{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual override returns (uint256[] memory) {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/extensions/ERC721Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC721Pausable is ERC721, Pausable {\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../extensions/ERC721Enumerable.sol\";\nimport \"../extensions/ERC721Burnable.sol\";\nimport \"../extensions/ERC721Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev {ERC721} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *  - token ID and URI autogeneration\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC721PresetMinterPauserAutoId is\n    Context,\n    AccessControlEnumerable,\n    ERC721Enumerable,\n    ERC721Burnable,\n    ERC721Pausable\n{\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    Counters.Counter private _tokenIdTracker;\n\n    string private _baseTokenURI;\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * Token URIs will be autogenerated based on `baseURI` and their token IDs.\n     * See {ERC721-tokenURI}.\n     */\n    constructor(string memory name, string memory symbol, string memory baseTokenURI) ERC721(name, symbol) {\n        _baseTokenURI = baseTokenURI;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    /**\n     * @dev Creates a new token for `to`. Its token ID will be automatically\n     * assigned (and available on the emitted {IERC721-Transfer} event), and the token\n     * URI autogenerated based on the base URI passed at construction.\n     *\n     * See {ERC721-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have minter role to mint\");\n\n        // We cannot just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(to, _tokenIdTracker.current());\n        _tokenIdTracker.increment();\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlEnumerable, ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Quoter Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoter {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountIn The desired input amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountOut The desired output amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/ICryptoKitties.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\n/**\n * @title TestSuperRareV1\n * @author NFTfi\n * @dev Test contract with SuperRareV1 ERC721 related functionalities.\n * Extracted from https://etherscan.io/address/0x41a322b28d0ff354040e2cbc676f0320d8c8850d#code\n */\ninterface ICryptoKitties {\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    function approve(address _to, uint256 _tokenId) external;\n\n    function transfer(address _to, uint256 _tokenId) external;\n\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Required methods\n    function totalSupply() external view returns (uint256 total);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IDirectLoanCoordinator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\n/**\n * @title IDirectLoanCoordinator\n * @author NFTfi\n * @dev DirectLoanCoordinator interface.\n */\ninterface IDirectLoanCoordinator {\n    enum StatusType {\n        NOT_EXISTS,\n        NEW,\n        REPAID,\n        LIQUIDATED\n    }\n\n    /**\n     * @notice This struct contains data related to a loan\n     *\n     * @param smartNftId - The id of both the promissory note and obligation receipt.\n     * @param status - The status in which the loan currently is.\n     * @param loanContract - Address of the LoanType contract that created the loan.\n     */\n    struct Loan {\n        address loanContract;\n        uint64 smartNftId;\n        StatusType status;\n    }\n\n    function registerLoan(address _lender, bytes32 _loanType) external returns (uint32);\n\n    function resetSmartNfts(uint32 _loanId, address _borrower) external;\n\n    function mintObligationReceipt(uint32 _loanId, address _borrower) external;\n\n    function resolveLoan(uint32 _loanId, bool liquidated) external;\n\n    function promissoryNoteToken() external view returns (address);\n\n    function obligationReceiptToken() external view returns (address);\n\n    function getLoanData(uint32 _loanId) external view returns (Loan memory);\n\n    function isValidLoanId(uint32 _loanId, address _loanContract) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC998ERC1155TopDown.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\ninterface IERC998ERC1155TopDown {\n    event Received1155Child(\n        address indexed from,\n        uint256 indexed toTokenId,\n        address indexed childContract,\n        uint256 childTokenId,\n        uint256 amount\n    );\n    event Transfer1155Child(\n        uint256 indexed fromTokenId,\n        address indexed to,\n        address indexed childContract,\n        uint256 childTokenId,\n        uint256 amount\n    );\n    event Transfer1155BatchChild(\n        uint256 indexed fromTokenId,\n        address indexed to,\n        address indexed childContract,\n        uint256[] childTokenIds,\n        uint256[] amounts\n    );\n\n    function safeTransferChild(\n        uint256 fromTokenId,\n        address to,\n        address childContract,\n        uint256 childTokenId,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferChild(\n        uint256 fromTokenId,\n        address to,\n        address childContract,\n        uint256[] calldata childTokenIds,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function childBalance(uint256 tokenId, address childContract, uint256 childTokenId) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC998ERC20TopDown.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\ninterface IERC998ERC20TopDown {\n    event ReceivedERC20(\n        address indexed _from,\n        uint256 indexed _tokenId,\n        address indexed _erc20Contract,\n        uint256 _value\n    );\n    event TransferERC20(uint256 indexed _tokenId, address indexed _to, address indexed _erc20Contract, uint256 _value);\n\n    function balanceOfERC20(uint256 _tokenId, address __erc20Contract) external view returns (uint256);\n\n    function tokenFallback(address _from, uint256 _value, bytes calldata _data) external;\n\n    function transferERC20(uint256 _tokenId, address _to, address _erc20Contract, uint256 _value) external;\n\n    function transferERC223(\n        uint256 _tokenId,\n        address _to,\n        address _erc223Contract,\n        uint256 _value,\n        bytes calldata _data\n    ) external;\n\n    function getERC20(address _from, uint256 _tokenId, address _erc20Contract, uint256 _value) external;\n}\n"
    },
    "contracts/interfaces/IERC998ERC20TopDownEnumerable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\ninterface IERC998ERC20TopDownEnumerable {\n    function totalERC20Contracts(uint256 _tokenId) external view returns (uint256);\n\n    function erc20ContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IERC998ERC721TopDown.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\ninterface IERC998ERC721TopDown {\n    event ReceivedChild(\n        address indexed _from,\n        uint256 indexed _tokenId,\n        address indexed _childContract,\n        uint256 _childTokenId\n    );\n    event TransferChild(\n        uint256 indexed tokenId,\n        address indexed _to,\n        address indexed _childContract,\n        uint256 _childTokenId\n    );\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _childTokenId,\n        bytes calldata _data\n    ) external returns (bytes4);\n\n    function transferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external;\n\n    function safeTransferChild(\n        uint256 _fromTokenId,\n        address _to,\n        address _childContract,\n        uint256 _childTokenId\n    ) external;\n\n    function safeTransferChild(\n        uint256 _fromTokenId,\n        address _to,\n        address _childContract,\n        uint256 _childTokenId,\n        bytes memory _data\n    ) external;\n\n    function transferChildToParent(\n        uint256 _fromTokenId,\n        address _toContract,\n        uint256 _toTokenId,\n        address _childContract,\n        uint256 _childTokenId,\n        bytes memory _data\n    ) external;\n\n    // getChild function enables older contracts like cryptokitties to be transferred into a composable\n    // The _childContract must approve this contract. Then getChild can be called.\n    function getChild(address _from, uint256 _tokenId, address _childContract, uint256 _childTokenId) external;\n\n    function rootOwnerOf(uint256 _tokenId) external view returns (bytes32 rootOwner);\n\n    function rootOwnerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 rootOwner);\n\n    function ownerOfChild(\n        address _childContract,\n        uint256 _childTokenId\n    ) external view returns (bytes32 parentTokenOwner, uint256 parentTokenId);\n}\n"
    },
    "contracts/interfaces/IERC998ERC721TopDownEnumerable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\ninterface IERC998ERC721TopDownEnumerable {\n    function totalChildContracts(uint256 _tokenId) external view returns (uint256);\n\n    function childContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address childContract);\n\n    function totalChildTokens(uint256 _tokenId, address _childContract) external view returns (uint256);\n\n    function childTokenByIndex(\n        uint256 _tokenId,\n        address _childContract,\n        uint256 _index\n    ) external view returns (uint256 childTokenId);\n}\n"
    },
    "contracts/interfaces/INftfiHub.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\n/**\n * @title INftfiHub\n * @author NFTfi\n * @dev NftfiHub interface\n */\ninterface INftfiHub {\n    function setContract(string calldata _contractKey, address _contractAddress) external;\n\n    function getContract(bytes32 _contractKey) external view returns (address);\n}\n"
    },
    "contracts/interfaces/INftTypeRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\n/**\n * @title INftTypeRegistry\n * @author NFTfi\n * @dev Interface for NFT Types Registry supported by NFTfi.\n */\ninterface INftTypeRegistry {\n    function setNftType(bytes32 _nftType, address _nftWrapper) external;\n\n    function getNftTypeWrapper(bytes32 _nftType) external view returns (address);\n}\n"
    },
    "contracts/interfaces/INftWrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\n/**\n * @title INftTypeRegistry\n * @author NFTfi\n * @dev Interface for NFT Wrappers.\n */\ninterface INftWrapper {\n    function transferNFT(address from, address to, address nftContract, uint256 tokenId) external returns (bool);\n\n    function approveNFT(address to, address nftContract, uint256 tokenId) external returns (bool);\n\n    function isOwner(address owner, address nftContract, uint256 tokenId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IPermittedERC20s.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\ninterface IPermittedERC20s {\n    function getERC20Permit(address _erc20) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IPermittedNFTs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\ninterface IPermittedNFTs {\n    function setNFTPermit(address _nftContract, string memory _nftType) external;\n\n    function getNFTPermit(address _nftContract) external view returns (bytes32);\n\n    function getNFTWrapper(address _nftContract) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IPermittedPartners.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\ninterface IPermittedPartners {\n    function getPartnerPermit(address _partner) external view returns (uint16);\n}\n"
    },
    "contracts/interfaces/IPunks.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\ninterface IPunks {\n    function balanceOf(address owner) external view returns (uint256);\n\n    function punkIndexToAddress(uint256 punkIndex) external view returns (address);\n\n    function transferPunk(address to, uint256 punkIndex) external;\n\n    function offerPunkForSaleToAddress(uint256 punkIndex, uint256 minSalePriceInWei, address toAddress) external;\n\n    function buyPunk(uint256 punkIndex) external payable;\n}\n"
    },
    "contracts/loans/BaseLoan.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {Ownable} from \"../utils/Ownable.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/**\n * @title  BaseLoan\n * @author NFTfi\n * @dev Implements base functionalities common to all Loan types.\n * Mostly related to governance and security.\n */\nabstract contract BaseLoan is Ownable, Pausable, ReentrancyGuard {\n    /* *********** */\n    /* CONSTRUCTOR */\n    /* *********** */\n\n    /**\n     * @notice Sets the admin of the contract.\n     *\n     * @param _admin - Initial admin of this contract.\n     */\n    constructor(address _admin) Ownable(_admin) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /* ********* */\n    /* FUNCTIONS */\n    /* ********* */\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - Only the owner can call this method.\n     * - The contract must not be paused.\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - Only the owner can call this method.\n     * - The contract must be paused.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/loans/direct/DirectLoanCoordinator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {SmartNft} from \"../../smartNft/SmartNft.sol\";\nimport {IDirectLoanCoordinator} from \"../../interfaces/IDirectLoanCoordinator.sol\";\nimport {INftfiHub} from \"../../interfaces/INftfiHub.sol\";\nimport {Ownable} from \"../../utils/Ownable.sol\";\nimport {ContractKeys} from \"../../utils/ContractKeys.sol\";\n\n/**\n * @title  DirectLoanCoordinator\n * @author NFTfi\n * @notice This contract is in charge of coordinating the creation, disctubution and desctruction of the SmartNfts\n * related to a loan, the Promossory Note and Obligaiton Receipt.\n */\ncontract DirectLoanCoordinator is IDirectLoanCoordinator, Ownable {\n    /* ******* */\n    /* STORAGE */\n    /* ******* */\n\n    // solhint-disable-next-line immutable-vars-naming\n    INftfiHub public immutable hub;\n\n    /**\n     * @dev For each loan type, records the address of the contract that implements the type\n     */\n    mapping(bytes32 => address) private typeContracts;\n    /**\n     * @dev reverse mapping of loanTypes - for each contract address, records the associated loan type\n     */\n    mapping(address => bytes32) private contractTypes;\n\n    /**\n     * @notice A continuously increasing counter that simultaneously allows every loan to have a unique ID and provides\n     * a running count of how many loans have been started by this contract.\n     */\n    uint32 public totalNumLoans = 0;\n\n    uint32 public smartNftIdCounter = 0;\n\n    // The address that deployed this contract\n    // solhint-disable-next-line immutable-vars-naming\n    address private immutable _deployer;\n    bool private _initialized = false;\n\n    mapping(uint32 => Loan) private loans;\n\n    address public override promissoryNoteToken;\n    address public override obligationReceiptToken;\n\n    /* ****** */\n    /* EVENTS */\n    /* ****** */\n\n    event UpdateStatus(\n        uint32 indexed loanId,\n        uint64 indexed smartNftId,\n        address indexed loanContract,\n        StatusType newStatus\n    );\n\n    /**\n     * @notice This event is fired whenever the admins register a loan type.\n     *\n     * @param loanType - Loan type represented by keccak256('loan type').\n     * @param loanContract - Address of the loan type contract.\n     */\n    event TypeUpdated(bytes32 indexed loanType, address indexed loanContract);\n\n    /**\n     * @dev Function using this modifier can only be executed after this contract is initialized\n     *\n     */\n    modifier onlyInitialized() {\n        // solhint-disable-next-line custom-errors\n        require(_initialized, \"not initialized\");\n\n        _;\n    }\n\n    /* *********** */\n    /* CONSTRUCTOR */\n    /* *********** */\n\n    /**\n     * @notice Sets the admin of the contract.\n     * Initializes `contractTypes` with a batch of loan types. Sets `NftfiHub`.\n     *\n     * @param  _nftfiHub - Address of the NftfiHub contract\n     * @param _admin - Initial admin of this contract.\n     * @param _loanTypes - Loan types represented by keccak256('loan type').\n     * @param _loanContracts - The addresses of each wrapper contract that implements the loan type's behaviour.\n     */\n    constructor(\n        address _nftfiHub,\n        address _admin,\n        string[] memory _loanTypes,\n        address[] memory _loanContracts\n    ) Ownable(_admin) {\n        hub = INftfiHub(_nftfiHub);\n        _deployer = msg.sender;\n        _registerLoanTypes(_loanTypes, _loanContracts);\n    }\n\n    /**\n     * @dev Sets `promissoryNoteToken` and `obligationReceiptToken`.\n     * It can be executed once by the deployer.\n     *\n     * @param  _promissoryNoteToken - Promissory Note Token address\n     * @param  _obligationReceiptToken - Obligaiton Recipt Token address\n     */\n    function initialize(address _promissoryNoteToken, address _obligationReceiptToken) external {\n        // solhint-disable-next-line custom-errors\n        require(msg.sender == _deployer, \"only deployer\");\n        // solhint-disable-next-line custom-errors\n        require(!_initialized, \"already initialized\");\n        // solhint-disable-next-line custom-errors\n        require(_promissoryNoteToken != address(0), \"promissoryNoteToken is zero\");\n        // solhint-disable-next-line custom-errors\n        require(_obligationReceiptToken != address(0), \"obligationReceiptToken is zero\");\n\n        _initialized = true;\n        promissoryNoteToken = _promissoryNoteToken;\n        obligationReceiptToken = _obligationReceiptToken;\n    }\n\n    /**\n     * @dev This is called by the LoanType beginning the new loan.\n     * It initialize the new loan data, mints both PromissoryNote and ObligationReceipt SmartNft's and returns the\n     * new loan id.\n     *\n     * @param _lender - Address of the lender\n     * @param _loanType - The type of the loan\n     */\n    function registerLoan(address _lender, bytes32 _loanType) external override onlyInitialized returns (uint32) {\n        address loanContract = msg.sender;\n\n        // solhint-disable-next-line custom-errors\n        require(getContractFromType(_loanType) == loanContract, \"Caller must be registered for loan type\");\n\n        // (loanIds start at 1)\n        totalNumLoans += 1;\n        smartNftIdCounter += 1;\n\n        uint64 smartNftId = uint64(uint256(keccak256(abi.encodePacked(address(this), smartNftIdCounter))));\n\n        Loan memory newLoan = Loan({status: StatusType.NEW, loanContract: loanContract, smartNftId: smartNftId});\n\n        // Issue an ERC721 promissory note to the lender that gives them the\n        // right to either the principal-plus-interest or the collateral.\n        SmartNft(promissoryNoteToken).mint(_lender, smartNftId, abi.encode(totalNumLoans));\n\n        loans[totalNumLoans] = newLoan;\n\n        emit UpdateStatus(totalNumLoans, smartNftId, loanContract, StatusType.NEW);\n\n        return totalNumLoans;\n    }\n\n    function mintObligationReceipt(uint32 _loanId, address _borrower) external override onlyInitialized {\n        address loanContract = msg.sender;\n\n        // solhint-disable-next-line custom-errors\n        require(getTypeFromContract(loanContract) != bytes32(0), \"Caller must a be registered loan type\");\n\n        uint64 smartNftId = loans[_loanId].smartNftId;\n        // solhint-disable-next-line custom-errors\n        require(smartNftId != 0, \"loan doesn't exist\");\n        // solhint-disable-next-line custom-errors\n        require(SmartNft(promissoryNoteToken).exists(smartNftId), \"Promissory note should exist\");\n        // solhint-disable-next-line custom-errors\n        require(!SmartNft(obligationReceiptToken).exists(smartNftId), \"Obligation r shouldn't exist\");\n\n        // Issue an ERC721 obligation receipt to the borrower that gives them the\n        // right to pay back the loan and get the collateral back.\n        SmartNft(obligationReceiptToken).mint(_borrower, smartNftId, abi.encode(_loanId));\n    }\n\n    function resetSmartNfts(uint32 _loanId, address _lender) external override onlyInitialized {\n        address loanContract = msg.sender;\n        // solhint-disable-next-line custom-errors\n        require(getTypeFromContract(loanContract) != bytes32(0), \"Caller must a be registered loan type\");\n\n        uint64 oldSmartNftId = loans[_loanId].smartNftId;\n        // solhint-disable-next-line custom-errors\n        require(oldSmartNftId != 0, \"loan doesn't exist\");\n        // solhint-disable-next-line custom-errors\n        require(SmartNft(promissoryNoteToken).exists(oldSmartNftId), \"Promissory note should exist\");\n\n        SmartNft(promissoryNoteToken).burn(oldSmartNftId);\n\n        // (loanIds start at 1)\n        smartNftIdCounter += 1;\n        uint64 newSmartNftId = uint64(uint256(keccak256(abi.encodePacked(address(this), smartNftIdCounter))));\n        SmartNft(promissoryNoteToken).mint(_lender, newSmartNftId, abi.encode(_loanId));\n        loans[_loanId].smartNftId = newSmartNftId;\n\n        if (SmartNft(obligationReceiptToken).exists(oldSmartNftId)) {\n            SmartNft(obligationReceiptToken).burn(oldSmartNftId);\n        }\n    }\n\n    /**\n     * @dev This is called by the LoanType who created the loan, when a loan is resolved whether by paying back or\n     * liquidating the loan.\n     * It sets the loan as `RESOLVED` and burns both PromossoryNote and ObligationReceipt SmartNft's.\n     *\n     * @param _loanId - Id of the loan\n     */\n    function resolveLoan(uint32 _loanId, bool _repaid) external override onlyInitialized {\n        Loan storage loan = loans[_loanId];\n        // solhint-disable-next-line custom-errors\n        require(loan.status == StatusType.NEW, \"Loan status must be New\");\n        // solhint-disable-next-line custom-errors\n        require(loan.loanContract == msg.sender, \"Not the same Contract that registered Loan\");\n\n        if (_repaid) {\n            loan.status = StatusType.REPAID;\n        } else {\n            loan.status = StatusType.LIQUIDATED;\n        }\n\n        SmartNft(promissoryNoteToken).burn(loan.smartNftId);\n        if (SmartNft(obligationReceiptToken).exists(loan.smartNftId)) {\n            SmartNft(obligationReceiptToken).burn(loan.smartNftId);\n        }\n\n        emit UpdateStatus(_loanId, loan.smartNftId, msg.sender, loan.status);\n    }\n\n    /**\n     * @dev Returns loan's data for a given id.\n     *\n     * @param _loanId - Id of the loan\n     */\n    function getLoanData(uint32 _loanId) external view override returns (Loan memory) {\n        return loans[_loanId];\n    }\n\n    /**\n     * @dev checks if the given id is valid for the given loan contract address\n     * @param _loanId - Id of the loan\n     * @param _loanContract - address og the loan contract\n     */\n    function isValidLoanId(uint32 _loanId, address _loanContract) external view override returns (bool validity) {\n        validity = loans[_loanId].loanContract == _loanContract;\n    }\n\n    /**\n     * @notice  Set or update the contract address that implements the given Loan Type.\n     * Set address(0) for a loan type for un-register such type.\n     *\n     * @param _loanType - Loan type represented by 'loan type'.\n     * @param _loanContract - The address of the wrapper contract that implements the loan type's behaviour.\n     */\n    function registerLoanType(string memory _loanType, address _loanContract) external onlyOwner {\n        _registerLoanType(_loanType, _loanContract);\n    }\n\n    /**\n     * @notice  Batch set or update the contract addresses that implement the given batch Loan Type.\n     * Set address(0) for a loan type for un-register such type.\n     *\n     * @param _loanTypes - Loan types represented by 'loan type'.\n     * @param _loanContracts - The addresses of each wrapper contract that implements the loan type's behaviour.\n     */\n    function registerLoanTypes(string[] memory _loanTypes, address[] memory _loanContracts) external onlyOwner {\n        _registerLoanTypes(_loanTypes, _loanContracts);\n    }\n\n    /**\n     * @notice This function can be called by anyone to get the contract address that implements the given loan type.\n     *\n     * @param  _loanType - The loan type, e.g. bytes32(\"DIRECT_LOAN_FIXED\"), or bytes32(\"DIRECT_LOAN_PRO_RATED\").\n     */\n    function getContractFromType(bytes32 _loanType) public view returns (address) {\n        return typeContracts[_loanType];\n    }\n\n    /**\n     * @notice This function can be called by anyone to get the loan type of the given contract address.\n     *\n     * @param  _loanContract - The loan contract\n     */\n    function getTypeFromContract(address _loanContract) public view returns (bytes32) {\n        return contractTypes[_loanContract];\n    }\n\n    /**\n     * @notice  Set or update the contract address that implements the given Loan Type.\n     * Set address(0) for a loan type for un-register such type.\n     *\n     * @param _loanType - Loan type represented by 'loan type').\n     * @param _loanContract - The address of the wrapper contract that implements the loan type's behaviour.\n     */\n    function _registerLoanType(string memory _loanType, address _loanContract) internal {\n        // solhint-disable-next-line custom-errors\n        require(bytes(_loanType).length != 0, \"loanType is empty\");\n        bytes32 loanTypeKey = ContractKeys.getIdFromStringKey(_loanType);\n\n        typeContracts[loanTypeKey] = _loanContract;\n        contractTypes[_loanContract] = loanTypeKey;\n\n        emit TypeUpdated(loanTypeKey, _loanContract);\n    }\n\n    /**\n     * @notice  Batch set or update the contract addresses that implement the given batch Loan Type.\n     * Set address(0) for a loan type for un-register such type.\n     *\n     * @param _loanTypes - Loan types represented by keccak256('loan type').\n     * @param _loanContracts - The addresses of each wrapper contract that implements the loan type's behaviour.\n     */\n    function _registerLoanTypes(string[] memory _loanTypes, address[] memory _loanContracts) internal {\n        // solhint-disable-next-line custom-errors\n        require(_loanTypes.length == _loanContracts.length, \"function information arity mismatch\");\n\n        for (uint256 i; i < _loanTypes.length; ++i) {\n            _registerLoanType(_loanTypes[i], _loanContracts[i]);\n        }\n    }\n}\n"
    },
    "contracts/loans/direct/loanTypes/DirectLoanBaseMinimal.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {IDirectLoanBase} from \"./IDirectLoanBase.sol\";\nimport {LoanData} from \"./LoanData.sol\";\nimport {LoanChecksAndCalculations} from \"./LoanChecksAndCalculations.sol\";\nimport {BaseLoan} from \"../../BaseLoan.sol\";\nimport {NftReceiver} from \"../../../utils/NftReceiver.sol\";\nimport {NFTfiSigningUtils} from \"../../../utils/NFTfiSigningUtils.sol\";\nimport {INftfiHub} from \"../../../interfaces/INftfiHub.sol\";\nimport {ContractKeys} from \"../../../utils/ContractKeys.sol\";\nimport {IDirectLoanCoordinator} from \"../../../interfaces/IDirectLoanCoordinator.sol\";\nimport {INftWrapper} from \"../../../interfaces/INftWrapper.sol\";\nimport {IPermittedERC20s} from \"../../../interfaces/IPermittedERC20s.sol\";\nimport {IPermittedNFTs} from \"../../../interfaces/IPermittedNFTs.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title  DirectLoanBase\n * @author NFTfi\n * @notice Main contract for NFTfi Direct Loans Type. This contract manages the ability to create NFT-backed\n * peer-to-peer loans.\n *\n * There are two ways to commence an NFT-backed loan:\n *\n * a. The borrower accepts a lender's offer by calling `acceptOffer`.\n *   1. the borrower calls nftContract.approveAll(NFTfi), approving the NFTfi contract to move their NFT's on their\n * be1alf.\n *   2. the lender calls erc20Contract.approve(NFTfi), allowing NFTfi to move the lender's ERC20 tokens on their\n * behalf.\n *   3. the lender signs an off-chain message, proposing its offer terms.\n *   4. the borrower calls `acceptOffer` to accept these terms and enter into the loan. The NFT is stored in\n * the contract, the borrower receives the loan principal in the specified ERC20 currency, the lender receives an\n * NFTfi promissory note (in ERC721 form) that represents the rights to either the principal-plus-interest, or the\n * underlying NFT collateral if the borrower does not pay back in time, and the borrower receives obligation receipt\n * (in ERC721 form) that gives them the right to pay back the loan and get the collateral back.\n *\n * The lender can freely transfer and trade this ERC721 promissory note as they wish, with the knowledge that\n * transferring the ERC721 promissory note tranfsers the rights to principal-plus-interest and/or collateral, and that\n * they will no longer have a claim on the loan. The ERC721 promissory note itself represents that claim.\n *\n * The borrower can freely transfer and trade this ERC721 obligaiton receipt as they wish, with the knowledge that\n * transferring the ERC721 obligaiton receipt tranfsers the rights right to pay back the loan and get the collateral\n * back.\n *\n * A loan may end in one of two ways:\n * - First, a borrower may call NFTfi.payBackLoan() and pay back the loan plus interest at any time, in which case they\n * receive their NFT back in the same transaction.\n * - Second, if the loan's duration has passed and the loan has not been paid back yet, a lender can call\n * NFTfi.liquidateOverdueLoan(), in which case they receive the underlying NFT collateral and forfeit the rights to the\n * principal-plus-interest, which the borrower now keeps.\n *\n *\n * If the loan was created as a ProRated type loan (pro-rata interest loan), then the user only pays the principal plus\n * pro-rata interest if repaid early.\n * However, if the loan was was created as a Fixed type loan (agreed to be a fixed-repayment loan), then the borrower\n * pays the maximumRepaymentAmount regardless of whether they repay early or not.\n *\n */\nabstract contract DirectLoanBaseMinimal is IDirectLoanBase, IPermittedERC20s, BaseLoan, NftReceiver, LoanData {\n    using SafeERC20 for IERC20;\n\n    /* ******* */\n    /* STORAGE */\n    /* ******* */\n\n    uint16 public constant HUNDRED_PERCENT = 10000;\n\n    // solhint-disable-next-line immutable-vars-naming\n    bytes32 public immutable override LOAN_COORDINATOR;\n\n    /**\n     * @notice The maximum duration of any loan started for this loan type, measured in seconds. This is both a\n     * sanity-check for borrowers and an upper limit on how long admins will have to support v1 of this contract if they\n     * eventually deprecate it, as well as a check to ensure that the loan duration never exceeds the space alotted for\n     * it in the loan struct.\n     */\n    uint256 public override maximumLoanDuration = 53 weeks;\n\n    /**\n     * @notice The percentage of interest earned by lenders on this platform that is taken by the contract admin's as a\n     * fee, measured in basis points (hundreths of a percent). The max allowed value is 10000.\n     */\n    uint16 public override adminFeeInBasisPoints = 500;\n\n    /**\n     * @notice A mapping from a loan's identifier to the loan's details, represted by the loan struct.\n     */\n    mapping(uint32 => LoanTerms) public override loanIdToLoan;\n    mapping(uint32 => LoanExtras) public loanIdToLoanExtras;\n\n    /**\n     * @notice A mapping tracking whether a loan has either been repaid or liquidated. This prevents an attacker trying\n     * to repay or liquidate the same loan twice.\n     */\n    mapping(uint32 => bool) public override loanRepaidOrLiquidated;\n\n    /**\n     * @dev keeps track of tokens being held as loan collateral, so we dont allow these\n     * to be transferred with the aridrop draining functions\n     * nft contract address => nft id => amount (in case of 1155)\n     */\n    mapping(address => mapping(uint256 => uint256)) private _escrowTokens;\n\n    /**\n     * @dev keeps track of payed back erc20 tokens being held in escrow of finished loans, so we dont allow these\n     * to be transferred with the aridrop draining functions\n     * token contract => amount\n     */\n    mapping(address => uint256) private _escrowErc20Tokens;\n\n    /**\n     * @dev keeps track of payed back erc20 tokens being held in escrow of finished loans for each lender\n     * lender => token contract => amount\n     */\n    mapping(address => mapping(address => uint256)) private _payBackEscrow;\n\n    /**\n     * @notice A mapping that takes both a user's address and a loan nonce that was first used when signing an off-chain\n     * order and checks whether that nonce has previously either been used for a loan, or has been pre-emptively\n     * cancelled. The nonce referred to here is not the same as an Ethereum account's nonce. We are referring instead to\n     * nonces that are used by both the lender and the borrower when they are first signing off-chain NFTfi orders.\n     *\n     * These nonces can be any uint256 value that the user has not previously used to sign an off-chain order. Each\n     * nonce can be used at most once per user within NFTfi, regardless of whether they are the lender or the borrower\n     * in that situation. This serves two purposes. First, it prevents replay attacks where an attacker would submit a\n     * user's off-chain order more than once. Second, it allows a user to cancel an off-chain order by calling\n     * NFTfi.cancelLoanCommitmentBeforeLoanHasBegun(), which marks the nonce as used and prevents any future loan from\n     * using the user's off-chain order that contains that nonce.\n     */\n    mapping(address => mapping(uint256 => bool)) internal _nonceHasBeenUsedForUser;\n\n    /**\n     * @notice A mapping from an ERC20 currency address to whether that currency\n     * is permitted to be used by this contract.\n     */\n    mapping(address => bool) private erc20Permits;\n\n    // solhint-disable-next-line immutable-vars-naming\n    INftfiHub public immutable hub;\n\n    /* ****** */\n    /* EVENTS */\n    /* ****** */\n\n    /**\n     * @notice This event is fired whenever the admins change the percent of interest rates earned that they charge as a\n     * fee. Note that newAdminFee can never exceed 10,000, since the fee is measured in basis points.\n     *\n     * @param  newAdminFee - The new admin fee measured in basis points. This is a percent of the interest paid upon a\n     * loan's completion that go to the contract admins.\n     */\n    event AdminFeeUpdated(uint16 newAdminFee);\n\n    /**\n     * @notice This event is fired whenever the admins change the maximum duration of any loan started for this loan\n     * type.\n     *\n     * @param  newMaximumLoanDuration - The new maximum duration.\n     */\n    event MaximumLoanDurationUpdated(uint256 newMaximumLoanDuration);\n\n    /**\n     * @notice This event is fired whenever a borrower begins a loan by calling NFTfi.beginLoan(), which can only occur\n     * after both the lender and borrower have approved their ERC721 and ERC20 contracts to use NFTfi, and when they\n     * both have signed off-chain messages that agree on the terms of the loan.\n     *\n     * @param  loanId - A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     * @param  borrower - The address of the borrower.\n     * @param  lender - The address of the lender. The lender can change their address by transferring the NFTfi ERC721\n     * token that they received when the loan began.\n     */\n    event LoanStarted(\n        uint32 indexed loanId,\n        address indexed borrower,\n        address indexed lender,\n        LoanTerms loanTerms,\n        LoanExtras loanExtras\n    );\n\n    /**\n     * @notice This event is fired whenever a borrower successfully repays their loan, paying\n     * principal-plus-interest-minus-fee to the lender in loanERC20Denomination, paying fee to owner in\n     * loanERC20Denomination, and receiving their NFT collateral back.\n     *\n     * @param  loanId - A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     * @param  borrower - The address of the borrower.\n     * @param  lender - The address of the lender. The lender can change their address by transferring the NFTfi ERC721\n     * token that they received when the loan began.\n     * @param  loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\n     * the loan, measured in loanERC20Denomination's smallest units.\n     * @param  nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\n     * loan. The NFT is stored within this contract during the duration of the loan.\n     * @param  amountPaidToLender The amount of ERC20 that the borrower paid to the lender, measured in the smalled\n     * units of loanERC20Denomination.\n     * @param  adminFee The amount of interest paid to the contract admins, measured in the smalled units of\n     * loanERC20Denomination and determined by adminFeeInBasisPoints. This amount never exceeds the amount of interest\n     * earned.\n     * @param  revenueShare The amount taken from admin fee amount shared with the partner.\n     * @param  revenueSharePartner  - The address of the partner that will receive the revenue share.\n     * @param  nftCollateralContract - The ERC721 contract of the NFT collateral\n     * @param  loanERC20Denomination - The ERC20 contract of the currency being used as principal/interest for this\n     * loan.\n     */\n    event LoanRepaid(\n        uint32 indexed loanId,\n        address indexed borrower,\n        address indexed lender,\n        uint256 loanPrincipalAmount,\n        uint256 nftCollateralId,\n        uint256 amountPaidToLender,\n        uint256 adminFee,\n        uint256 revenueShare,\n        address revenueSharePartner,\n        address nftCollateralContract,\n        address loanERC20Denomination\n    );\n\n    /**\n     * @notice This event is fired whenever a loan is repaid into escrow\n     *\n     * @param  loanId - A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     */\n    event EscrowRepay(uint32 indexed loanId);\n\n    /**\n     * @notice This event is fired whenever a lender liquidates an outstanding loan that is owned to them that has\n     * exceeded its duration. The lender receives the underlying NFT collateral, and the borrower no longer needs to\n     * repay the loan principal-plus-interest.\n     *\n     * @param  loanId - A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     * @param  borrower - The address of the borrower.\n     * @param  lender - The address of the lender. The lender can change their address by transferring the NFTfi ERC721\n     * token that they received when the loan began.\n     * @param  loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\n     * the loan, measured in loanERC20Denomination's smallest units.\n     * @param  nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\n     * loan. The NFT is stored within this contract during the duration of the loan.\n     * @param  loanMaturityDate - The unix time (measured in seconds) that the loan became due and was eligible for\n     * liquidation.\n     * @param  loanLiquidationDate - The unix time (measured in seconds) that liquidation occurred.\n     * @param  nftCollateralContract - The ERC721 contract of the NFT collateral\n     */\n    event LoanLiquidated(\n        uint32 indexed loanId,\n        address indexed borrower,\n        address indexed lender,\n        uint256 loanPrincipalAmount,\n        uint256 nftCollateralId,\n        uint256 loanMaturityDate,\n        uint256 loanLiquidationDate,\n        address nftCollateralContract\n    );\n\n    /**\n     * @notice This event is fired when some of the terms of a loan are being renegotiated.\n     *\n     * @param loanId - The unique identifier for the loan to be renegotiated\n     * @param newLoanDuration - The new amount of time (measured in seconds) that can elapse before the lender can\n     * liquidate the loan and seize the underlying collateral NFT.\n     * @param newMaximumRepaymentAmount - The new maximum amount of money that the borrower would be required to\n     * retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The\n     * borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay\n     * early.\n     * @param renegotiationFee Agreed upon fee in loan denomination that borrower pays for the lender for the\n     * renegotiation, has to be paid with an ERC20 transfer loanERC20Denomination token, uses transfer from,\n     * frontend will have to propmt an erc20 approve for this from the borrower to the lender\n     * @param renegotiationAdminFee renegotiationFee admin portion based on determined by adminFeeInBasisPoints\n     */\n    event LoanRenegotiated(\n        uint32 indexed loanId,\n        address indexed borrower,\n        address indexed lender,\n        uint32 newLoanDuration,\n        uint256 newMaximumRepaymentAmount,\n        uint256 renegotiationFee,\n        uint256 renegotiationAdminFee\n    );\n\n    /**\n     * @notice This event is fired whenever the admin sets a ERC20 permit.\n     *\n     * @param erc20Contract - Address of the ERC20 contract.\n     * @param isPermitted - Signals ERC20 permit.\n     */\n    event ERC20Permit(address indexed erc20Contract, bool isPermitted);\n\n    /* ************* */\n    /* CUSTOM ERRORS */\n    /* ************* */\n\n    error LoanDurationOverflow();\n    error BasisPointsTooHigh();\n    error NoTokensOwned();\n    error TokensInEscrow();\n    error FunctionInformationArityMismatch();\n    error TokenIsCollateral();\n    error NFTNotOwned();\n    error SenderNotBorrower();\n    error NoNFTsOwned();\n    error NoTokensInEscrow();\n    error LoanAlreadyRepaidOrLiquidated();\n    error LoanNotOverdueYet();\n    error OnlyLenderCanLiquidate();\n    error InvalidNonce();\n    error RenegotiationSignatureInvalid();\n    error ERC20ZeroAddress();\n    error CurrencyDenominationNotPermitted();\n    error NFTCollateralContractNotPermitted();\n    error LoanDurationExceedsMaximum();\n    error LoanDurationCannotBeZero();\n    error AdminFeeChanged();\n\n    /* *********** */\n    /* CONSTRUCTOR */\n    /* *********** */\n\n    /**\n     * @dev Sets `hub`\n     *\n     * @param _admin - Initial admin of this contract.\n     * @param  _nftfiHub - NFTfiHub address\n     * @param  _loanCoordinatorKey -\n     * @param  _permittedErc20s -\n     */\n    constructor(\n        address _admin,\n        address _nftfiHub,\n        bytes32 _loanCoordinatorKey,\n        address[] memory _permittedErc20s\n    ) BaseLoan(_admin) {\n        hub = INftfiHub(_nftfiHub);\n        LOAN_COORDINATOR = _loanCoordinatorKey;\n        for (uint256 i; i < _permittedErc20s.length; ++i) {\n            _setERC20Permit(_permittedErc20s[i], true);\n        }\n    }\n\n    /* *************** */\n    /* ADMIN FUNCTIONS */\n    /* *************** */\n\n    /**\n     * @notice This function can be called by admins to change the maximumLoanDuration. Note that they can never change\n     * maximumLoanDuration to be greater than UINT32_MAX, since that's the maximum space alotted for the duration in the\n     * loan struct.\n     *\n     * @param _newMaximumLoanDuration - The new maximum loan duration, measured in seconds.\n     */\n    function updateMaximumLoanDuration(uint256 _newMaximumLoanDuration) external onlyOwner {\n        if (_newMaximumLoanDuration > uint256(type(uint32).max)) {\n            revert LoanDurationOverflow();\n        }\n        maximumLoanDuration = _newMaximumLoanDuration;\n        emit MaximumLoanDurationUpdated(_newMaximumLoanDuration);\n    }\n\n    /**\n     * @notice This function can be called by admins to change the percent of interest rates earned that they charge as\n     * a fee. Note that newAdminFee can never exceed 10,000, since the fee is measured in basis points.\n     *\n     * @param _newAdminFeeInBasisPoints - The new admin fee measured in basis points. This is a percent of the interest\n     * paid upon a loan's completion that go to the contract admins.\n     */\n    function updateAdminFee(uint16 _newAdminFeeInBasisPoints) external onlyOwner {\n        if (_newAdminFeeInBasisPoints > HUNDRED_PERCENT) {\n            revert BasisPointsTooHigh();\n        }\n        adminFeeInBasisPoints = _newAdminFeeInBasisPoints;\n        emit AdminFeeUpdated(_newAdminFeeInBasisPoints);\n    }\n\n    /**\n     * @notice used by the owner account to be able to drain ERC20 tokens received as airdrops\n     * for the locked  collateral NFT-s\n     * @param _tokenAddress - address of the token contract for the token to be sent out\n     * @param _receiver - receiver of the token\n     */\n    function drainERC20Airdrop(address _tokenAddress, uint256 amount, address _receiver) external onlyOwner {\n        IERC20 tokenContract = IERC20(_tokenAddress);\n        uint256 balance = tokenContract.balanceOf(address(this));\n        if (balance == 0) {\n            revert NoTokensOwned();\n        }\n        if (balance - _escrowErc20Tokens[_tokenAddress] < amount) {\n            revert TokensInEscrow();\n        }\n        tokenContract.safeTransfer(_receiver, amount);\n    }\n\n    /**\n     * @notice This function can be called by admins to change the permitted status of an ERC20 currency. This includes\n     * both adding an ERC20 currency to the permitted list and removing it.\n     *\n     * @param _erc20 - The address of the ERC20 currency whose permit list status changed.\n     * @param _permit - The new status of whether the currency is permitted or not.\n     */\n    function setERC20Permit(address _erc20, bool _permit) external onlyOwner {\n        _setERC20Permit(_erc20, _permit);\n    }\n\n    /**\n     * @notice This function can be called by admins to change the permitted status of a batch of ERC20 currency. This\n     * includes both adding an ERC20 currency to the permitted list and removing it.\n     *\n     * @param _erc20s - The addresses of the ERC20 currencies whose permit list status changed.\n     * @param _permits - The new statuses of whether the currency is permitted or not.\n     */\n    function setERC20Permits(address[] memory _erc20s, bool[] memory _permits) external onlyOwner {\n        if (_erc20s.length != _permits.length) {\n            revert FunctionInformationArityMismatch();\n        }\n        for (uint256 i = 0; i < _erc20s.length; ++i) {\n            _setERC20Permit(_erc20s[i], _permits[i]);\n        }\n    }\n\n    /**\n     * @notice used by the owner account to be able to drain ERC721 tokens received as airdrops\n     * for the locked  collateral NFT-s\n     * @param _tokenAddress - address of the token contract for the token to be sent out\n     * @param _tokenId - id token to be sent out\n     * @param _receiver - receiver of the token\n     */\n    function drainERC721Airdrop(address _tokenAddress, uint256 _tokenId, address _receiver) external onlyOwner {\n        IERC721 tokenContract = IERC721(_tokenAddress);\n        if (_escrowTokens[_tokenAddress][_tokenId] > 0) {\n            revert TokenIsCollateral();\n        }\n        if (tokenContract.ownerOf(_tokenId) != address(this)) {\n            revert NFTNotOwned();\n        }\n        tokenContract.safeTransferFrom(address(this), _receiver, _tokenId);\n    }\n\n    /**\n     * @notice used by the owner account to be able to drain ERC1155 tokens received as airdrops\n     * for the locked  collateral NFT-s\n     * @param _tokenAddress - address of the token contract for the token to be sent out\n     * @param _tokenId - id token to be sent out\n     * @param _receiver - receiver of the token\n     */\n    function drainERC1155Airdrop(address _tokenAddress, uint256 _tokenId, address _receiver) external onlyOwner {\n        IERC1155 tokenContract = IERC1155(_tokenAddress);\n        uint256 amount = tokenContract.balanceOf(address(this), _tokenId);\n        if (_escrowTokens[_tokenAddress][_tokenId] > 0) {\n            revert TokenIsCollateral();\n        }\n        if (amount == 0) {\n            revert NoNFTsOwned();\n        }\n        tokenContract.safeTransferFrom(address(this), _receiver, _tokenId, amount, \"\");\n    }\n\n    function mintObligationReceipt(uint32 _loanId) external nonReentrant {\n        address borrower = loanIdToLoan[_loanId].borrower;\n        if (msg.sender != borrower) {\n            revert SenderNotBorrower();\n        }\n        IDirectLoanCoordinator loanCoordinator = IDirectLoanCoordinator(hub.getContract(LOAN_COORDINATOR));\n        loanCoordinator.mintObligationReceipt(_loanId, borrower);\n\n        delete loanIdToLoan[_loanId].borrower;\n    }\n\n    /**\n     * @dev makes possible to change loan duration and max repayment amount, loan duration even can be extended if\n     * loan was expired but not liquidated.\n     *\n     * @param _loanId - The unique identifier for the loan to be renegotiated\n     * @param _newLoanDuration - The new amount of time (measured in seconds) that can elapse before the lender can\n     * liquidate the loan and seize the underlying collateral NFT.\n     * @param _newMaximumRepaymentAmount - The new maximum amount of money that the borrower would be required to\n     * retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The\n     * borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay\n     * early.\n     * @param _renegotiationFee Agreed upon fee in ether that borrower pays for the lender for the renegitiation\n     * @param _lenderNonce - The nonce referred to here is not the same as an Ethereum account's nonce. We are\n     * referring instead to nonces that are used by both the lender and the borrower when they are first signing\n     * off-chain NFTfi orders. These nonces can be any uint256 value that the user has not previously used to sign an\n     * off-chain order. Each nonce can be used at most once per user within NFTfi, regardless of whether they are the\n     * lender or the borrower in that situation. This serves two purposes:\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\n     * , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\n     * that nonce.\n     * @param _expiry - The date when the renegotiation offer expires\n     * @param _lenderSignature - The ECDSA signature of the lender, obtained off-chain ahead of time, signing the\n     * following combination of parameters:\n     * - _loanId\n     * - _newLoanDuration\n     * - _newMaximumRepaymentAmount\n     * - _lender\n     * - _expiry\n     *  - address of this contract\n     * - chainId\n     */\n    function renegotiateLoan(\n        uint32 _loanId,\n        uint32 _newLoanDuration,\n        uint256 _newMaximumRepaymentAmount,\n        uint256 _renegotiationFee,\n        uint256 _lenderNonce,\n        uint256 _expiry,\n        bytes memory _lenderSignature\n    ) external whenNotPaused nonReentrant {\n        _renegotiateLoan(\n            _loanId,\n            _newLoanDuration,\n            _newMaximumRepaymentAmount,\n            _renegotiationFee,\n            _lenderNonce,\n            _expiry,\n            _lenderSignature\n        );\n    }\n\n    /**\n     * @notice This function is called by a anyone to repay a loan. It can be called at any time after the loan has\n     * begun and before loan expiry.. The caller will pay a pro-rata portion of their interest if the loan is paid off\n     * early and the loan is pro-rated type, but the complete repayment amount if it is fixed type.\n     * The the borrower (current owner of the obligation note) will get the collaterl NFT back.\n     *\n     * This function is purposefully not pausable in order to prevent an attack where the contract admin's pause the\n     * contract and hold hostage the NFT's that are still within it.\n     *\n     * @param _loanId  A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     */\n    function payBackLoan(uint32 _loanId) external nonReentrant {\n        LoanChecksAndCalculations.payBackChecks(_loanId, hub);\n        (\n            address borrower,\n            address lender,\n            LoanTerms memory loan,\n            IDirectLoanCoordinator loanCoordinator\n        ) = _getPartiesAndData(_loanId);\n\n        _payBackLoan(_loanId, borrower, lender, loan);\n\n        bool repaid = true;\n        _resolveLoan(_loanId, borrower, loan, loanCoordinator, repaid);\n    }\n\n    /**\n     * @notice This function is called by a anyone to repay a loan. It can be called at any time after the loan has\n     * begun and before loan expiry.. The caller will pay a pro-rata portion of their interest if the loan is paid off\n     * early and the loan is pro-rated type, but the complete repayment amount if it is fixed type.\n     * The the borrower (current owner of the obligation note) will get the collaterl NFT back.\n     *\n     * This function is purposefully not pausable in order to prevent an attack where the contract admin's pause the\n     * contract and hold hostage the NFT's that are still within it.\n     *\n     * @param _loanId  A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     */\n    function payBackLoanSafe(uint32 _loanId) external nonReentrant {\n        LoanChecksAndCalculations.payBackChecks(_loanId, hub);\n        (\n            address borrower,\n            address lender,\n            LoanTerms memory loan,\n            IDirectLoanCoordinator loanCoordinator\n        ) = _getPartiesAndData(_loanId);\n\n        _payBackLoanSafe(_loanId, borrower, lender, loan);\n\n        bool repaid = true;\n        _resolveLoan(_loanId, borrower, loan, loanCoordinator, repaid);\n    }\n\n    /**\n     * @notice Used for lenders to get their payback from escrow,\n     * in case the direct loan payback didn't work, because it caused a revert.\n     *\n     * @param _token  ERC20 token conract address\n     */\n    function getEscrowedPayBack(address _token) external nonReentrant {\n        uint256 amount = _payBackEscrow[msg.sender][_token];\n        if (amount == 0) {\n            revert NoTokensInEscrow();\n        }\n        IERC20(_token).safeTransfer(msg.sender, amount);\n        delete _payBackEscrow[msg.sender][_token];\n        _escrowErc20Tokens[_token] -= amount;\n    }\n\n    /**\n     * @notice This function is called by a lender once a loan has finished its duration and the borrower still has not\n     * repaid. The lender can call this function to seize the underlying NFT collateral, although the lender gives up\n     * all rights to the principal-plus-collateral by doing so.\n     *\n     * This function is purposefully not pausable in order to prevent an attack where the contract admin's pause\n     * the contract and hold hostage the NFT's that are still within it.\n     *\n     * We intentionally allow anybody to call this function, although only the lender will end up receiving the seized\n     * collateral. We are exploring the possbility of incentivizing users to call this function by using some of the\n     * admin funds.\n     *\n     * @param _loanId  A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     */\n    function liquidateOverdueLoan(uint32 _loanId) external nonReentrant {\n        LoanChecksAndCalculations.checkLoanIdValidity(_loanId, hub);\n        // Sanity check that payBackLoan() and liquidateOverdueLoan() have never been called on this loanId.\n        // Depending on how the rest of the code turns out, this check may be unnecessary.\n        if (loanRepaidOrLiquidated[_loanId]) {\n            revert LoanAlreadyRepaidOrLiquidated();\n        }\n\n        (\n            address borrower,\n            address lender,\n            LoanTerms memory loan,\n            IDirectLoanCoordinator loanCoordinator\n        ) = _getPartiesAndData(_loanId);\n\n        // Ensure that the loan is indeed overdue, since we can only liquidate overdue loans.\n        uint256 loanMaturityDate = uint256(loan.loanStartTime) + uint256(loan.loanDuration);\n        if (block.timestamp <= loanMaturityDate) {\n            revert LoanNotOverdueYet();\n        }\n        if (msg.sender != lender) {\n            revert OnlyLenderCanLiquidate();\n        }\n\n        bool repaid = false;\n\n        _resolveLoan(_loanId, lender, loan, loanCoordinator, repaid);\n\n        // Emit an event with all relevant details from this transaction.\n        emit LoanLiquidated(\n            _loanId,\n            borrower,\n            lender,\n            loan.loanPrincipalAmount,\n            loan.nftCollateralId,\n            loanMaturityDate,\n            block.timestamp,\n            loan.nftCollateralContract\n        );\n    }\n\n    /**\n     * @notice This function can be called by either a lender or a borrower to cancel all off-chain orders that they\n     * have signed that contain this nonce. If the off-chain orders were created correctly, there should only be one\n     * off-chain order that contains this nonce at all.\n     *\n     * The nonce referred to here is not the same as an Ethereum account's nonce. We are referring\n     * instead to nonces that are used by both the lender and the borrower when they are first signing off-chain NFTfi\n     * orders. These nonces can be any uint256 value that the user has not previously used to sign an off-chain order.\n     * Each nonce can be used at most once per user within NFTfi, regardless of whether they are the lender or the\n     * borrower in that situation. This serves two purposes. First, it prevents replay attacks where an attacker would\n     * submit a user's off-chain order more than once. Second, it allows a user to cancel an off-chain order by calling\n     * NFTfi.cancelLoanCommitmentBeforeLoanHasBegun(), which marks the nonce as used and prevents any future loan from\n     * using the user's off-chain order that contains that nonce.\n     *\n     * @param  _nonce - User nonce\n     */\n    function cancelLoanCommitmentBeforeLoanHasBegun(uint256 _nonce) external {\n        if (_nonceHasBeenUsedForUser[msg.sender][_nonce]) {\n            revert InvalidNonce();\n        }\n        _nonceHasBeenUsedForUser[msg.sender][_nonce] = true;\n    }\n\n    /* ******************* */\n    /* READ-ONLY FUNCTIONS */\n    /* ******************* */\n\n    /**\n     * @notice This function can be used to view the current quantity of the ERC20 currency used in the specified loan\n     * required by the borrower to repay their loan, measured in the smallest unit of the ERC20 currency.\n     *\n     * @param _loanId  A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     *\n     * @return The amount of the specified ERC20 currency required to pay back this loan, measured in the smallest unit\n     * of the specified ERC20 currency.\n     */\n    function getPayoffAmount(uint32 _loanId) external view virtual returns (uint256);\n\n    /**\n     * @notice This function can be used to view whether a particular nonce for a particular user has already been used,\n     * either from a successful loan or a cancelled off-chain order.\n     *\n     * @param _user - The address of the user. This function works for both lenders and borrowers alike.\n     * @param  _nonce - The nonce referred to here is not the same as an Ethereum account's nonce. We are referring\n     * instead to nonces that are used by both the lender and the borrower when they are first signing off-chain\n     * NFTfi orders. These nonces can be any uint256 value that the user has not previously used to sign an off-chain\n     * order. Each nonce can be used at most once per user within NFTfi, regardless of whether they are the lender or\n     * the borrower in that situation. This serves two purposes:\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\n     * , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\n     * that nonce.\n     *\n     * @return A bool representing whether or not this nonce has been used for this user.\n     */\n    function getWhetherNonceHasBeenUsedForUser(address _user, uint256 _nonce) external view override returns (bool) {\n        return _nonceHasBeenUsedForUser[_user][_nonce];\n    }\n\n    /**\n     * @notice This function can be called by anyone to get the permit associated with the erc20 contract.\n     *\n     * @param _erc20 - The address of the erc20 contract.\n     *\n     * @return Returns whether the erc20 is permitted\n     */\n    function getERC20Permit(address _erc20) public view override returns (bool) {\n        return erc20Permits[_erc20];\n    }\n\n    /* ****************** */\n    /* INTERNAL FUNCTIONS */\n    /* ****************** */\n\n    /**\n     * @dev makes possible to change loan duration and max repayment amount, loan duration even can be extended if\n     * loan was expired but not liquidated. IMPORTANT: Frontend will have to propt the caller to do an ERC20 approve for\n     * the fee amount from themselves (borrower/obligation reciept holder) to the lender (promissory note holder)\n     *\n     * @param _loanId - The unique identifier for the loan to be renegotiated\n     * @param _newLoanDuration - The new amount of time (measured in seconds) that can elapse before the lender can\n     * liquidate the loan and seize the underlying collateral NFT.\n     * @param _newMaximumRepaymentAmount - The new maximum amount of money that the borrower would be required to\n     * retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The\n     * borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay\n     * early.\n     * @param _renegotiationFee Agreed upon fee in loan denomination that borrower pays for the lender and\n     * the admin for the renegotiation, has to be paid with an ERC20 transfer loanERC20Denomination token,\n     * uses transfer from, frontend will have to propmt an erc20 approve for this from the borrower to the lender,\n     * admin fee is calculated by the loan's loanAdminFeeInBasisPoints value\n     * @param _lenderNonce - The nonce referred to here is not the same as an Ethereum account's nonce. We are\n     * referring instead to nonces that are used by both the lender and the borrower when they are first signing\n     * off-chain NFTfi orders. These nonces can be any uint256 value that the user has not previously used to sign an\n     * off-chain order. Each nonce can be used at most once per user within NFTfi, regardless of whether they are the\n     * lender or the borrower in that situation. This serves two purposes:\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\n     , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\n     * that nonce.\n     * @param _expiry - The date when the renegotiation offer expires\n     * @param _lenderSignature - The ECDSA signature of the lender, obtained off-chain ahead of time, signing the\n     * following combination of parameters:\n     * - _loanId\n     * - _newLoanDuration\n     * - _newMaximumRepaymentAmount\n     * - _lender\n     * - _expiry\n     * - address of this contract\n     * - chainId\n     */\n    function _renegotiateLoan(\n        uint32 _loanId,\n        uint32 _newLoanDuration,\n        uint256 _newMaximumRepaymentAmount,\n        uint256 _renegotiationFee,\n        uint256 _lenderNonce,\n        uint256 _expiry,\n        bytes memory _lenderSignature\n    ) internal {\n        LoanTerms storage loan = loanIdToLoan[_loanId];\n\n        (address borrower, address lender) = LoanChecksAndCalculations.renegotiationChecks(\n            loan,\n            _loanId,\n            _newLoanDuration,\n            _newMaximumRepaymentAmount,\n            _lenderNonce,\n            hub\n        );\n\n        _nonceHasBeenUsedForUser[lender][_lenderNonce] = true;\n\n        if (\n            !NFTfiSigningUtils.isValidLenderRenegotiationSignature(\n                _loanId,\n                _newLoanDuration,\n                _newMaximumRepaymentAmount,\n                _renegotiationFee,\n                Signature({signer: lender, nonce: _lenderNonce, expiry: _expiry, signature: _lenderSignature})\n            )\n        ) {\n            revert RenegotiationSignatureInvalid();\n        }\n\n        uint256 renegotiationAdminFee;\n        /**\n         * @notice Transfers fee to the lender immediately\n         * @dev implements Checks-Effects-Interactions pattern by modifying state only after\n         * the transfer happened successfully, we also add the nonReentrant modifier to\n         * the pbulic versions\n         */\n        if (_renegotiationFee > 0) {\n            renegotiationAdminFee = LoanChecksAndCalculations.computeAdminFee(\n                _renegotiationFee,\n                loan.loanAdminFeeInBasisPoints\n            );\n            // Transfer principal-plus-interest-minus-fees from the caller (always has to be borrower) to lender\n            IERC20(loan.loanERC20Denomination).safeTransferFrom(\n                borrower,\n                lender,\n                _renegotiationFee - renegotiationAdminFee\n            );\n            // Transfer fees from the caller (always has to be borrower) to admins\n            IERC20(loan.loanERC20Denomination).safeTransferFrom(borrower, owner(), renegotiationAdminFee);\n        }\n\n        loan.loanDuration = _newLoanDuration;\n        loan.maximumRepaymentAmount = _newMaximumRepaymentAmount;\n\n        // we have to reinstate borrower record here, because obligation receipt gets deleted in reMint\n        if (loan.borrower == address(0)) {\n            loan.borrower = borrower;\n        }\n        IDirectLoanCoordinator(hub.getContract(LOAN_COORDINATOR)).resetSmartNfts(_loanId, lender);\n\n        emit LoanRenegotiated(\n            _loanId,\n            borrower,\n            lender,\n            _newLoanDuration,\n            _newMaximumRepaymentAmount,\n            _renegotiationFee,\n            renegotiationAdminFee\n        );\n    }\n\n    /**\n     * @dev Transfer collateral NFT from borrower to this contract and principal from lender to the borrower and\n     * registers the new loan through the loan coordinator.\n     *\n     * @param _loanType - The type of loan it is being created\n     * @param _loanTerms - Struct containing the loan's settings\n     * @param _loanExtras - Struct containing some loan's extra settings, needed to avoid stack too deep\n     * @param _lender - The address of the lender.\n     * @param _referrer - The address of the referrer who found the lender matching the listing, Zero address to signal\n     * that there is no referrer.\n     */\n    function _createLoan(\n        bytes32 _loanType,\n        LoanTerms memory _loanTerms,\n        LoanExtras memory _loanExtras,\n        address _borrower,\n        address _lender,\n        address _referrer\n    ) internal returns (uint32) {\n        // Transfer collateral from borrower to this contract to be held until\n        // loan completion.\n        _transferNFT(_loanTerms, _borrower, address(this));\n\n        return _createLoanNoNftTransfer(_loanType, _loanTerms, _loanExtras, _borrower, _lender, _referrer);\n    }\n\n    /**\n     * @dev Transfer principal from lender to the borrower and\n     * registers the new loan through the loan coordinator.\n     *\n     * @param _loanType - The type of loan it is being created\n     * @param _loanTerms - Struct containing the loan's settings\n     * @param _loanExtras - Struct containing some loan's extra settings, needed to avoid stack too deep\n     * @param _lender - The address of the lender.\n     * @param _referrer - The address of the referrer who found the lender matching the listing, Zero address to signal\n     * that there is no referrer.\n     */\n    function _createLoanNoNftTransfer(\n        bytes32 _loanType,\n        LoanTerms memory _loanTerms,\n        LoanExtras memory _loanExtras,\n        address _borrower,\n        address _lender,\n        address _referrer\n    ) internal returns (uint32 loanId) {\n        _escrowTokens[_loanTerms.nftCollateralContract][_loanTerms.nftCollateralId] += 1;\n\n        uint256 referralfee = LoanChecksAndCalculations.computeReferralFee(\n            _loanTerms.loanPrincipalAmount,\n            _loanExtras.referralFeeInBasisPoints,\n            _referrer\n        );\n        uint256 principalAmount = _loanTerms.loanPrincipalAmount - referralfee;\n        if (referralfee > 0) {\n            // Transfer the referral fee from lender to referrer.\n            IERC20(_loanTerms.loanERC20Denomination).safeTransferFrom(_lender, _referrer, referralfee);\n        }\n        // Transfer principal from lender to borrower.\n        IERC20(_loanTerms.loanERC20Denomination).safeTransferFrom(_lender, _borrower, principalAmount);\n\n        // Issue an ERC721 promissory note to the lender that gives them the\n        // right to either the principal-plus-interest or the collateral,\n        // and an obligation note to the borrower that gives them the\n        // right to pay back the loan and get the collateral back.\n        IDirectLoanCoordinator loanCoordinator = IDirectLoanCoordinator(hub.getContract(LOAN_COORDINATOR));\n        loanId = loanCoordinator.registerLoan(_lender, _loanType);\n\n        // Add the loan to storage before moving collateral/principal to follow\n        // the Checks-Effects-Interactions pattern.\n        loanIdToLoan[loanId] = _loanTerms;\n        loanIdToLoanExtras[loanId] = _loanExtras;\n\n        return loanId;\n    }\n\n    /**\n     * @dev Transfers several types of NFTs using a wrapper that knows how to handle each case.\n     *\n     * @param _loanTerms - Struct containing all the loan's parameters\n     * @param _sender - Current owner of the NFT\n     * @param _recipient - Recipient of the transfer\n     */\n    function _transferNFT(LoanTerms memory _loanTerms, address _sender, address _recipient) internal {\n        Address.functionDelegateCall(\n            _loanTerms.nftCollateralWrapper,\n            abi.encodeWithSelector(\n                INftWrapper(_loanTerms.nftCollateralWrapper).transferNFT.selector,\n                _sender,\n                _recipient,\n                _loanTerms.nftCollateralContract,\n                _loanTerms.nftCollateralId\n            ),\n            \"NFT not successfully transferred\"\n        );\n    }\n\n    /**\n     * @notice This function is called by a anyone to repay a loan. It can be called at any time after the loan has\n     * begun and before loan expiry.. The caller will pay a pro-rata portion of their interest if the loan is paid off\n     * early and the loan is pro-rated type, but the complete repayment amount if it is fixed type.\n     * The the borrower (current owner of the obligation note) will get the collaterl NFT back.\n     *\n     * This function is purposefully not pausable in order to prevent an attack where the contract admin's pause the\n     * contract and hold hostage the NFT's that are still within it.\n     *\n     * @param _loanId  A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     */\n    function _payBackLoan(uint32 _loanId, address _borrower, address _lender, LoanTerms memory _loan) internal {\n        // Fetch loan details from storage, but store them in memory for the sake of saving gas.\n        LoanExtras memory loanExtras = loanIdToLoanExtras[_loanId];\n\n        (uint256 adminFee, uint256 payoffAmount) = _payoffAndFee(_loan);\n\n        // Transfer principal-plus-interest-minus-fees from the caller to lender\n        IERC20(_loan.loanERC20Denomination).safeTransferFrom(msg.sender, _lender, payoffAmount);\n\n        uint256 revenueShare = LoanChecksAndCalculations.computeRevenueShare(\n            adminFee,\n            loanExtras.revenueShareInBasisPoints\n        );\n        // PermittedPartners contract doesn't allow to set a revenueShareInBasisPoints for address zero so revenuShare\n        // > 0 implies that revenueSharePartner ~= address(0), BUT revenueShare can be zero for a partener when the\n        // adminFee is low\n        if (revenueShare > 0 && loanExtras.revenueSharePartner != address(0)) {\n            adminFee -= revenueShare;\n            // Transfer revenue share from the caller to permitted partner\n            IERC20(_loan.loanERC20Denomination).safeTransferFrom(\n                msg.sender,\n                loanExtras.revenueSharePartner,\n                revenueShare\n            );\n        }\n\n        // Transfer fees from the caller to admins\n        IERC20(_loan.loanERC20Denomination).safeTransferFrom(msg.sender, owner(), adminFee);\n\n        // Emit an event with all relevant details from this transaction.\n        emit LoanRepaid(\n            _loanId,\n            _borrower,\n            _lender,\n            _loan.loanPrincipalAmount,\n            _loan.nftCollateralId,\n            payoffAmount,\n            adminFee,\n            revenueShare,\n            loanExtras.revenueSharePartner, // this could be a non address zero even if revenueShare is 0\n            _loan.nftCollateralContract,\n            _loan.loanERC20Denomination\n        );\n    }\n\n    /**\n     * @notice This function is called by a anyone to repay a loan. It can be called at any time after the loan has\n     * begun and before loan expiry.. The caller will pay a pro-rata portion of their interest if the loan is paid off\n     * early and the loan is pro-rated type, but the complete repayment amount if it is fixed type.\n     * The the borrower (current owner of the obligation note) will get the collaterl NFT back.\n     *\n     * This function is purposefully not pausable in order to prevent an attack where the contract admin's pause the\n     * contract and hold hostage the NFT's that are still within it.\n     *\n     * @param _loanId  A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     */\n    function _payBackLoanSafe(uint32 _loanId, address _borrower, address _lender, LoanTerms memory _loan) internal {\n        // Fetch loan details from storage, but store them in memory for the sake of saving gas.\n        LoanExtras memory loanExtras = loanIdToLoanExtras[_loanId];\n\n        (uint256 adminFee, uint256 payoffAmount) = _payoffAndFee(_loan);\n\n        // use try to detect the case of erc20 transfer failing for some reason (e.g. USDC blacklisted address)\n        try IERC20(_loan.loanERC20Denomination).transferFrom(msg.sender, _lender, payoffAmount) {\n            // solhint-disable-previous-line no-empty-blocks\n        } catch {\n            // if ERC20 transfer fails, we store the amount in escrow in this contract\n            IERC20(_loan.loanERC20Denomination).safeTransferFrom(msg.sender, address(this), payoffAmount);\n            _payBackEscrow[_lender][_loan.loanERC20Denomination] += payoffAmount;\n            _escrowErc20Tokens[_loan.loanERC20Denomination] += payoffAmount;\n            emit EscrowRepay(_loanId);\n        }\n\n        uint256 revenueShare = LoanChecksAndCalculations.computeRevenueShare(\n            adminFee,\n            loanExtras.revenueShareInBasisPoints\n        );\n\n        // PermittedPartners contract doesn't allow to set a revenueShareInBasisPoints for address zero so revenuShare\n        // > 0 implies that revenueSharePartner ~= address(0), BUT revenueShare can be zero for a partener when the\n        // adminFee is low\n        if (revenueShare > 0 && loanExtras.revenueSharePartner != address(0)) {\n            adminFee -= revenueShare;\n            // Transfer revenue share from the caller to permitted partner\n            // try is here so if for whatever reason (USCD blacklist specifically) this\n            // transfer would fail the borrowerr still can pay back and get their nft back\n            // revenue share can be later drained by us and distributed manually\n            try\n                IERC20(_loan.loanERC20Denomination).transferFrom(\n                    msg.sender,\n                    loanExtras.revenueSharePartner,\n                    revenueShare\n                )\n            {\n                // solhint-disable-previous-line no-empty-blocks\n            } catch {\n                IERC20(_loan.loanERC20Denomination).safeTransferFrom(msg.sender, address(this), revenueShare);\n            }\n        }\n\n        // Transfer fees from the caller to admins\n        // try is here so if for whatever reason (USCD blacklist specifically) this\n        // transfer would fail the borrowerr still can pay back and get their nft back\n        // admin fee can be later drained by us\n        try IERC20(_loan.loanERC20Denomination).transferFrom(msg.sender, owner(), adminFee) {\n            // solhint-disable-previous-line no-empty-blocks\n        } catch {\n            IERC20(_loan.loanERC20Denomination).safeTransferFrom(msg.sender, address(this), adminFee);\n        }\n\n        // Emit an event with all relevant details from this transaction.\n        emit LoanRepaid(\n            _loanId,\n            _borrower,\n            _lender,\n            _loan.loanPrincipalAmount,\n            _loan.nftCollateralId,\n            payoffAmount,\n            adminFee,\n            revenueShare,\n            loanExtras.revenueSharePartner, // this could be a non address zero even if revenueShare is 0\n            _loan.nftCollateralContract,\n            _loan.loanERC20Denomination\n        );\n    }\n\n    /**\n     * @notice A convenience function with shared functionality between `payBackLoan` and `liquidateOverdueLoan`.\n     *\n     * @param _loanId  A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     * @param _nftReceiver - The receiver of the collateral nft. The borrower when `payBackLoan` or the lender when\n     * `liquidateOverdueLoan`.\n     * @param _loanTerms - The main Loan Terms struct. This data is saved upon loan creation on loanIdToLoan.\n     * @param _loanCoordinator - The loan coordinator used when creating the loan.\n     */\n    function _resolveLoan(\n        uint32 _loanId,\n        address _nftReceiver,\n        LoanTerms memory _loanTerms,\n        IDirectLoanCoordinator _loanCoordinator,\n        bool _repaid\n    ) internal {\n        _resolveLoanNoNftTransfer(_loanId, _loanTerms, _loanCoordinator, _repaid);\n        // Transfer collateral from this contract to the lender, since the lender is seizing collateral for an overdue\n        // loan\n        _transferNFT(_loanTerms, address(this), _nftReceiver);\n    }\n\n    /**\n     * @notice Resolving the loan without trasferring the nft to provide a base for the bundle\n     * break up of the bundled loans\n     *\n     * @param _loanId  A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     * @param _loanTerms - The main Loan Terms struct. This data is saved upon loan creation on loanIdToLoan.\n     * @param _loanCoordinator - The loan coordinator used when creating the loan.\n     */\n    function _resolveLoanNoNftTransfer(\n        uint32 _loanId,\n        LoanTerms memory _loanTerms,\n        IDirectLoanCoordinator _loanCoordinator,\n        bool _repaid\n    ) internal {\n        // Mark loan as liquidated before doing any external transfers to follow the Checks-Effects-Interactions design\n        // pattern\n        loanRepaidOrLiquidated[_loanId] = true;\n\n        _escrowTokens[_loanTerms.nftCollateralContract][_loanTerms.nftCollateralId] -= 1;\n\n        // Destroy the lender's promissory note for this loan and borrower obligation receipt\n        _loanCoordinator.resolveLoan(_loanId, _repaid);\n    }\n\n    /**\n     * @notice This function can be called by admins to change the permitted status of an ERC20 currency. This includes\n     * both adding an ERC20 currency to the permitted list and removing it.\n     *\n     * @param _erc20 - The address of the ERC20 currency whose permit list status changed.\n     * @param _permit - The new status of whether the currency is permitted or not.\n     */\n    function _setERC20Permit(address _erc20, bool _permit) internal {\n        if (_erc20 == address(0)) {\n            revert ERC20ZeroAddress();\n        }\n        erc20Permits[_erc20] = _permit;\n\n        emit ERC20Permit(_erc20, _permit);\n    }\n\n    /**\n     * @dev Performs some validation checks over loan parameters\n     *\n     */\n    function _loanSanityChecks(LoanData.Offer memory _offer, address _nftWrapper) internal view {\n        if (!getERC20Permit(_offer.loanERC20Denomination)) {\n            revert CurrencyDenominationNotPermitted();\n        }\n        if (_nftWrapper == address(0)) {\n            revert NFTCollateralContractNotPermitted();\n        }\n        if (uint256(_offer.loanDuration) > maximumLoanDuration) {\n            revert LoanDurationExceedsMaximum();\n        }\n        if (uint256(_offer.loanDuration) == 0) {\n            revert LoanDurationCannotBeZero();\n        }\n        if (_offer.loanAdminFeeInBasisPoints != adminFeeInBasisPoints) {\n            revert AdminFeeChanged();\n        }\n    }\n\n    /**\n     * @dev reads some variable values of a loan for payback functions, created to reduce code repetition\n     */\n    function _getPartiesAndData(\n        uint32 _loanId\n    )\n        internal\n        view\n        returns (address borrower, address lender, LoanTerms memory loan, IDirectLoanCoordinator loanCoordinator)\n    {\n        loanCoordinator = IDirectLoanCoordinator(hub.getContract(LOAN_COORDINATOR));\n        IDirectLoanCoordinator.Loan memory loanCoordinatorData = loanCoordinator.getLoanData(_loanId);\n        uint256 smartNftId = loanCoordinatorData.smartNftId;\n        // Fetch loan details from storage, but store them in memory for the sake of saving gas.\n        loan = loanIdToLoan[_loanId];\n        if (loan.borrower != address(0)) {\n            borrower = loan.borrower;\n        } else {\n            // Fetch current owner of loan obligation note.\n            borrower = IERC721(loanCoordinator.obligationReceiptToken()).ownerOf(smartNftId);\n        }\n        lender = IERC721(loanCoordinator.promissoryNoteToken()).ownerOf(smartNftId);\n    }\n\n    /**\n     * @dev Creates a `LoanExtras` struct using data sent as the borrower's extra settings.\n     * This is needed in order to avoid stack too deep issues.\n     */\n    function _setupLoanExtras(\n        address _revenueSharePartner,\n        uint16 _referralFeeInBasisPoints\n    ) internal view returns (LoanExtras memory) {\n        // Save loan details to a struct in memory first, to save on gas if any\n        // of the below checks fail, and to avoid the \"Stack Too Deep\" error by\n        // clumping the parameters together into one struct held in memory.\n        return\n            LoanExtras({\n                revenueSharePartner: _revenueSharePartner,\n                revenueShareInBasisPoints: LoanChecksAndCalculations.getRevenueSharePercent(_revenueSharePartner, hub),\n                referralFeeInBasisPoints: _referralFeeInBasisPoints\n            });\n    }\n\n    /**\n     * @dev Calculates the payoff amount and admin fee\n     */\n    function _payoffAndFee(LoanTerms memory _loanTerms) internal view virtual returns (uint256, uint256);\n\n    /**\n     * @dev Checks that the collateral is a supported contracts and returns what wrapper to use for the loan's NFT\n     * collateral contract.\n     *\n     * @param _nftCollateralContract - The address of the the NFT collateral contract.\n     *\n     * @return Address of the NftWrapper to use for the loan's NFT collateral.\n     */\n    function _getWrapper(address _nftCollateralContract) internal view returns (address) {\n        return IPermittedNFTs(hub.getContract(ContractKeys.PERMITTED_NFTS)).getNFTWrapper(_nftCollateralContract);\n    }\n}\n"
    },
    "contracts/loans/direct/loanTypes/DirectLoanFixedCollectionOffer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {DirectLoanFixedOffer, NFTfiSigningUtils} from \"./DirectLoanFixedOffer.sol\";\nimport {NFTfiCollectionOfferSigningUtils} from \"../../../utils/NFTfiCollectionOfferSigningUtils.sol\";\n\n/**\n * @title  DirectLoanFixedCollectionOffer\n * @author NFTfi\n * @notice Main contract for NFTfi Direct Loans Fixed Collection Type.\n * This contract manages the ability to create reoccurring NFT-backed\n * peer-to-peer loans of type Fixed (agreed to be a fixed-repayment loan) where the borrower pays the\n * maximumRepaymentAmount regardless of whether they repay early or not.\n * In collection offer type loans the collateral can be any one item (id) of a given NFT collection (contract).\n *\n * To commence an NFT-backed loan:\n *\n * The borrower accepts a lender's offer by calling `acceptOffer`.\n *   1. the borrower calls nftContract.approveAll(NFTfi), approving the NFTfi contract to move their NFT's on their\n * be1alf.\n *   2. the lender calls erc20Contract.approve(NFTfi), allowing NFTfi to move the lender's ERC20 tokens on their\n * behalf.\n *   3. the lender signs a reusable off-chain message, proposing its collection offer terms.\n *   4. the borrower calls `acceptOffer` to accept these terms and enter into the loan. The NFT is stored in\n * the contract, the borrower receives the loan principal in the specified ERC20 currency, the lender receives an\n * NFTfi promissory note (in ERC721 form) that represents the rights to either the principal-plus-interest, or the\n * underlying NFT collateral if the borrower does not pay back in time, and the borrower receives obligation receipt\n * (in ERC721 form) that gives them the right to pay back the loan and get the collateral back.\n *  5. another borrower can also repeat step 4 until the original lender cancels or their\n * wallet runs out of funds with allowance to the contract\n *\n * The lender can freely transfer and trade this ERC721 promissory note as they wish, with the knowledge that\n * transferring the ERC721 promissory note tranfsers the rights to principal-plus-interest and/or collateral, and that\n * they will no longer have a claim on the loan. The ERC721 promissory note itself represents that claim.\n *\n * The borrower can freely transfer and trade this ERC721 obligaiton receipt as they wish, with the knowledge that\n * transferring the ERC721 obligaiton receipt tranfsers the rights right to pay back the loan and get the collateral\n * back.\n *\n *\n * A loan may end in one of two ways:\n * - First, a borrower may call NFTfi.payBackLoan() and pay back the loan plus interest at any time, in which case they\n * receive their NFT back in the same transaction.\n * - Second, if the loan's duration has passed and the loan has not been paid back yet, a lender can call\n * NFTfi.liquidateOverdueLoan(), in which case they receive the underlying NFT collateral and forfeit the rights to the\n * principal-plus-interest, which the borrower now keeps.\n */\ncontract DirectLoanFixedCollectionOffer is DirectLoanFixedOffer {\n    /* ************* */\n    /* CUSTOM ERRORS */\n    /* ************* */\n\n    error CollateralIdNotInRange();\n    error MinIdGreaterThanMaxId();\n    error OriginalAcceptOfferDisabled();\n\n    /* *********** */\n    /* CONSTRUCTOR */\n    /* *********** */\n\n    /**\n     * @dev Sets `hub` and permitted erc20-s\n     *\n     * @param _admin - Initial admin of this contract.\n     * @param  _nftfiHub - NFTfiHub address\n     * @param  _permittedErc20s - list of permitted ERC20 token contract addresses\n     */\n    constructor(\n        address _admin,\n        address _nftfiHub,\n        address[] memory _permittedErc20s\n    ) DirectLoanFixedOffer(_admin, _nftfiHub, _permittedErc20s) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /* ******************* */\n    /* READ-ONLY FUNCTIONS */\n    /* ******************* */\n\n    /**\n     * @notice This function returns a bytes32 value identifying the loan type for the coordinator\n     */\n    // all caps, because used to be a constant storage and the interface should be the same\n    // solhint-disable-next-line func-name-mixedcase\n    function LOAN_TYPE() public pure override returns (bytes32) {\n        return bytes32(\"DIRECT_LOAN_FIXED_COLLECTION\");\n    }\n\n    /**\n     * @notice overriding to make it impossible to create a regular offer on this contract (only collection offers)\n     */\n    function acceptOffer(\n        Offer memory,\n        Signature memory,\n        BorrowerSettings memory\n    ) external override whenNotPaused nonReentrant returns (uint32) {\n        revert OriginalAcceptOfferDisabled();\n    }\n\n    /**\n     * @notice This function is called by the borrower when accepting a lender's collection offer to begin a loan.\n     *\n     * @param _offer - The offer made by the lender.\n     * @param _signature - The components of the lender's signature.\n     * stolen or otherwise unwanted items\n     * @param _borrowerSettings - Some extra parameters that the borrower needs to set when accepting an offer.\n     */\n    function acceptCollectionOffer(\n        Offer memory _offer,\n        Signature memory _signature,\n        BorrowerSettings memory _borrowerSettings\n    ) external whenNotPaused nonReentrant {\n        address nftWrapper = _getWrapper(_offer.nftCollateralContract);\n        _loanSanityChecks(_offer, nftWrapper);\n        _loanSanityChecksOffer(_offer);\n        _acceptOffer(\n            _setupLoanTerms(_offer, nftWrapper),\n            _setupLoanExtras(_borrowerSettings.revenueSharePartner, _borrowerSettings.referralFeeInBasisPoints),\n            _offer,\n            _signature\n        );\n    }\n\n    /**\n     * @notice This function is called by the borrower when accepting a lender's\n     * collection offer with a given id range to begin a loan\n     *\n     * @param _offer - The offer made by the lender.\n     * @param _idRange - min and max (inclusive) Id ranges for collection offers on collections,\n     * like ArtBlocks, where multiple collections are defined on one contract differentiated by id-ranges\n     * @param _signature - The components of the lender's signature.\n     * stolen or otherwise unwanted items\n     * @param _borrowerSettings - Some extra parameters that the borrower needs to set when accepting an offer.\n     */\n    function acceptCollectionOfferWithIdRange(\n        Offer memory _offer,\n        CollectionIdRange memory _idRange,\n        Signature memory _signature,\n        BorrowerSettings memory _borrowerSettings\n    ) external whenNotPaused nonReentrant {\n        address nftWrapper = _getWrapper(_offer.nftCollateralContract);\n        _loanSanityChecks(_offer, nftWrapper);\n        _loanSanityChecksOffer(_offer);\n        _idRangeSanityCheck(_idRange);\n        _acceptOfferWithIdRange(\n            _setupLoanTerms(_offer, nftWrapper),\n            _setupLoanExtras(_borrowerSettings.revenueSharePartner, _borrowerSettings.referralFeeInBasisPoints),\n            _offer,\n            _idRange,\n            _signature\n        );\n    }\n\n    /* ****************** */\n    /* INTERNAL FUNCTIONS */\n    /* ****************** */\n\n    /**\n     * @notice This function is called by the borrower when accepting a lender's offer\n     * to begin a loan with the public function acceptCollectionOffer.\n     *\n     * @param _loanTerms - The main Loan Terms struct. This data is saved upon loan creation on loanIdToLoan.\n     * @param _loanExtras - The main Loan Terms struct. This data is saved upon loan creation on loanIdToLoanExtras.\n     * @param _offer - The offer made by the lender.\n     * @param _signature - The components of the lender's signature.\n     * stolen or otherwise unwanted items\n     */\n    function _acceptOffer(\n        LoanTerms memory _loanTerms,\n        LoanExtras memory _loanExtras,\n        Offer memory _offer,\n        Signature memory _signature\n    ) internal override returns (uint32) {\n        // still checking the nonce for possible cancellations\n        if (_nonceHasBeenUsedForUser[_signature.signer][_signature.nonce]) {\n            revert InvalidNonce();\n        }\n        // Note that we are not invalidating the nonce as part of acceptOffer (as is the case for loan types in general)\n        // since the nonce that the lender signed with remains valid for all loans for the collection offer\n\n        Offer memory offerToCheck = _offer;\n\n        offerToCheck.nftCollateralId = 0;\n\n        if (!NFTfiSigningUtils.isValidLenderSignature(offerToCheck, _signature)) {\n            revert InvalidLenderSignature();\n        }\n\n        uint32 loanId = _createLoan(\n            LOAN_TYPE(),\n            _loanTerms,\n            _loanExtras,\n            msg.sender,\n            _signature.signer,\n            _offer.referrer\n        );\n\n        // Emit an event with all relevant details from this transaction.\n        emit LoanStarted(loanId, msg.sender, _signature.signer, _loanTerms, _loanExtras);\n\n        return loanId;\n    }\n\n    /**\n     * @notice This function is called by the borrower when accepting a lender's\n     * collection offer with a given id range to begin a loan\n     *\n     * @param _loanTerms - The main Loan Terms struct. This data is saved upon loan creation on loanIdToLoan.\n     * @param _loanExtras - The main Loan Terms struct. This data is saved upon loan creation on loanIdToLoanExtras.\n     * @param _idRange - min and max (inclusive) Id ranges for collection offers on collections,\n     * like ArtBlocks, where multiple collections are defined on one contract differentiated by id-ranges\n     * @param _offer - The offer made by the lender.\n     * @param _signature - The components of the lender's signature.\n     * stolen or otherwise unwanted items\n     */\n    function _acceptOfferWithIdRange(\n        LoanTerms memory _loanTerms,\n        LoanExtras memory _loanExtras,\n        Offer memory _offer,\n        CollectionIdRange memory _idRange,\n        Signature memory _signature\n    ) internal {\n        // still checking the nonce for possible cancellations\n        if (_nonceHasBeenUsedForUser[_signature.signer][_signature.nonce]) {\n            revert InvalidNonce();\n        }\n        // Note that we are not invalidating the nonce as part of acceptOffer (as is the case for loan types in general)\n        // since the nonce that the lender signed with remains valid for all loans for the collection offer\n\n        //check for id range\n        if (_loanTerms.nftCollateralId < _idRange.minId || _loanTerms.nftCollateralId > _idRange.maxId) {\n            revert CollateralIdNotInRange();\n        }\n        Offer memory offerToCheck = _offer;\n\n        offerToCheck.nftCollateralId = 0;\n\n        if (!NFTfiCollectionOfferSigningUtils.isValidLenderSignatureWithIdRange(offerToCheck, _idRange, _signature)) {\n            revert InvalidLenderSignature();\n        }\n\n        uint32 loanId = _createLoan(\n            LOAN_TYPE(),\n            _loanTerms,\n            _loanExtras,\n            msg.sender,\n            _signature.signer,\n            _offer.referrer\n        );\n\n        // Emit an event with all relevant details from this transaction.\n        emit LoanStarted(loanId, msg.sender, _signature.signer, _loanTerms, _loanExtras);\n    }\n\n    function _idRangeSanityCheck(CollectionIdRange memory _idRange) internal pure {\n        if (_idRange.minId > _idRange.maxId) {\n            revert MinIdGreaterThanMaxId();\n        }\n    }\n}\n"
    },
    "contracts/loans/direct/loanTypes/DirectLoanFixedOffer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\n// \"compiler\": \"0.7.4\" (or greater)\nimport {\n    DirectLoanBaseMinimal,\n    NFTfiSigningUtils,\n    LoanChecksAndCalculations,\n    LoanData\n} from \"./DirectLoanBaseMinimal.sol\";\nimport {ContractKeys} from \"../../../utils/ContractKeys.sol\";\n\n/**\n * @title  DirectLoanFixedOffer\n * @author NFTfi\n * @notice Main contract for NFTfi Direct Loans Fixed Type. This contract manages the ability to create NFT-backed\n * peer-to-peer loans of type Fixed (agreed to be a fixed-repayment loan) where the borrower pays the\n * maximumRepaymentAmount regardless of whether they repay early or not.\n *\n * There are two ways to commence an NFT-backed loan:\n *\n * a. The borrower accepts a lender's offer by calling `acceptOffer`.\n *   1. the borrower calls nftContract.approveAll(NFTfi), approving the NFTfi contract to move their NFT's on their\n * be1alf.\n *   2. the lender calls erc20Contract.approve(NFTfi), allowing NFTfi to move the lender's ERC20 tokens on their\n * behalf.\n *   3. the lender signs an off-chain message, proposing its offer terms.\n *   4. the borrower calls `acceptOffer` to accept these terms and enter into the loan. The NFT is stored in\n * the contract, the borrower receives the loan principal in the specified ERC20 currency, the lender receives an\n * NFTfi promissory note (in ERC721 form) that represents the rights to either the principal-plus-interest, or the\n * underlying NFT collateral if the borrower does not pay back in time, and the borrower receives obligation receipt\n * (in ERC721 form) that gives them the right to pay back the loan and get the collateral back.\n *\n * The lender can freely transfer and trade this ERC721 promissory note as they wish, with the knowledge that\n * transferring the ERC721 promissory note tranfsers the rights to principal-plus-interest and/or collateral, and that\n * they will no longer have a claim on the loan. The ERC721 promissory note itself represents that claim.\n *\n * The borrower can freely transfer and trade this ERC721 obligaiton receipt as they wish, with the knowledge that\n * transferring the ERC721 obligaiton receipt tranfsers the rights right to pay back the loan and get the collateral\n * back.\n *\n *\n * A loan may end in one of two ways:\n * - First, a borrower may call NFTfi.payBackLoan() and pay back the loan plus interest at any time, in which case they\n * receive their NFT back in the same transaction.\n * - Second, if the loan's duration has passed and the loan has not been paid back yet, a lender can call\n * NFTfi.liquidateOverdueLoan(), in which case they receive the underlying NFT collateral and forfeit the rights to the\n * principal-plus-interest, which the borrower now keeps.\n */\ncontract DirectLoanFixedOffer is DirectLoanBaseMinimal {\n    /* ************* */\n    /* CUSTOM ERRORS */\n    /* ************* */\n\n    error InvalidLenderSignature();\n    error NegativeInterestRate();\n\n    /* *********** */\n    /* CONSTRUCTOR */\n    /* *********** */\n\n    /**\n     * @dev Sets `hub` and permitted erc20-s\n     *\n     * @param _admin - Initial admin of this contract.\n     * @param  _nftfiHub - NFTfiHub address\n     * @param  _permittedErc20s - list of permitted ERC20 token contract addresses\n     */\n    constructor(\n        address _admin,\n        address _nftfiHub,\n        address[] memory _permittedErc20s\n    )\n        DirectLoanBaseMinimal(\n            _admin,\n            _nftfiHub,\n            ContractKeys.getIdFromStringKey(\"DIRECT_LOAN_COORDINATOR\"),\n            _permittedErc20s\n        )\n    {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /* ********* */\n    /* FUNCTIONS */\n    /* ********* */\n\n    /**\n     * @notice This function is called by the borrower when accepting a lender's offer to begin a loan.\n     *\n     * @param _offer - The offer made by the lender.\n     * @param _signature - The components of the lender's signature.\n     * @param _borrowerSettings - Some extra parameters that the borrower needs to set when accepting an offer.\n     */\n    function acceptOffer(\n        Offer memory _offer,\n        Signature memory _signature,\n        BorrowerSettings memory _borrowerSettings\n    ) external virtual whenNotPaused nonReentrant returns (uint32) {\n        address nftWrapper = _getWrapper(_offer.nftCollateralContract);\n        _loanSanityChecks(_offer, nftWrapper);\n        _loanSanityChecksOffer(_offer);\n        return\n            _acceptOffer(\n                _setupLoanTerms(_offer, nftWrapper),\n                _setupLoanExtras(_borrowerSettings.revenueSharePartner, _borrowerSettings.referralFeeInBasisPoints),\n                _offer,\n                _signature\n            );\n    }\n\n    /* ******************* */\n    /* READ-ONLY FUNCTIONS */\n    /* ******************* */\n\n    /**\n     * @notice This function returns a bytes32 value identifying the loan type for the coordinator\n     */\n    // all caps, because used to be a constant storage and the interface should be the same\n    // solhint-disable-next-line func-name-mixedcase\n    function LOAN_TYPE() public pure virtual returns (bytes32) {\n        return bytes32(\"DIRECT_LOAN_FIXED_OFFER\");\n    }\n\n    /**\n     * @notice This function can be used to view the current quantity of the ERC20 currency used in the specified loan\n     * required by the borrower to repay their loan, measured in the smallest unit of the ERC20 currency.\n     *\n     * @param _loanId  A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     *\n     * @return The amount of the specified ERC20 currency required to pay back this loan, measured in the smallest unit\n     * of the specified ERC20 currency.\n     */\n    function getPayoffAmount(uint32 _loanId) external view override returns (uint256) {\n        LoanTerms storage loan = loanIdToLoan[_loanId];\n        return loan.maximumRepaymentAmount;\n    }\n\n    /* ****************** */\n    /* INTERNAL FUNCTIONS */\n    /* ****************** */\n\n    /**\n     * @notice This function is called by the borrower when accepting a lender's offer to begin a loan.\n     *\n     * @param _loanTerms - The main Loan Terms struct. This data is saved upon loan creation on loanIdToLoan.\n     * @param _loanExtras - The main Loan Terms struct. This data is saved upon loan creation on loanIdToLoanExtras.\n     * @param _offer - The offer made by the lender.\n     * @param _signature - The components of the lender's signature.\n     */\n    function _acceptOffer(\n        LoanTerms memory _loanTerms,\n        LoanExtras memory _loanExtras,\n        Offer memory _offer,\n        Signature memory _signature\n    ) internal virtual returns (uint32) {\n        // Check loan nonces. These are different from Ethereum account nonces.\n        // Here, these are uint256 numbers that should uniquely identify\n        // each signature for each user (i.e. each user should only create one\n        // off-chain signature for each nonce, with a nonce being any arbitrary\n        // uint256 value that they have not used yet for an off-chain NFTfi\n        // signature).\n        if (_nonceHasBeenUsedForUser[_signature.signer][_signature.nonce]) {\n            revert InvalidNonce();\n        }\n\n        _nonceHasBeenUsedForUser[_signature.signer][_signature.nonce] = true;\n\n        if (!NFTfiSigningUtils.isValidLenderSignature(_offer, _signature)) {\n            revert InvalidLenderSignature();\n        }\n\n        uint32 loanId = _createLoan(\n            LOAN_TYPE(),\n            _loanTerms,\n            _loanExtras,\n            msg.sender,\n            _signature.signer,\n            _offer.referrer\n        );\n\n        // Emit an event with all relevant details from this transaction.\n        emit LoanStarted(loanId, msg.sender, _signature.signer, _loanTerms, _loanExtras);\n        return loanId;\n    }\n\n    /**\n     * @dev Creates a `LoanTerms` struct using data sent as the lender's `_offer` on `acceptOffer`.\n     * This is needed in order to avoid stack too deep issues.\n     * Since this is a Fixed loan type loanInterestRateForDurationInBasisPoints is ignored.\n     */\n    function _setupLoanTerms(Offer memory _offer, address _nftWrapper) internal view returns (LoanTerms memory) {\n        return\n            LoanTerms({\n                loanERC20Denomination: _offer.loanERC20Denomination,\n                loanPrincipalAmount: _offer.loanPrincipalAmount,\n                maximumRepaymentAmount: _offer.maximumRepaymentAmount,\n                nftCollateralContract: _offer.nftCollateralContract,\n                nftCollateralWrapper: _nftWrapper,\n                nftCollateralId: _offer.nftCollateralId,\n                loanStartTime: uint64(block.timestamp),\n                loanDuration: _offer.loanDuration,\n                loanInterestRateForDurationInBasisPoints: uint16(0),\n                loanAdminFeeInBasisPoints: _offer.loanAdminFeeInBasisPoints,\n                borrower: msg.sender\n            });\n    }\n\n    /**\n     * @dev Calculates the payoff amount and admin fee\n     *\n     * @param _loanTerms - Struct containing all the loan's parameters\n     */\n    function _payoffAndFee(\n        LoanTerms memory _loanTerms\n    ) internal pure override returns (uint256 adminFee, uint256 payoffAmount) {\n        // Calculate amounts to send to lender and admins\n        uint256 interestDue = _loanTerms.maximumRepaymentAmount - _loanTerms.loanPrincipalAmount;\n        adminFee = LoanChecksAndCalculations.computeAdminFee(\n            interestDue,\n            uint256(_loanTerms.loanAdminFeeInBasisPoints)\n        );\n        payoffAmount = _loanTerms.maximumRepaymentAmount - adminFee;\n    }\n\n    /**\n     * @dev Function that performs some validation checks over loan parameters when accepting an offer\n     *\n     */\n    function _loanSanityChecksOffer(LoanData.Offer memory _offer) internal pure {\n        if (_offer.maximumRepaymentAmount < _offer.loanPrincipalAmount) {\n            revert NegativeInterestRate();\n        }\n    }\n}\n"
    },
    "contracts/loans/direct/loanTypes/DirectLoanProRatedOffer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {\n    DirectLoanBaseMinimal,\n    NFTfiSigningUtils,\n    LoanChecksAndCalculations,\n    LoanData\n} from \"./DirectLoanBaseMinimal.sol\";\nimport {ContractKeys} from \"../../../utils/ContractKeys.sol\";\n\n/**\n * @title  DirectLoanProRatedOffer\n * @author NFTfi\n * @notice Main contract for NFTfi Direct Loans ProRated Type. This contract manages the ability to create NFT-backed\n * peer-to-peer loans type ProRated (pro-rata interest loan) where the user only pays the principal plus pro-rata\n * interest if repaid early.\n *\n * There are two ways to commence an NFT-backed loan:\n *\n * a. The borrower accepts a lender's offer by calling `acceptOffer`.\n *   1. the borrower calls nftContract.approveAll(NFTfi), approving the NFTfi contract to move their NFT's on their\n * be1alf.\n *   2. the lender calls erc20Contract.approve(NFTfi), allowing NFTfi to move the lender's ERC20 tokens on their\n * behalf.\n *   3. the lender signs an off-chain message, proposing its offer terms.\n *   4. the borrower calls `acceptOffer` to accept these terms and enter into the loan. The NFT is stored in\n * the contract, the borrower receives the loan principal in the specified ERC20 currency, the lender receives an\n * NFTfi promissory note (in ERC721 form) that represents the rights to either the principal-plus-interest, or the\n * underlying NFT collateral if the borrower does not pay back in time, and the borrower receives obligation receipt\n * (in ERC721 form) that gives them the right to pay back the loan and get the collateral back.\n *\n * The lender can freely transfer and trade this ERC721 promissory note as they wish, with the knowledge that\n * transferring the ERC721 promissory note tranfsers the rights to principal-plus-interest and/or collateral, and that\n * they will no longer have a claim on the loan. The ERC721 promissory note itself represents that claim.\n *\n * The borrower can freely transfer and trade this ERC721 obligaiton receipt as they wish, with the knowledge that\n * transferring the ERC721 obligaiton receipt tranfsers the rights right to pay back the loan and get the collateral\n * back.\n *\n *\n * A loan may end in one of two ways:\n * - First, a borrower may call NFTfi.payBackLoan() and pay back the loan plus interest at any time, in which case they\n * receive their NFT back in the same transaction.\n * - Second, if the loan's duration has passed and the loan has not been paid back yet, a lender can call\n * NFTfi.liquidateOverdueLoan(), in which case they receive the underlying NFT collateral and forfeit the rights to the\n * principal-plus-interest, which the borrower now keeps.\n */\ncontract DirectLoanProRatedOffer is DirectLoanBaseMinimal {\n    /* ************* */\n    /* CUSTOM ERRORS */\n    /* ************* */\n\n    error InvalidLenderSignature();\n    error NegativeInterestRate();\n\n    /* ********** */\n    /* DATA TYPES */\n    /* ********** */\n\n    bytes32 public constant LOAN_TYPE = bytes32(\"DIRECT_LOAN_PRO_RATED_OFFER\");\n\n    /* *********** */\n    /* CONSTRUCTOR */\n    /* *********** */\n\n    /**\n     * @dev Sets `hub`\n     *\n     * @param _admin - Initial admin of this contract.\n     * @param  _nftfiHub - NFTfiHub address\n     * @param  _permittedErc20s - list of permitted ERC20 token contract addresses\n     */\n    constructor(\n        address _admin,\n        address _nftfiHub,\n        address[] memory _permittedErc20s\n    )\n        DirectLoanBaseMinimal(\n            _admin,\n            _nftfiHub,\n            ContractKeys.getIdFromStringKey(\"DIRECT_LOAN_COORDINATOR\"),\n            _permittedErc20s\n        )\n    {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /* ********* */\n    /* FUNCTIONS */\n    /* ********* */\n\n    /**\n     * @notice This function is called by the borrower when accepting a lender's offer to begin a loan.\n     *\n     * @param _offer - The offer made by the lender.\n     * @param _signature - The components of the lender's signature.\n     * @param _borrowerSettings - Some extra parameters that the borrower needs to set when accepting an offer.\n     */\n    function acceptOffer(\n        Offer memory _offer,\n        Signature memory _signature,\n        BorrowerSettings memory _borrowerSettings\n    ) external whenNotPaused nonReentrant {\n        address nftWrapper = _getWrapper(_offer.nftCollateralContract);\n        _loanSanityChecks(_offer, nftWrapper);\n        _loanSanityChecksOffer(_offer);\n        _acceptOffer(\n            LOAN_TYPE,\n            _setupLoanTerms(_offer, nftWrapper),\n            _setupLoanExtras(_borrowerSettings.revenueSharePartner, _borrowerSettings.referralFeeInBasisPoints),\n            _offer,\n            _signature\n        );\n    }\n\n    /* ******************* */\n    /* READ-ONLY FUNCTIONS */\n    /* ******************* */\n\n    /**\n     * @notice This function can be used to view the current quantity of the ERC20 currency used in the specified loan\n     * required by the borrower to repay their loan, measured in the smallest unit of the ERC20 currency. Note that\n     * since interest accrues every second, once a borrower calls repayLoan(), the amount will have increased slightly.\n     *\n     * @param _loanId  A unique identifier for this particular loan, sourced from the Loan Coordinator.\n     *\n     * @return The amount of the specified ERC20 currency required to pay back this loan, measured in the smallest unit\n     * of the specified ERC20 currency.\n     */\n    function getPayoffAmount(uint32 _loanId) external view override returns (uint256) {\n        LoanTerms memory loan = loanIdToLoan[_loanId];\n        uint256 loanDurationSoFarInSeconds = block.timestamp - uint256(loan.loanStartTime);\n        uint256 interestDue = _computeInterestDue(\n            loan.loanPrincipalAmount,\n            loan.maximumRepaymentAmount,\n            loanDurationSoFarInSeconds,\n            uint256(loan.loanDuration),\n            uint256(loan.loanInterestRateForDurationInBasisPoints)\n        );\n\n        return (loan.loanPrincipalAmount) + interestDue;\n    }\n\n    /* ****************** */\n    /* INTERNAL FUNCTIONS */\n    /* ****************** */\n\n    /**\n     * @notice This function is called by the borrower when accepting a lender's offer to begin a loan.\n     *\n     * @param _loanType - The loan type being created.\n     * @param _loanTerms - The main Loan Terms struct. This data is saved upon loan creation on loanIdToLoan.\n     * @param _loanExtras - The main Loan Terms struct. This data is saved upon loan creation on loanIdToLoanExtras.\n     * @param _offer - The offer made by the lender.\n     * @param _signature - The components of the lender's signature.\n     */\n    function _acceptOffer(\n        bytes32 _loanType,\n        LoanTerms memory _loanTerms,\n        LoanExtras memory _loanExtras,\n        Offer memory _offer,\n        Signature memory _signature\n    ) internal {\n        // Check loan nonces. These are different from Ethereum account nonces.\n        // Here, these are uint256 numbers that should uniquely identify\n        // each signature for each user (i.e. each user should only create one\n        // off-chain signature for each nonce, with a nonce being any arbitrary\n        // uint256 value that they have not used yet for an off-chain NFTfi\n        // signature).\n        if (_nonceHasBeenUsedForUser[_signature.signer][_signature.nonce]) {\n            revert InvalidNonce();\n        }\n\n        _nonceHasBeenUsedForUser[_signature.signer][_signature.nonce] = true;\n\n        if (!NFTfiSigningUtils.isValidLenderSignature(_offer, _signature)) {\n            revert InvalidLenderSignature();\n        }\n\n        uint32 loanId = _createLoan(_loanType, _loanTerms, _loanExtras, msg.sender, _signature.signer, _offer.referrer);\n\n        // Emit an event with all relevant details from this transaction.\n        emit LoanStarted(loanId, msg.sender, _signature.signer, _loanTerms, _loanExtras);\n    }\n\n    /**\n     * @dev Calculates and updates loanInterestRateForDurationInBasisPoints rate\n     * based on loanPrincipalAmount and maximumRepaymentAmount\n     */\n    function _updateInterestRate(uint32 _loanId) internal {\n        LoanTerms storage loan = loanIdToLoan[_loanId];\n        loan.loanInterestRateForDurationInBasisPoints = _calculateInterestRate(\n            loan.loanPrincipalAmount,\n            loan.maximumRepaymentAmount\n        );\n    }\n\n    /**\n     * @dev Calculates the payoff amount and admin fee\n     *\n     * @param _loan - Struct containing all the loan's parameters\n     */\n    function _payoffAndFee(\n        LoanTerms memory _loan\n    ) internal view override returns (uint256 adminFee, uint256 payoffAmount) {\n        // Calculate amounts to send to lender and admins\n        uint256 interestDue = _computeInterestDue(\n            _loan.loanPrincipalAmount,\n            _loan.maximumRepaymentAmount,\n            block.timestamp - uint256(_loan.loanStartTime),\n            uint256(_loan.loanDuration),\n            uint256(_loan.loanInterestRateForDurationInBasisPoints)\n        );\n        adminFee = LoanChecksAndCalculations.computeAdminFee(interestDue, uint256(_loan.loanAdminFeeInBasisPoints));\n        payoffAmount = ((_loan.loanPrincipalAmount) + interestDue) - adminFee;\n    }\n\n    /**\n     * @dev Creates a `LoanTerms` struct using data sent as the lender's `_offer` on `acceptOffer`.\n     * This is needed in order to avoid stack too deep issues.\n     */\n    function _setupLoanTerms(Offer memory _offer, address _nftWrapper) internal view returns (LoanTerms memory) {\n        return\n            LoanTerms({\n                loanERC20Denomination: _offer.loanERC20Denomination,\n                loanPrincipalAmount: _offer.loanPrincipalAmount,\n                maximumRepaymentAmount: _offer.maximumRepaymentAmount,\n                nftCollateralContract: _offer.nftCollateralContract,\n                nftCollateralWrapper: _nftWrapper,\n                nftCollateralId: _offer.nftCollateralId,\n                loanStartTime: uint64(block.timestamp),\n                loanDuration: _offer.loanDuration,\n                loanInterestRateForDurationInBasisPoints: _calculateInterestRate(\n                    _offer.loanPrincipalAmount,\n                    _offer.maximumRepaymentAmount\n                ),\n                loanAdminFeeInBasisPoints: _offer.loanAdminFeeInBasisPoints,\n                borrower: msg.sender\n            });\n    }\n\n    /**\n     * @notice A convenience function that calculates the amount of interest currently due for a given loan. The\n     * interest is capped at _maximumRepaymentAmount minus _loanPrincipalAmount.\n     *\n     * @param _loanPrincipalAmount - The total quantity of principal first loaned to the borrower, measured in the\n     * smallest units of the ERC20 currency used for the loan.\n     * @param _maximumRepaymentAmount - The maximum amount of money that the borrower would be required to retrieve\n     * their collateral. If interestIsProRated is set to false, then the borrower will always have to pay this amount to\n     * retrieve their collateral.\n     * @param _loanDurationSoFarInSeconds - The elapsed time (in seconds) that has occurred so far since the loan began\n     * until repayment.\n     * @param _loanTotalDurationAgreedTo - The original duration that the borrower and lender agreed to, by which they\n     * measured the interest that would be due.\n     * @param _loanInterestRateForDurationInBasisPoints - The interest rate that the borrower and lender agreed would be\n     * due after the totalDuration passed.\n     *\n     * @return The quantity of interest due, measured in the smallest units of the ERC20 currency used to pay this loan.\n     */\n    function _computeInterestDue(\n        uint256 _loanPrincipalAmount,\n        uint256 _maximumRepaymentAmount,\n        uint256 _loanDurationSoFarInSeconds,\n        uint256 _loanTotalDurationAgreedTo,\n        uint256 _loanInterestRateForDurationInBasisPoints\n    ) internal pure returns (uint256) {\n        uint256 interestDueAfterEntireDurationInBasisPoints = (_loanPrincipalAmount *\n            _loanInterestRateForDurationInBasisPoints);\n        uint256 interestDueAfterElapsedDuration = (interestDueAfterEntireDurationInBasisPoints *\n            _loanDurationSoFarInSeconds) /\n            _loanTotalDurationAgreedTo /\n            uint256(HUNDRED_PERCENT);\n        if (_loanPrincipalAmount + interestDueAfterElapsedDuration > _maximumRepaymentAmount) {\n            return (_maximumRepaymentAmount - _loanPrincipalAmount);\n        } else {\n            return interestDueAfterElapsedDuration;\n        }\n    }\n\n    /**\n     * @dev Calculates loanInterestRateForDurationInBasisPoints rate\n     * based on loanPrincipalAmount and maximumRepaymentAmount\n     */\n    function _calculateInterestRate(\n        uint256 _loanPrincipalAmount,\n        uint256 _maximumRepaymentAmount\n    ) internal pure returns (uint16) {\n        uint256 interest = _maximumRepaymentAmount - _loanPrincipalAmount;\n        return uint16((interest * HUNDRED_PERCENT) / _loanPrincipalAmount);\n    }\n\n    /**\n     * @dev Function that performs some validation checks over loan parameters when accepting an offer\n     *\n     */\n    function _loanSanityChecksOffer(LoanData.Offer memory _offer) internal pure {\n        if (_offer.maximumRepaymentAmount < _offer.loanPrincipalAmount) {\n            revert NegativeInterestRate();\n        }\n    }\n}\n"
    },
    "contracts/loans/direct/loanTypes/IDirectLoanBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\ninterface IDirectLoanBase {\n    function maximumLoanDuration() external view returns (uint256);\n\n    function adminFeeInBasisPoints() external view returns (uint16);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function LOAN_COORDINATOR() external view returns (bytes32);\n\n    function loanIdToLoan(\n        uint32\n    )\n        external\n        view\n        returns (uint256, uint256, uint256, address, uint32, uint16, uint16, address, uint64, address, address);\n\n    function loanRepaidOrLiquidated(uint32) external view returns (bool);\n\n    function getWhetherNonceHasBeenUsedForUser(address _user, uint256 _nonce) external view returns (bool);\n}\n"
    },
    "contracts/loans/direct/loanTypes/LoanChecksAndCalculations.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {IDirectLoanBase} from \"./IDirectLoanBase.sol\";\nimport {LoanData} from \"./LoanData.sol\";\nimport {IDirectLoanCoordinator} from \"../../../interfaces/IDirectLoanCoordinator.sol\";\nimport {ContractKeys} from \"../../../utils/ContractKeys.sol\";\nimport {INftfiHub} from \"../../../interfaces/INftfiHub.sol\";\nimport {IPermittedPartners} from \"../../../interfaces/IPermittedPartners.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/**\n * @title  LoanChecksAndCalculations\n * @author NFTfi\n * @notice Helper library for LoanBase\n */\nlibrary LoanChecksAndCalculations {\n    uint16 private constant HUNDRED_PERCENT = 10000;\n\n    /**\n     * @dev Function that performs some validation checks before trying to repay a loan\n     *\n     * @param _loanId - The id of the loan being repaid\n     */\n    function payBackChecks(uint32 _loanId, INftfiHub _hub) external view {\n        checkLoanIdValidity(_loanId, _hub);\n        // Sanity check that payBackLoan() and liquidateOverdueLoan() have never been called on this loanId.\n        // Depending on how the rest of the code turns out, this check may be unnecessary.\n        // solhint-disable-next-line custom-errors\n        require(!IDirectLoanBase(address(this)).loanRepaidOrLiquidated(_loanId), \"Loan already repaid/liquidated\");\n\n        // Fetch loan details from storage, but store them in memory for the sake of saving gas.\n        (, , , , uint32 loanDuration, , , , uint64 loanStartTime, , ) = IDirectLoanBase(address(this)).loanIdToLoan(\n            _loanId\n        );\n\n        // When a loan exceeds the loan term, it is expired. At this stage the Lender can call Liquidate Loan to resolve\n        // the loan.\n        // solhint-disable-next-line custom-errors\n        require(block.timestamp <= (uint256(loanStartTime) + uint256(loanDuration)), \"Loan is expired\");\n    }\n\n    function checkLoanIdValidity(uint32 _loanId, INftfiHub _hub) public view {\n        // solhint-disable-next-line custom-errors\n        require(\n            IDirectLoanCoordinator(_hub.getContract(IDirectLoanBase(address(this)).LOAN_COORDINATOR())).isValidLoanId(\n                _loanId,\n                address(this)\n            ),\n            \"invalid loanId\"\n        );\n    }\n\n    /**\n     * @dev Function that the partner is permitted and returns its shared percent.\n     *\n     * @param _revenueSharePartner - Partner's address\n     *\n     * @return The revenue share percent for the partner.\n     */\n    function getRevenueSharePercent(address _revenueSharePartner, INftfiHub _hub) external view returns (uint16) {\n        // return soon if no partner is set to avoid a public call\n        if (_revenueSharePartner == address(0)) {\n            return 0;\n        }\n\n        uint16 revenueSharePercent = IPermittedPartners(_hub.getContract(ContractKeys.PERMITTED_PARTNERS))\n            .getPartnerPermit(_revenueSharePartner);\n\n        return revenueSharePercent;\n    }\n\n    /**\n     * @dev Performs some validation checks before trying to renegotiate a loan.\n     * Needed to avoid stack too deep.\n     *\n     * @param _loan - The main Loan Terms struct.\n     * @param _loanId - The unique identifier for the loan to be renegotiated\n     * @param _newLoanDuration - The new amount of time (measured in seconds) that can elapse before the lender can\n     * liquidate the loan and seize the underlying collateral NFT.\n     * @param _newMaximumRepaymentAmount - The new maximum amount of money that the borrower would be required to\n     * retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The\n     * borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay\n     * early.\n     * @param _lenderNonce - The nonce referred to here is not the same as an Ethereum account's nonce. We are\n     * referring instead to nonces that are used by both the lender and the borrower when they are first signing\n     * off-chain NFTfi orders. These nonces can be any uint256 value that the user has not previously used to sign an\n     * off-chain order. Each nonce can be used at most once per user within NFTfi, regardless of whether they are the\n     * lender or the borrower in that situation. This serves two purposes:\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\n     , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\n     * that nonce.\n     * @return Borrower and Lender addresses\n     */\n    function renegotiationChecks(\n        LoanData.LoanTerms memory _loan,\n        uint32 _loanId,\n        uint32 _newLoanDuration,\n        uint256 _newMaximumRepaymentAmount,\n        uint256 _lenderNonce,\n        INftfiHub _hub\n    ) external view returns (address, address) {\n        checkLoanIdValidity(_loanId, _hub);\n        IDirectLoanCoordinator loanCoordinator = IDirectLoanCoordinator(\n            _hub.getContract(IDirectLoanBase(address(this)).LOAN_COORDINATOR())\n        );\n        uint256 smartNftId = loanCoordinator.getLoanData(_loanId).smartNftId;\n\n        address borrower;\n\n        if (_loan.borrower != address(0)) {\n            borrower = _loan.borrower;\n        } else {\n            borrower = IERC721(loanCoordinator.obligationReceiptToken()).ownerOf(smartNftId);\n        }\n\n        // solhint-disable-next-line custom-errors\n        require(msg.sender == borrower, \"Only borrower can initiate\");\n        // solhint-disable-next-line custom-errors\n        require(block.timestamp <= (uint256(_loan.loanStartTime) + _newLoanDuration), \"New duration already expired\");\n        // solhint-disable-next-line custom-errors\n        require(\n            uint256(_newLoanDuration) <= IDirectLoanBase(address(this)).maximumLoanDuration(),\n            \"New duration exceeds maximum loan duration\"\n        );\n        // solhint-disable-next-line custom-errors\n        require(!IDirectLoanBase(address(this)).loanRepaidOrLiquidated(_loanId), \"Loan already repaid/liquidated\");\n        // solhint-disable-next-line custom-errors\n        require(\n            _newMaximumRepaymentAmount >= _loan.loanPrincipalAmount,\n            \"Negative interest rate loans are not allowed.\"\n        );\n\n        // Fetch current owner of loan promissory note.\n        address lender = IERC721(loanCoordinator.promissoryNoteToken()).ownerOf(smartNftId);\n\n        // solhint-disable-next-line custom-errors\n        require(\n            !IDirectLoanBase(address(this)).getWhetherNonceHasBeenUsedForUser(lender, _lenderNonce),\n            \"Lender nonce invalid\"\n        );\n\n        return (borrower, lender);\n    }\n\n    /**\n     * @notice A convenience function computing the revenue share taken from the admin fee to transferr to the permitted\n     * partner.\n     *\n     * @param _adminFee - The quantity of ERC20 currency (measured in smalled units of that ERC20 currency) that is due\n     * as an admin fee.\n     * @param _revenueShareInBasisPoints - The percent (measured in basis points) of the admin fee amount that will be\n     * taken as a revenue share for a the partner, at the moment the loan is begun.\n     *\n     * @return The quantity of ERC20 currency (measured in smalled units of that ERC20 currency) that should be sent to\n     * the `revenueSharePartner`.\n     */\n    function computeRevenueShare(\n        uint256 _adminFee,\n        uint256 _revenueShareInBasisPoints\n    ) external pure returns (uint256) {\n        return (_adminFee * _revenueShareInBasisPoints) / HUNDRED_PERCENT;\n    }\n\n    /**\n     * @notice A convenience function computing the adminFee taken from a specified quantity of interest.\n     *\n     * @param _interestDue - The amount of interest due, measured in the smallest quantity of the ERC20 currency being\n     * used to pay the interest.\n     * @param _adminFeeInBasisPoints - The percent (measured in basis points) of the interest earned that will be taken\n     * as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\n     * earned.\n     *\n     * @return The quantity of ERC20 currency (measured in smalled units of that ERC20 currency) that is due as an admin\n     * fee.\n     */\n    function computeAdminFee(uint256 _interestDue, uint256 _adminFeeInBasisPoints) external pure returns (uint256) {\n        return (_interestDue * _adminFeeInBasisPoints) / HUNDRED_PERCENT;\n    }\n\n    /**\n     * @notice A convenience function computing the referral fee taken from the loan principal amount to transferr to\n     * the referrer.\n     *\n     * @param _loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\n     * the loan, measured in loanERC20Denomination's smallest units.\n     * @param _referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.\n     * @param _referrer - The address of the referrer who found the lender matching the listing, Zero address to signal\n     * that there is no referrer.\n     *\n     * @return The quantity of ERC20 currency (measured in smalled units of that ERC20 currency) that should be sent to\n     * the referrer.\n     */\n    function computeReferralFee(\n        uint256 _loanPrincipalAmount,\n        uint256 _referralFeeInBasisPoints,\n        address _referrer\n    ) external pure returns (uint256) {\n        if (_referralFeeInBasisPoints == 0 || _referrer == address(0)) {\n            return 0;\n        }\n        return (_loanPrincipalAmount * _referralFeeInBasisPoints) / HUNDRED_PERCENT;\n    }\n}\n"
    },
    "contracts/loans/direct/loanTypes/LoanData.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\n/**\n * @title  LoanData\n * @author NFTfi\n * @notice An interface containg the main Loan struct shared by Direct Loans types.\n */\ninterface LoanData {\n    /* ********** */\n    /* DATA TYPES */\n    /* ********** */\n\n    /**\n     * @notice The main Loan Terms struct. This data is saved upon loan creation.\n     *\n     * @param loanERC20Denomination - The address of the ERC20 contract of the currency being used as principal/interest\n     * for this loan.\n     * @param loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\n     * the loan, measured in loanERC20Denomination's smallest units.\n     * @param maximumRepaymentAmount - The maximum amount of money that the borrower would be required to retrieve their\n     * collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have\n     * to pay this amount to retrieve their collateral, regardless of whether they repay early.\n     * @param nftCollateralContract - The address of the the NFT collateral contract.\n     * @param nftCollateralWrapper - The NFTfi wrapper of the NFT collateral contract.\n     * @param nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\n     * loan. The NFT is stored within this contract during the duration of the loan.\n     * @param loanStartTime - The block.timestamp when the loan first began (measured in seconds).\n     * @param loanDuration - The amount of time (measured in seconds) that can elapse before the lender can liquidate\n     * the loan and seize the underlying collateral NFT.\n     * @param loanInterestRateForDurationInBasisPoints - This is the interest rate (measured in basis points, e.g.\n     * hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan\n     * or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and\n     * is irrelevant so it should be set to 0.\n     * @param loanAdminFeeInBasisPoints - The percent (measured in basis points) of the interest earned that will be\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\n     * earned.\n     * @param borrower\n     */\n    struct LoanTerms {\n        uint256 loanPrincipalAmount;\n        uint256 maximumRepaymentAmount;\n        uint256 nftCollateralId;\n        address loanERC20Denomination;\n        uint32 loanDuration;\n        uint16 loanInterestRateForDurationInBasisPoints;\n        uint16 loanAdminFeeInBasisPoints;\n        address nftCollateralWrapper;\n        uint64 loanStartTime;\n        address nftCollateralContract;\n        address borrower;\n    }\n\n    /**\n     * @notice Some extra Loan's settings struct. This data is saved upon loan creation.\n     * We need this to avoid stack too deep errors.\n     *\n     * @param revenueSharePartner - The address of the partner that will receive the revenue share.\n     * @param revenueShareInBasisPoints - The percent (measured in basis points) of the admin fee amount that will be\n     * taken as a revenue share for a t\n     * @param referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.he partner, at the moment\n     * the loan is begun.\n     */\n    struct LoanExtras {\n        address revenueSharePartner;\n        uint16 revenueShareInBasisPoints;\n        uint16 referralFeeInBasisPoints;\n    }\n\n    /**\n     * @notice The offer made by the lender. Used as parameter on both acceptOffer (initiated by the borrower)\n     *\n     * @param loanERC20Denomination - The address of the ERC20 contract of the currency being used as principal/interest\n     * for this loan.\n     * @param loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\n     * the loan, measured in loanERC20Denomination's smallest units.\n     * @param maximumRepaymentAmount - The maximum amount of money that the borrower would be required to retrieve their\n     *  collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always\n     * have to pay this amount to retrieve their collateral, regardless of whether they repay early.\n     * @param nftCollateralContract - The address of the ERC721 contract of the NFT collateral.\n     * @param nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\n     * loan. The NFT is stored within this contract during the duration of the loan.\n     * @param referrer - The address of the referrer who found the lender matching the listing, Zero address to signal\n     * this there is no referrer.\n     * @param loanDuration - The amount of time (measured in seconds) that can elapse before the lender can liquidate\n     * the loan and seize the underlying collateral NFT.\n     * @param loanAdminFeeInBasisPoints - The percent (measured in basis points) of the interest earned that will be\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\n     * earned.\n     */\n    struct Offer {\n        uint256 loanPrincipalAmount;\n        uint256 maximumRepaymentAmount;\n        uint256 nftCollateralId;\n        address nftCollateralContract;\n        uint32 loanDuration;\n        uint16 loanAdminFeeInBasisPoints;\n        address loanERC20Denomination;\n        address referrer;\n    }\n\n    /**\n     * @notice Signature related params. Used as parameter on both acceptOffer (containing borrower signature)\n     *\n     * @param signer - The address of the signer. The borrower for `acceptOffer`\n     * @param nonce - The nonce referred here is not the same as an Ethereum account's nonce.\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\n     * off-chain order. Each nonce can be used at most once peruser within NFTfi, regardless of whether they are the\n     * lender or the borrower in that situation. This serves two purposes:\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\n     * , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\n     * that nonce.\n     * @param expiry - Date when the signature expires\n     * @param signature - The ECDSA signature of the borrower or the lender, obtained off-chain ahead of time, signing\n     * the following combination of parameters:\n     * - Lender:\n     *   - Offer.loanERC20Denomination\n     *   - Offer.loanPrincipalAmount\n     *   - Offer.maximumRepaymentAmount\n     *   - Offer.nftCollateralContract\n     *   - Offer.nftCollateralId\n     *   - Offer.referrer\n     *   - Offer.loanDuration\n     *   - Offer.loanAdminFeeInBasisPoints\n     *   - Signature.signer,\n     *   - Signature.nonce,\n     *   - Signature.expiry,\n     *   - address of the loan type contract\n     *   - chainId\n     */\n    struct Signature {\n        uint256 nonce;\n        uint256 expiry;\n        address signer;\n        bytes signature;\n    }\n\n    /**\n     * inclusive min and max Id ranges for collection offers on collections,\n     * like ArtBlocks, where multiple collections are defined on one contract differentiated by id-ranges\n     */\n    struct CollectionIdRange {\n        uint256 minId;\n        uint256 maxId;\n    }\n\n    /**\n     * @notice Some extra parameters that the borrower needs to set when accepting an offer.\n     *\n     * @param revenueSharePartner - The address of the partner that will receive the revenue share.\n     * @param referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.\n     */\n    struct BorrowerSettings {\n        address revenueSharePartner;\n        uint16 referralFeeInBasisPoints;\n    }\n}\n"
    },
    "contracts/NftfiHub.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {INftfiHub} from \"./interfaces/INftfiHub.sol\";\nimport {Ownable} from \"./utils/Ownable.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {ContractKeys} from \"./utils/ContractKeys.sol\";\n\n/**\n * @title  NftfiHub\n * @author NFTfi\n * @dev Registry for the contracts supported by NFTfi protocol.\n */\ncontract NftfiHub is Ownable, Pausable, ReentrancyGuard, INftfiHub {\n    /* ******* */\n    /* STORAGE */\n    /* ******* */\n\n    mapping(bytes32 => address) private contracts;\n\n    /* ****** */\n    /* EVENTS */\n    /* ****** */\n\n    /**\n     * @notice This event is fired whenever the admin registers a contract.\n     *\n     * @param contractKey - Contract key e.g. bytes32('PERMITTED_NFTS').\n     * @param contractAddress - Address of the contract.\n     */\n    event ContractUpdated(bytes32 indexed contractKey, address indexed contractAddress);\n\n    /* *********** */\n    /* CONSTRUCTOR */\n    /* *********** */\n\n    /**\n     * @dev Initializes `contracts` with a batch of permitted contracts\n     *\n     * @param _admin - Initial admin of this contract.\n     * @param _contractKeys - Initial contract keys.\n     * @param _contractAddresses - Initial associated contract addresses.\n     */\n    constructor(address _admin, string[] memory _contractKeys, address[] memory _contractAddresses) Ownable(_admin) {\n        _setContracts(_contractKeys, _contractAddresses);\n    }\n\n    /* ********* */\n    /* FUNCTIONS */\n    /* ********* */\n\n    /**\n     * @notice Set or update the contract address for the given key.\n     * @param _contractKey - New or existing contract key.\n     * @param _contractAddress - The associated contract address.\n     */\n    function setContract(string calldata _contractKey, address _contractAddress) external override onlyOwner {\n        _setContract(_contractKey, _contractAddress);\n    }\n\n    /**\n     * @notice Set or update the contract addresses for the given keys.\n     * @param _contractKeys - New or existing contract keys.\n     * @param _contractAddresses - The associated contract addresses.\n     */\n    function setContracts(string[] memory _contractKeys, address[] memory _contractAddresses) external onlyOwner {\n        _setContracts(_contractKeys, _contractAddresses);\n    }\n\n    /**\n     * @notice This function can be called by anyone to lookup the contract address associated with the key.\n     * @param  _contractKey - The index to the contract address.\n     */\n    function getContract(bytes32 _contractKey) external view override returns (address) {\n        return contracts[_contractKey];\n    }\n\n    /**\n     * @notice Set or update the contract address for the given key.\n     * @param _contractKey - New or existing contract key.\n     * @param _contractAddress - The associated contract address.\n     */\n    function _setContract(string memory _contractKey, address _contractAddress) internal {\n        bytes32 key = ContractKeys.getIdFromStringKey(_contractKey);\n        contracts[key] = _contractAddress;\n\n        emit ContractUpdated(key, _contractAddress);\n    }\n\n    /**\n     * @notice Set or update the contract addresses for the given keys.\n     * @param _contractKeys - New or existing contract key.\n     * @param _contractAddresses - The associated contract address.\n     */\n    function _setContracts(string[] memory _contractKeys, address[] memory _contractAddresses) internal {\n        // solhint-disable-next-line custom-errors\n        require(_contractKeys.length == _contractAddresses.length, \"setContracts function information arity mismatch\");\n\n        for (uint256 i; i < _contractKeys.length; ++i) {\n            _setContract(_contractKeys[i], _contractAddresses[i]);\n        }\n    }\n}\n"
    },
    "contracts/nftTypeRegistry/nftTypes/CryptoKittiesWrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {INftWrapper} from \"../../interfaces/INftWrapper.sol\";\nimport {ICryptoKitties} from \"../../interfaces/ICryptoKitties.sol\";\n\n/**\n * @title CryptoKittiesWrapper\n * @author NFTfi\n * @dev Provides logic to transfer CryptoKitties\n */\ncontract CryptoKittiesWrapper is INftWrapper {\n    /**\n     * @dev Transfers Kitty `_nftId` handled by the contract `_nftContract` from `_sender` to `_recipient`\n     *\n     * @param _sender - The current owner of the Kitty\n     * @param _recipient - The new owner of the Kitty\n     * @param _nftContract - CryptoKitties contract\n     * @param _nftId - Kitty id\n     *\n     * @return true if successfully transferred, false otherwise\n     */\n    function transferNFT(\n        address _sender,\n        address _recipient,\n        address _nftContract,\n        uint256 _nftId\n    ) external override returns (bool) {\n        if (_sender == address(this)) {\n            ICryptoKitties(_nftContract).transfer(_recipient, _nftId);\n        } else {\n            ICryptoKitties(_nftContract).transferFrom(_sender, _recipient, _nftId);\n        }\n\n        return true;\n    }\n\n    function approveNFT(address to, address nftContract, uint256 tokenId) external override returns (bool) {\n        ICryptoKitties(nftContract).approve(to, tokenId);\n        return true;\n    }\n\n    function isOwner(address _owner, address _nftContract, uint256 _tokenId) external view override returns (bool) {\n        return ICryptoKitties(_nftContract).ownerOf(_tokenId) == _owner;\n    }\n}\n"
    },
    "contracts/nftTypeRegistry/nftTypes/ERC1155Wrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {INftWrapper} from \"../../interfaces/INftWrapper.sol\";\n\n/**\n * @title ERC1155Wrapper\n * @dev Provides logic to transfer ERC1155 tokens\n */\ncontract ERC1155Wrapper is INftWrapper {\n    /**\n     * @dev Transfer the nft to the `recipient`\n     *\n     * @param _sender Address of the current owner of the nft\n     * @param _recipient Address that will receive the nft\n     * @param _nftContract Address of the nft contract\n     * @param _nftId Id of the nft\n     *\n     * @return true if successfully transferred, false otherwise\n     */\n    function transferNFT(\n        address _sender,\n        address _recipient,\n        address _nftContract,\n        uint256 _nftId\n    ) external override returns (bool) {\n        // Warning:\n        // Since we permit ERC1155s in their entirety, the given nftId may represent a fungible token (amount > 1),\n        // in which case they are treated as non-fungible by hard coding the amount to 1.\n        IERC1155(_nftContract).safeTransferFrom(_sender, _recipient, _nftId, 1, \"\");\n        return true;\n    }\n\n    function approveNFT(address to, address nftContract, uint256) external override returns (bool) {\n        IERC1155(nftContract).setApprovalForAll(to, true);\n        return true;\n    }\n\n    function isOwner(address _owner, address _nftContract, uint256 _tokenId) external view override returns (bool) {\n        return IERC1155(_nftContract).balanceOf(_owner, _tokenId) > 0;\n    }\n}\n"
    },
    "contracts/nftTypeRegistry/nftTypes/ERC721LegacyWrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {INftWrapper} from \"../../interfaces/INftWrapper.sol\";\n\n/**\n * @title ERC721LegacyWrapper\n * @author NFTfi\n * @dev Provides logic to transfer ERC721, uses regular transferFrom instead of safe\n */\ncontract ERC721LegacyWrapper is INftWrapper {\n    /**\n     * @dev Transfers ERC721 `_nftId` handled by the contract `_nftContract` from `_sender` to `_recipient`\n     *\n     * @param _sender - The current owner of the ERC721\n     * @param _recipient - The new owner of the ERC721\n     * @param _nftContract - ERC721 contract\n     * @param _nftId - ERC721 id\n     *\n     * @return true if successfully transferred, false otherwise\n     */\n    function transferNFT(\n        address _sender,\n        address _recipient,\n        address _nftContract,\n        uint256 _nftId\n    ) external override returns (bool) {\n        IERC721(_nftContract).transferFrom(_sender, _recipient, _nftId);\n        return true;\n    }\n\n    function approveNFT(address to, address nftContract, uint256 tokenId) external override returns (bool) {\n        IERC721(nftContract).approve(to, tokenId);\n        return true;\n    }\n\n    function isOwner(address _owner, address _nftContract, uint256 _tokenId) external view override returns (bool) {\n        return IERC721(_nftContract).ownerOf(_tokenId) == _owner;\n    }\n}\n"
    },
    "contracts/nftTypeRegistry/nftTypes/ERC721Wrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {INftWrapper} from \"../../interfaces/INftWrapper.sol\";\n\n/**\n * @title ERC721Wrapper\n * @author NFTfi\n * @dev Provides logic to transfer ERC721\n */\ncontract ERC721Wrapper is INftWrapper {\n    /**\n     * @dev Transfers ERC721 `_nftId` handled by the contract `_nftContract` from `_sender` to `_recipient`\n     *\n     * @param _sender - The current owner of the ERC721\n     * @param _recipient - The new owner of the ERC721\n     * @param _nftContract - ERC721 contract\n     * @param _nftId - ERC721 id\n     *\n     * @return true if successfully transferred, false otherwise\n     */\n    function transferNFT(\n        address _sender,\n        address _recipient,\n        address _nftContract,\n        uint256 _nftId\n    ) external override returns (bool) {\n        IERC721(_nftContract).safeTransferFrom(_sender, _recipient, _nftId);\n        return true;\n    }\n\n    function approveNFT(address to, address nftContract, uint256 tokenId) external override returns (bool) {\n        IERC721(nftContract).approve(to, tokenId);\n        return true;\n    }\n\n    function isOwner(address _owner, address _nftContract, uint256 _tokenId) external view override returns (bool) {\n        return IERC721(_nftContract).ownerOf(_tokenId) == _owner;\n    }\n}\n"
    },
    "contracts/nftTypeRegistry/nftTypes/PunkWrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {INftWrapper} from \"../../interfaces/INftWrapper.sol\";\nimport {IPunks} from \"../../interfaces/IPunks.sol\";\n\n/**\n * @title PunkWrapper\n * @author NFTfi\n * @dev Provides logic to transfer Punks\n */\ncontract PunkWrapper is INftWrapper {\n    /**\n     * @dev Transfers Punk `_nftId` handled by the contract `_nftContract` from `_sender` to `_recipient`\n     *\n     * @param _sender - The current owner of the Punk\n     * @param _recipient - The new owner of the Punk\n     * @param _nftContract - Punk contract\n     * @param _nftId - Punk id\n     *\n     * @return true if successfully transferred, false otherwise\n     */\n    function transferNFT(\n        address _sender,\n        address _recipient,\n        address _nftContract,\n        uint256 _nftId\n    ) external override returns (bool) {\n        if (address(this) == _sender) {\n            IPunks(_nftContract).transferPunk(_recipient, _nftId);\n        } else {\n            // solhint-disable-next-line custom-errors\n            require(isOwner(_sender, _nftContract, _nftId), \"PunkWrapper:sender must be owner\");\n            IPunks(_nftContract).buyPunk(_nftId);\n        }\n        return true;\n    }\n\n    function approveNFT(address to, address nftContract, uint256 tokenId) external override returns (bool) {\n        IPunks(nftContract).offerPunkForSaleToAddress(tokenId, 0, to);\n        return true;\n    }\n\n    function isOwner(address _owner, address _nftContract, uint256 _tokenId) public view override returns (bool) {\n        return IPunks(_nftContract).punkIndexToAddress(_tokenId) == _owner;\n    }\n}\n"
    },
    "contracts/permittedLists/PermittedERC20s.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {IPermittedERC20s} from \"../interfaces/IPermittedERC20s.sol\";\nimport {Ownable} from \"../utils/Ownable.sol\";\n\n/**\n * @title  PermittedERC20s\n * @author NFTfi\n * @dev Registry for ERC20 currencies supported by NFTfi. Each ERC20 is\n * associated with a boolean permit.\n */\ncontract PermittedERC20s is Ownable, IPermittedERC20s {\n    /* ******* */\n    /* STORAGE */\n    /* ******* */\n\n    /**\n     * @notice A mapping from an ERC20 currency address to whether that currency\n     * is permitted to be used by this contract.\n     */\n    mapping(address => bool) private erc20Permits;\n\n    /* ****** */\n    /* EVENTS */\n    /* ****** */\n\n    /**\n     * @notice This event is fired whenever the admin sets a ERC20 permit.\n     *\n     * @param erc20Contract - Address of the ERC20 contract.\n     * @param isPermitted - Signals ERC20 permit.\n     */\n    event ERC20Permit(address indexed erc20Contract, bool isPermitted);\n\n    /* *********** */\n    /* CONSTRUCTOR */\n    /* *********** */\n\n    /**\n     * @notice Initialize `erc20Permits` with a batch of permitted ERC20s\n     *\n     * @param _admin - Initial admin of this contract.\n     * @param _permittedErc20s - The batch of addresses initially permitted.\n     */\n    constructor(address _admin, address[] memory _permittedErc20s) Ownable(_admin) {\n        for (uint256 i; i < _permittedErc20s.length; ++i) {\n            _setERC20Permit(_permittedErc20s[i], true);\n        }\n    }\n\n    /* ********* */\n    /* FUNCTIONS */\n    /* ********* */\n\n    /**\n     * @notice This function can be called by admins to change the permitted status of an ERC20 currency. This includes\n     * both adding an ERC20 currency to the permitted list and removing it.\n     *\n     * @param _erc20 - The address of the ERC20 currency whose permit list status changed.\n     * @param _permit - The new status of whether the currency is permitted or not.\n     */\n    function setERC20Permit(address _erc20, bool _permit) external onlyOwner {\n        _setERC20Permit(_erc20, _permit);\n    }\n\n    /**\n     * @notice This function can be called by admins to change the permitted status of a batch of ERC20 currency. This\n     * includes both adding an ERC20 currency to the permitted list and removing it.\n     *\n     * @param _erc20s - The addresses of the ERC20 currencies whose permit list status changed.\n     * @param _permits - The new statuses of whether the currency is permitted or not.\n     */\n    function setERC20Permits(address[] memory _erc20s, bool[] memory _permits) external onlyOwner {\n        // solhint-disable-next-line custom-errors\n        require(_erc20s.length == _permits.length, \"setERC20Permits function information arity mismatch\");\n\n        for (uint256 i; i < _erc20s.length; ++i) {\n            _setERC20Permit(_erc20s[i], _permits[i]);\n        }\n    }\n\n    /**\n     * @notice This function can be called by anyone to get the permit associated with the erc20 contract.\n     *\n     * @param _erc20 - The address of the erc20 contract.\n     *\n     * @return Returns whether the erc20 is permitted\n     */\n    function getERC20Permit(address _erc20) external view override returns (bool) {\n        return erc20Permits[_erc20];\n    }\n\n    /**\n     * @notice This function can be called by admins to change the permitted status of an ERC20 currency. This includes\n     * both adding an ERC20 currency to the permitted list and removing it.\n     *\n     * @param _erc20 - The address of the ERC20 currency whose permit list status changed.\n     * @param _permit - The new status of whether the currency is permitted or not.\n     */\n    function _setERC20Permit(address _erc20, bool _permit) internal {\n        // solhint-disable-next-line custom-errors\n        require(_erc20 != address(0), \"erc20 is zero address\");\n\n        erc20Permits[_erc20] = _permit;\n\n        emit ERC20Permit(_erc20, _permit);\n    }\n}\n"
    },
    "contracts/permittedLists/PermittedNFTsAndTypeRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {IPermittedNFTs} from \"../interfaces/IPermittedNFTs.sol\";\nimport {INftfiHub} from \"../interfaces/INftfiHub.sol\";\n\nimport {Ownable} from \"../utils/Ownable.sol\";\nimport {ContractKeys} from \"../utils/ContractKeys.sol\";\n\n/**\n * @title  PermittedNFTsAndTypeRegistry\n * @author NFTfi\n * @dev Registry for NFT contracts supported by NFTfi.\n * Each NFT is associated with an NFT Type.\n */\ncontract PermittedNFTsAndTypeRegistry is Ownable, IPermittedNFTs {\n    INftfiHub public hub;\n    mapping(bytes32 => address) private nftTypes;\n\n    /**\n     * @notice A mapping from an NFT contract's address to the Token type of that contract. A zero Token Type indicates\n     * non-permitted.\n     */\n    mapping(address => bytes32) private nftPermits;\n\n    /* ****** */\n    /* EVENTS */\n    /* ****** */\n\n    /**\n     * @notice This event is fired whenever the admins register a ntf type.\n     *\n     * @param nftType - Nft type represented by keccak256('nft type').\n     * @param nftWrapper - Address of the wrapper contract.\n     */\n    event TypeUpdated(bytes32 indexed nftType, address indexed nftWrapper);\n\n    /**\n     * @notice This event is fired whenever the admin sets a NFT's permit.\n     *\n     * @param nftContract - Address of the NFT contract.\n     * @param nftType - NTF type e.g. bytes32(\"CRYPTO_KITTIES\")\n     */\n    event NFTPermit(address indexed nftContract, bytes32 indexed nftType);\n\n    /* *********** */\n    /* CONSTRUCTOR */\n    /* *********** */\n\n    /**\n     * @dev Sets `nftTypeRegistry`\n     * Initialize `nftPermits` with a batch of permitted NFTs\n     *\n     * @param _admin - Initial admin of this contract.\n     * @param _nftfiHub - Address of the NftfiHub contract\n     * @param _definedNftTypes - All the ossible nft types\n     * @param _definedNftWrappers - All the possible wrappers for the types\n     * @param _permittedNftContracts - The addresses of the NFT contracts.\n     * @param _permittedNftTypes - The NFT Types. e.g. \"CRYPTO_KITTIES\"\n     * - \"\" means \"disable this permit\"\n     * - != \"\" means \"enable permit with the given NFT Type\"\n     */\n    constructor(\n        address _admin,\n        address _nftfiHub,\n        string[] memory _definedNftTypes,\n        address[] memory _definedNftWrappers,\n        address[] memory _permittedNftContracts,\n        string[] memory _permittedNftTypes\n    ) Ownable(_admin) {\n        hub = INftfiHub(_nftfiHub);\n        _setNftTypes(_definedNftTypes, _definedNftWrappers);\n        _setNFTPermits(_permittedNftContracts, _permittedNftTypes);\n    }\n\n    /* ********* */\n    /* FUNCTIONS */\n    /* ********* */\n\n    /**\n     * @notice This function can be called by admins to change the permitted list status of an NFT contract. This\n     * includes both adding an NFT contract to the permitted list and removing it.\n     * `_nftContract` can not be zero address.\n     *\n     * @param _nftContract - The address of the NFT contract.\n     * @param _nftType - The NFT Type. e.g. \"CRYPTO_KITTIES\"\n     * - \"\" means \"disable this permit\"\n     * - != \"\" means \"enable permit with the given NFT Type\"\n     */\n    function setNFTPermit(address _nftContract, string memory _nftType) external override onlyOwner {\n        _setNFTPermit(_nftContract, _nftType);\n    }\n\n    /**\n     * @notice This function can be called by admins to change the permitted list status of a batch NFT contracts. This\n     * includes both adding an NFT contract to the permitted list and removing it.\n     * `_nftContract` can not be zero address.\n     *\n     * @param _nftContracts - The addresses of the NFT contracts.\n     * @param _nftTypes - The NFT Types. e.g. \"CRYPTO_KITTIES\"\n     * - \"\" means \"disable this permit\"\n     * - != \"\" means \"enable permit with the given NFT Type\"\n     */\n    function setNFTPermits(address[] memory _nftContracts, string[] memory _nftTypes) external onlyOwner {\n        _setNFTPermits(_nftContracts, _nftTypes);\n    }\n\n    /**\n     * @notice This function can be called by anyone to lookup the Nft Type associated with the contract.\n     * @param  _nftContract - The address of the NFT contract.\n     * @notice Returns the NFT Type:\n     * - bytes32(\"\") means \"not permitted\"\n     * - != bytes32(\"\") means \"permitted with the given NFT Type\"\n     */\n    function getNFTPermit(address _nftContract) external view override returns (bytes32) {\n        return nftPermits[_nftContract];\n    }\n\n    /**\n     * @notice This function can be called by anyone to lookup the address of the NftWrapper associated to the\n     * `_nftContract` type.\n     * @param _nftContract - The address of the NFT contract.\n     */\n    function getNFTWrapper(address _nftContract) external view override returns (address) {\n        bytes32 nftType = nftPermits[_nftContract];\n        return getNftTypeWrapper(nftType);\n    }\n\n    /**\n     * @notice Set or update the wrapper contract address for the given NFT Type.\n     * Set address(0) for a nft type for un-register such type.\n     *\n     * @param _nftType - The nft type, e.g. \"ERC721\", or \"ERC1155\".\n     * @param _nftWrapper - The address of the wrapper contract that implements INftWrapper behaviour for dealing with\n     * NFTs.\n     */\n    function setNftType(string memory _nftType, address _nftWrapper) external onlyOwner {\n        _setNftType(_nftType, _nftWrapper);\n    }\n\n    /**\n     * @notice Batch set or update the wrappers contract address for the given batch of NFT Types.\n     * Set address(0) for a nft type for un-register such type.\n     *\n     * @param _nftTypes - The nft types, e.g. \"ERC721\", or \"ERC1155\".\n     * @param _nftWrappers - The addresses of the wrapper contract that implements INftWrapper behaviour for dealing\n     * with NFTs.\n     */\n    function setNftTypes(string[] memory _nftTypes, address[] memory _nftWrappers) external onlyOwner {\n        _setNftTypes(_nftTypes, _nftWrappers);\n    }\n\n    /**\n     * @notice This function can be called by anyone to get the contract address that implements the given nft type.\n     *\n     * @param  _nftType - The nft type, e.g. bytes32(\"ERC721\"), or bytes32(\"ERC1155\").\n     */\n    function getNftTypeWrapper(bytes32 _nftType) public view returns (address) {\n        return nftTypes[_nftType];\n    }\n\n    /**\n     * @notice Set or update the wrapper contract address for the given NFT Type.\n     * Set address(0) for a nft type for un-register such type.\n     *\n     * @param _nftType - The nft type, e.g. \"ERC721\", or \"ERC1155\".\n     * @param _nftWrapper - The address of the wrapper contract that implements INftWrapper behaviour for dealing with\n     * NFTs.\n     */\n    function _setNftType(string memory _nftType, address _nftWrapper) internal {\n        // solhint-disable-next-line custom-errors\n        require(bytes(_nftType).length != 0, \"nftType is empty\");\n        bytes32 nftTypeKey = ContractKeys.getIdFromStringKey(_nftType);\n\n        nftTypes[nftTypeKey] = _nftWrapper;\n\n        emit TypeUpdated(nftTypeKey, _nftWrapper);\n    }\n\n    /**\n     * @notice Batch set or update the wrappers contract address for the given batch of NFT Types.\n     * Set address(0) for a nft type for un-register such type.\n     *\n     * @param _nftTypes - The nft types, e.g. keccak256(\"ERC721\"), or keccak256(\"ERC1155\").\n     * @param _nftWrappers - The addresses of the wrapper contract that implements INftWrapper behaviour for dealing\n     * with NFTs.\n     */\n    function _setNftTypes(string[] memory _nftTypes, address[] memory _nftWrappers) internal {\n        // solhint-disable-next-line custom-errors\n        require(_nftTypes.length == _nftWrappers.length, \"setNftTypes function information arity mismatch\");\n\n        for (uint256 i; i < _nftWrappers.length; ++i) {\n            _setNftType(_nftTypes[i], _nftWrappers[i]);\n        }\n    }\n\n    /**\n     * @notice This function changes the permitted list status of an NFT contract. This includes both adding an NFT\n     * contract to the permitted list and removing it.\n     * @param _nftContract - The address of the NFT contract.\n     * @param _nftType - The NFT Type. e.g. bytes32(\"CRYPTO_KITTIES\")\n     * - bytes32(\"\") means \"disable this permit\"\n     * - != bytes32(\"\") means \"enable permit with the given NFT Type\"\n     */\n    function _setNFTPermit(address _nftContract, string memory _nftType) internal {\n        // solhint-disable-next-line custom-errors\n        require(_nftContract != address(0), \"nftContract is zero address\");\n        bytes32 nftTypeKey = ContractKeys.getIdFromStringKey(_nftType);\n\n        if (nftTypeKey != 0) {\n            // solhint-disable-next-line custom-errors\n            require(getNftTypeWrapper(nftTypeKey) != address(0), \"NFT type not registered\");\n        }\n\n        nftPermits[_nftContract] = nftTypeKey;\n        emit NFTPermit(_nftContract, nftTypeKey);\n    }\n\n    /**\n     * @notice This function changes the permitted list status of a batch NFT contracts. This includes both adding an\n     * NFT contract to the permitted list and removing it.\n     * @param _nftContracts - The addresses of the NFT contracts.\n     * @param _nftTypes - The NFT Types. e.g. \"CRYPTO_KITTIES\"\n     * - \"\" means \"disable this permit\"\n     * - != \"\" means \"enable permit with the given NFT Type\"\n     */\n    function _setNFTPermits(address[] memory _nftContracts, string[] memory _nftTypes) internal {\n        // solhint-disable-next-line custom-errors\n        require(_nftContracts.length == _nftTypes.length, \"setNFTPermits function information arity mismatch\");\n\n        for (uint256 i; i < _nftContracts.length; ++i) {\n            _setNFTPermit(_nftContracts[i], _nftTypes[i]);\n        }\n    }\n}\n"
    },
    "contracts/permittedLists/PermittedPartners.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {IPermittedPartners} from \"../interfaces/IPermittedPartners.sol\";\n\nimport {Ownable} from \"../utils/Ownable.sol\";\n\n/**\n * @title  PermittedPartners\n * @author NFTfi\n * @dev Registry for partners permitted for reciving a revenue share.\n * Each partner's address is associated with the percent of the admin fee shared.\n */\ncontract PermittedPartners is Ownable, IPermittedPartners {\n    /* ******* */\n    /* STORAGE */\n    /* ******* */\n\n    uint256 public constant HUNDRED_PERCENT = 10000;\n\n    /**\n     * @notice A mapping from a partner's address to the percent of the admin fee shared with them. A zero indicates\n     * non-permitted.\n     */\n    mapping(address => uint16) private partnerRevenueShare;\n\n    /* ****** */\n    /* EVENTS */\n    /* ****** */\n\n    /**\n     * @notice This event is fired whenever the admin sets a partner's revenue share.\n     *\n     * @param partner - The address of the partner.\n     * @param revenueShareInBasisPoints - The percent (measured in basis points) of the admin fee amount that will be\n     * taken as a revenue share for a the partner.\n     */\n    event PartnerRevenueShare(address indexed partner, uint16 revenueShareInBasisPoints);\n\n    /* *********** */\n    /* CONSTRUCTOR */\n    /* *********** */\n\n    /**\n     * @notice Sets the admin of the contract.\n     *\n     * @param _admin - Initial admin of this contract.\n     */\n    constructor(address _admin) Ownable(_admin) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /* ********* */\n    /* FUNCTIONS */\n    /* ********* */\n\n    /**\n     * @notice This function can be called by admins to change the revenue share status of a partner. This includes\n     * adding an partner to the revenue share list, removing it and updating the revenue share percent.\n     *\n     * @param _partner - The address of the partner.\n     * @param _revenueShareInBasisPoints - The percent (measured in basis points) of the admin fee amount that will be\n     * taken as a revenue share for a the partner.\n     */\n    function setPartnerRevenueShare(address _partner, uint16 _revenueShareInBasisPoints) external onlyOwner {\n        // solhint-disable-next-line custom-errors\n        require(_partner != address(0), \"Partner is address zero\");\n        // solhint-disable-next-line custom-errors\n        require(_revenueShareInBasisPoints <= HUNDRED_PERCENT, \"Revenue share too big\");\n        partnerRevenueShare[_partner] = _revenueShareInBasisPoints;\n        emit PartnerRevenueShare(_partner, _revenueShareInBasisPoints);\n    }\n\n    /**\n     * @notice This function can be called by anyone to get the revenue share parcent associated with the partner.\n     *\n     * @param _partner - The address of the partner.\n     *\n     * @return Returns the partner's revenue share\n     */\n    function getPartnerPermit(address _partner) external view override returns (uint16) {\n        return partnerRevenueShare[_partner];\n    }\n}\n"
    },
    "contracts/refinancing/flashloan/aaveV3/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62: siloed borrowing enabled\n    //bit 63: flashloaning enabled\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}"
    },
    "contracts/refinancing/flashloan/aaveV3/IFlashLoanSimpleReceiver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from \"./IPoolAddressesProvider.sol\";\nimport {IPool} from \"./IPool.sol\";\n\n/**\n * @title IFlashLoanSimpleReceiver\n * @author Aave\n * @notice Defines the basic interface of a flashloan-receiver contract.\n * @dev Implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n */\ninterface IFlashLoanSimpleReceiver {\n  /**\n   * @notice Executes an operation after receiving the flash-borrowed asset\n   * @dev Ensure that the contract can return the debt + premium, e.g., has\n   *      enough funds to repay and has approved the Pool to pull the total amount\n   * @param asset The address of the flash-borrowed asset\n   * @param amount The amount of the flash-borrowed asset\n   * @param premium The fee of the flash-borrowed asset\n   * @param initiator The address of the flashloan initiator\n   * @param params The byte-encoded params passed when initiating the flashloan\n   * @return True if the execution of the operation succeeds, false otherwise\n   */\n  function executeOperation(\n    address asset,\n    uint256 amount,\n    uint256 premium,\n    address initiator,\n    bytes calldata params\n  ) external returns (bool);\n\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  function POOL() external view returns (IPool);\n}"
    },
    "contracts/refinancing/flashloan/aaveV3/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from \"./IPoolAddressesProvider.sol\";\nimport {DataTypes} from \"./DataTypes.sol\";\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(\n    address asset\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(\n    address user\n  ) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n}"
    },
    "contracts/refinancing/flashloan/aaveV3/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}"
    },
    "contracts/refinancing/flashloan/dydx/FlashloanDyDx.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\nimport {IFlashloanDyDx} from \"./IFlashloanDyDx.sol\";\nimport {ISoloMargin} from \"./ISoloMargin.sol\";\nimport {Refinancing} from \"../../Refinancing.sol\";\nimport {LoanData} from \"../../../loans/direct/loanTypes/LoanData.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\npragma solidity 0.8.19;\n\n/**\n * @title FlashloanDyDx\n * @author NFTfi\n * @dev This contract allows for executing flash loans using the dYdX lending protocol.\n * It handles the initiation of the flash loans.\n */\nabstract contract FlashloanDyDx is IFlashloanDyDx {\n    // The address of the SoloMargin contract for executing flash loans.\n    // solhint-disable-next-line immutable-vars-naming\n    ISoloMargin public immutable soloMargin;\n\n    // Mapping to keep track of tokens that can be flash loaned. (tokenAddress => isFlashloanble)\n    mapping(address => bool) public tokenFlashloanble;\n    // Mapping to keep track of market ids for each token. (tokenAddress => marketId)\n    mapping(address => uint256) public marketIds;\n\n    error callerNotFlashloanContract();\n    error flashloanInitiatorNotThisContract();\n\n    /**\n     * @dev Contract constructor that sets the SoloMargin contract and the flash loan fee.\n     * @param _soloMargin The address of the SoloMargin contract. (dYdX)\n     */\n    constructor(address _soloMargin) {\n        soloMargin = ISoloMargin(_soloMargin);\n        if (_soloMargin != address(0)) {\n            _loadTokens(_soloMargin);\n        }\n    }\n\n    /**\n     * @dev Loads tokens that can be flash loaned from the SoloMargin contract.\n     * It uses the private _loadTokens function to populate the tokenFlashloanble and marketIds mappings.\n     */\n    function loadTokens() public {\n        _loadTokens(address(soloMargin));\n    }\n\n    /**\n     * @dev Helper function that populates the tokenFlashloanble and marketIds mappings.\n     * @param _soloMargin The address of the SoloMargin contract.\n     */\n    function _loadTokens(address _soloMargin) private {\n        for (uint256 i; i <= 3; ++i) {\n            address tokenAddress = ISoloMargin(_soloMargin).getMarketTokenAddress(i);\n            tokenFlashloanble[tokenAddress] = true;\n            marketIds[tokenAddress] = i;\n        }\n    }\n\n    /**\n     * @dev Initiates a flash loan operation. Constructs an\n     * operations array containing Withdraw, Call, and Deposit actions.\n     * Then it approves the token transfer and calls the operate function on the soloMargin contract.\n     * @param _borrower The address of the borrower.\n     * @param _token The token to be flash loaned.\n     * @param _amount The amount to be flash loaned.\n     * @param _refinancingData Data related to the refinancing operation.\n     * @param _offer The loan offer details.\n     * @param _lenderSignature The lender's signature for the loan.\n     * @param _borrowerSettings The borrower's settings for the loan.\n     */\n    function _flashLoan(\n        address _borrower,\n        address _token,\n        uint256 _amount,\n        bool _swapping,\n        Refinancing.RefinancingData memory _refinancingData,\n        LoanData.Offer memory _offer,\n        LoanData.Signature memory _lenderSignature,\n        LoanData.BorrowerSettings memory _borrowerSettings\n    ) internal {\n        /*\n        The flash loan functionality in dydx is predicated by their \"operate\" function,\n        which takes a list of operations to execute, and defers validating the state of\n        things until it's done executing them.\n        \n        We thus create three operations, a Withdraw (which loans us the funds), a Call\n        (which invokes the callFunction method on this contract), and a Deposit (which\n        repays the loan, plus the 2 wei fee), and pass them all to \"operate\".\n        \n        Note that the Deposit operation will invoke the transferFrom to pay the loan \n        (or whatever amount it was initialised with) back to itself, there is no need\n        to pay it back explicitly.\n        \n        The loan must be given as an ERC-20 token, so WETH is used instead of ETH. Other\n        currencies (DAI, USDC) are also available, their index can be looked up by\n        calling getMarketTokenAddress on the solo margin contract, and set as the \n        primaryMarketId in the Withdraw and Deposit definitions.\n        */\n\n        uint256 primaryMarketId = marketIds[_token];\n\n        ActionArgs[] memory operations = new ActionArgs[](3);\n\n        operations[0] = ActionArgs({\n            actionType: ActionType.Withdraw,\n            accountId: 0,\n            amount: AssetAmount({\n                sign: false,\n                denomination: AssetDenomination.Wei,\n                ref: AssetReference.Delta,\n                value: _amount // Amount to borrow\n            }),\n            primaryMarketId: primaryMarketId,\n            secondaryMarketId: 0,\n            otherAddress: address(this),\n            otherAccountId: 0,\n            data: \"\"\n        });\n\n        operations[1] = ActionArgs({\n            actionType: ActionType.Call,\n            accountId: 0,\n            amount: AssetAmount({\n                sign: false,\n                denomination: AssetDenomination.Wei,\n                ref: AssetReference.Delta,\n                value: 0\n            }),\n            primaryMarketId: primaryMarketId,\n            secondaryMarketId: 0,\n            otherAddress: address(this),\n            otherAccountId: 0,\n            data: abi.encode(\n                _borrower,\n                _token,\n                _amount,\n                _swapping,\n                _refinancingData,\n                _offer,\n                _lenderSignature,\n                _borrowerSettings\n            )\n        });\n\n        operations[2] = ActionArgs({\n            actionType: ActionType.Deposit,\n            accountId: 0,\n            amount: AssetAmount({\n                sign: true,\n                denomination: AssetDenomination.Wei,\n                ref: AssetReference.Delta,\n                value: _amount + _getDydxFee()\n            }),\n            primaryMarketId: primaryMarketId,\n            secondaryMarketId: 0,\n            otherAddress: address(this),\n            otherAccountId: 0,\n            data: \"\"\n        });\n\n        IERC20(_token).approve(address(soloMargin), _amount + _getDydxFee());\n\n        AccountInfo[] memory accountInfos = new AccountInfo[](1);\n        accountInfos[0] = AccountInfo({owner: address(this), number: 1});\n\n        soloMargin.operate(accountInfos, operations);\n    }\n\n    /**\n     * @notice Function that's called back when flashloan is executed.\n     * Decodes the data returned by the flashloan, then calls the internal\n     * `_refinanceFlashloanCallback` function.\n     * DyDx flashloan interface expects this function to exist\n     *\n     * this function is only the entry point of the operations happening in the callback,\n     * it also serves to decode the callback data,\n     * the main logic is implemented in _refinanceFlashloanCallback()\n     *\n     * @param _data - Byte array of data returned by the flashloan\n     */\n    function callFunction(address sender, AccountInfo memory, bytes memory _data) external {\n        if (address(soloMargin) != msg.sender) revert callerNotFlashloanContract();\n        if (sender != address(this)) revert flashloanInitiatorNotThisContract();\n\n        (\n            address borrower,\n            address payOffToken,\n            uint256 payOffAmount,\n            bool swapping,\n            Refinancing.RefinancingData memory refinancingData,\n            LoanData.Offer memory offer,\n            LoanData.Signature memory lenderSignature,\n            LoanData.BorrowerSettings memory borrowerSettings\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    address,\n                    uint256,\n                    bool,\n                    Refinancing.RefinancingData,\n                    LoanData.Offer,\n                    LoanData.Signature,\n                    LoanData.BorrowerSettings\n                )\n            );\n\n        _refinanceFlashloanCallback(\n            borrower,\n            payOffToken,\n            payOffAmount,\n            swapping,\n            refinancingData,\n            offer,\n            lenderSignature,\n            borrowerSettings\n        );\n    }\n\n    /**\n     * @dev Callback function that executes the core logic of refinancing after obtaining a flashloan.\n     * This includes paying off the old loan, validating ownership of the collateral,\n     * and creating a new loan. The function handles token swaps if necessary and ensures\n     * the flashloan is paid off with the appropriate fees.\n     *\n     * @param _borrower Address of the borrower initiating the refinance.\n     * @param _payOffToken Address of the token used to pay off the old loan.\n     * @param _flashloanAmount Amount of the flashloan taken out for refinancing.\n     * @param _swapping Indicates whether token swapping is needed during the refinancing process.\n     * @param _refinancingData Struct containing data relevant to the refinancing operation.\n     * @param _offer Details of the new loan offer being initiated.\n     * @param _lenderSignature Signature of the lender of the new loan.\n     * @param _borrowerSettings Settings related to the borrower for the new loan.\n     */\n    function _refinanceFlashloanCallback(\n        address _borrower,\n        address _payOffToken,\n        uint256 _flashloanAmount,\n        bool _swapping,\n        Refinancing.RefinancingData memory _refinancingData,\n        LoanData.Offer memory _offer,\n        LoanData.Signature memory _lenderSignature,\n        LoanData.BorrowerSettings memory _borrowerSettings\n    ) internal virtual;\n\n    function _getDydxFee() internal virtual returns (uint256);\n}\n"
    },
    "contracts/refinancing/flashloan/dydx/IFlashloanDyDx.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\n/**\n * @title IFlashloanDyDx\n * @author NFTfi\n * @dev This is an interface for the Flashloan contract.\n * It includes the definitions for data types and function used in the flashloan operations.\n */\ninterface IFlashloanDyDx {\n    /**\n     * @dev Enum representing the denomination of an asset.\n     * Assets can be denominated in Wei or Par.\n     */\n    enum AssetDenomination {\n        Wei,\n        Par\n    }\n\n    /**\n     * @dev Enum representing the reference of an asset amount.\n     * Assets can be referenced by a delta (change in value) or target (final value).\n     */\n    enum AssetReference {\n        Delta,\n        Target\n    }\n\n    /**\n     * @dev Enum representing the type of action to be performed.\n     * This can be any one among several options including Deposit, Withdraw, Transfer, etc.\n     */\n    enum ActionType {\n        Deposit,\n        Withdraw,\n        Transfer,\n        Buy,\n        Sell,\n        Trade,\n        Liquidate,\n        Vaporize,\n        Call\n    }\n\n    /**\n     * @dev Struct representing an asset amount for an action.\n     * It includes information about the sign (positive/negative),\n     * denomination (Wei/Par), reference (Delta/Target), and the value.\n     */\n    struct AssetAmount {\n        bool sign;\n        AssetDenomination denomination;\n        AssetReference ref;\n        uint256 value;\n    }\n\n    /**\n     * @dev Struct representing an action.\n     * It includes information about the type of action, the accountId,\n     * the amount of the asset, market ids, address of the other party,\n     * the other account's id, and any additional data.\n     */\n    struct ActionArgs {\n        ActionType actionType;\n        uint256 accountId;\n        AssetAmount amount;\n        uint256 primaryMarketId;\n        uint256 secondaryMarketId;\n        address otherAddress;\n        uint256 otherAccountId;\n        bytes data;\n    }\n\n    /**\n     * @dev Struct representing the account information.\n     * It includes the owner's address and the account number.\n     */\n    struct AccountInfo {\n        address owner;\n        uint256 number;\n    }\n\n    /**\n     * @dev Function that is called after a flash loan operation.\n     * @param sender The address initiating the call.\n     * @param accountInfo Account related information.\n     * @param data The data passed in the call.\n     */\n    function callFunction(address sender, AccountInfo memory accountInfo, bytes memory data) external;\n}\n"
    },
    "contracts/refinancing/flashloan/dydx/ISoloMargin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {IFlashloanDyDx} from \"./IFlashloanDyDx.sol\";\n\n/**\n * @title ISoloMargin\n * @author NFTfi\n * @dev Interface for dYdX's SoloMargin contract.\n * It includes essential methods needed to interact with the SoloMargin contract.\n * These methods are used for initiating flash loans and getting token address of the market.\n */\ninterface ISoloMargin {\n    /**\n     * @dev Function to bundle multiple operations in a single transaction.\n     * The operations are executed atomically and the state is maintained to ensure protocol's solvency.\n     * @param accounts An array of AccountInfo objects, which contains the address and number of each account involved.\n     * @param actions An array of ActionArgs objects, representing the actions to be executed.\n     */\n    function operate(IFlashloanDyDx.AccountInfo[] memory accounts, IFlashloanDyDx.ActionArgs[] memory actions) external;\n\n    /**\n     * @dev Function to get the token address of the market based on the given marketId.\n     * @param marketId The ID of the market to get the token address for.\n     * @return Address of the token for the specified market.\n     */\n    function getMarketTokenAddress(uint256 marketId) external view returns (address);\n}\n"
    },
    "contracts/refinancing/Refinancing.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {INftfiHub} from \"../interfaces/INftfiHub.sol\";\nimport {LoanData} from \"../loans/direct/loanTypes/LoanData.sol\";\nimport {RefinancingAdapterRegistry} from \"./refinancingAdapters/RefinancingAdapterRegistry.sol\";\nimport {IRefinancingAdapter} from \"./refinancingAdapters/IRefinancingAdapter.sol\";\nimport {DirectLoanFixedOffer, ContractKeys} from \"../loans/direct/loanTypes/DirectLoanFixedOffer.sol\";\nimport {FlashloanDyDx} from \"./flashloan/dydx/FlashloanDyDx.sol\";\nimport {NftReceiver} from \"../utils/NftReceiver.sol\";\nimport {IDirectLoanCoordinator} from \"../interfaces/IDirectLoanCoordinator.sol\";\nimport {INftWrapper} from \"../interfaces/INftWrapper.sol\";\nimport {IPermittedNFTs} from \"../interfaces/IPermittedNFTs.sol\";\nimport {SwapFlashloanWETH} from \"./SwapFlashloanWETH.sol\";\n\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/**\n * @title  Refinancing\n * @author NFTfi\n * @notice\n */\n\n/**\n * @title Refinancing\n *\n * @dev This smart contract is designed to manage the process of loan refinancing.\n * It allows borrowers to replace their current loans with new ones that have more favorable terms.\n * Each loan is identified by a unique identifier and associated with a refinanceable contract,\n * enabling tracking and management of loan refinancing details.\n *\n * @author NFTfi\n */\ncontract Refinancing is\n    RefinancingAdapterRegistry,\n    FlashloanDyDx,\n    SwapFlashloanWETH,\n    NftReceiver,\n    Pausable,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n\n    // solhint-disable-next-line immutable-vars-naming\n    INftfiHub public immutable hub;\n    address public targetLoanContract;\n\n    uint256 public dydxFee;\n\n    /**\n     * @notice Struct to hold data necessary for a refinancing operation.\n     *\n     * @param loanIdentifier Numeric identifier of the loan to be refinanced.\n     * @param refinanceableContract Address of the contract that supports the refinancing.\n     */\n    struct RefinancingData {\n        uint256 loanIdentifier;\n        address refinanceableContract;\n    }\n\n    uint32 private latestRefinancedLoanId;\n\n    error callerNotBorrowerOfOldLoan();\n    error collateralNotOwned();\n    error denominationMismatch();\n    error unsupportedCollateral();\n\n    /**\n     * @notice Sets the admin of the contract.\n     * Initializes `contractTypes` with a batch of loan types. Sets `NftfiHub`.\n     * Initializes RefinancingAdapterRegistry and Flashloan contracts\n     *\n     * @param  _nftfiHub - Address of the NftfiHub contract\n     * @param _targetLoanContract - Address of the target loan contract\n     * @param _admin - Initial admin of this contract.\n     * @param _definedRefinanceableTypes - Array of defined refinancing types\n     * @param _refinancingAdapters - Array of addresses of the refinancing adapters\n     * @param _refinanceableTypes - Array of refinancing types\n     * @param _refinanceableContracts - Array of addresses of the refinancing contracts\n     * @param _soloMargin - Address of the solo margin contract for flashloans\n     * @param _dydxFee - Fee for using a flashloan\n     */\n    constructor(\n        address _nftfiHub,\n        address _targetLoanContract,\n        address _admin,\n        string[] memory _definedRefinanceableTypes,\n        address[] memory _refinancingAdapters,\n        string[] memory _refinanceableTypes,\n        address[] memory _refinanceableContracts,\n        address _soloMargin,\n        uint256 _dydxFee,\n        SwapConstructorParams memory _swapContructorParams\n    )\n        RefinancingAdapterRegistry(\n            _admin,\n            _definedRefinanceableTypes,\n            _refinancingAdapters,\n            _refinanceableTypes,\n            _refinanceableContracts\n        )\n        FlashloanDyDx(_soloMargin)\n        SwapFlashloanWETH(_swapContructorParams)\n    {\n        hub = INftfiHub(_nftfiHub);\n        targetLoanContract = _targetLoanContract;\n        dydxFee = _dydxFee;\n    }\n\n    /**\n     * @notice Main function for initiating the loan refinance process.\n     * Initiated by the borrower of the old refinancable if applicable and the new loan\n     * From the standpoint of the lender this whole process can just be a regular loan,\n     * the only caveat is that the collateral is locked in some refinancable protocol (loan, market).\n     * If the old refinancable is a loan, borrower role transfer has to be approved\n     * (eg erc-721 approve for obligation receipt) to this contract beforehand.\n     * Checks the terms of the refinancing offer, verifies the borrower of the old loan,\n     * pays off the old loan, creates a new loan offer and mints an Obligation Receipt Token.\n     *\n     * @param _refinancingData - Data related to the refinancing loan\n     * @param _offer - The loan offer details\n     * @param _lenderSignature - Signature of the lender\n     * @param _borrowerSettings - Settings related to the borrower\n     */\n    function refinance(\n        RefinancingData memory _refinancingData,\n        LoanData.Offer memory _offer,\n        LoanData.Signature memory _lenderSignature,\n        LoanData.BorrowerSettings memory _borrowerSettings\n    ) external whenNotPaused nonReentrant {\n        address refinancingAdapter = getRefinancingAdapter(_refinancingData.refinanceableContract);\n\n        address borrower = _getBorrowerAddress(\n            refinancingAdapter,\n            _refinancingData.refinanceableContract,\n            _refinancingData.loanIdentifier\n        );\n\n        if (borrower != address(0)) {\n            if (borrower != msg.sender) revert callerNotBorrowerOfOldLoan();\n        } else {\n            // in case of non loan refinancables, like opensea we dont need to check\n            borrower = msg.sender;\n        }\n\n        (address payOffToken, uint256 payOffAmount) = _getPayoffDetails(\n            refinancingAdapter,\n            _refinancingData.refinanceableContract,\n            _refinancingData.loanIdentifier\n        );\n\n        if (payOffToken != _offer.loanERC20Denomination) revert denominationMismatch();\n\n        // take over old loan\n        _transferBorrowerRole(\n            refinancingAdapter,\n            _refinancingData.refinanceableContract,\n            _refinancingData.loanIdentifier\n        );\n\n        // if we have to swap tokens, to get a flashloan (no flashloan fot wstETH)\n        (bool swapping, uint256 flashloanAmount) = _checkIfSwapNeededAndGetFlashloanParamters(\n            payOffToken,\n            payOffAmount\n        );\n\n        // take out flashloan\n        // this will call back to callFunction()\n        // inside callback:\n        //   - pay off old loan\n        //   - check collateral\n        //   - start new loan\n        _flashLoan(\n            borrower,\n            payOffToken,\n            flashloanAmount,\n            swapping,\n            _refinancingData,\n            _offer,\n            _lenderSignature,\n            _borrowerSettings\n        );\n        // pay off flashloan (happens impicitly with a tranferFrom)\n\n        uint256 refinancingSurplus = IERC20(payOffToken).balanceOf(address(this));\n        if (refinancingSurplus > 0) {\n            IERC20(payOffToken).safeTransfer(borrower, refinancingSurplus);\n        }\n\n        _mintAndSendNewLoanObligationReceipt(borrower);\n    }\n\n    /**\n     * @dev Callback function that executes the core logic of refinancing after obtaining a flashloan.\n     * This includes paying off the old loan, validating ownership of the collateral,\n     * and creating a new loan. The function handles token swaps if necessary and ensures\n     * the flashloan is paid off with the appropriate fees.\n     *\n     * @param _borrower Address of the borrower initiating the refinance.\n     * @param _payOffToken Address of the token used to pay off the old loan.\n     * @param _flashloanAmount Amount of the flashloan taken out for refinancing.\n     * @param _swapping Indicates whether token swapping is needed during the refinancing process.\n     * @param _refinancingData Struct containing data relevant to the refinancing operation.\n     * @param _offer Details of the new loan offer being initiated.\n     * @param _lenderSignature Signature of the lender of the new loan.\n     * @param _borrowerSettings Settings related to the borrower for the new loan.\n     */\n    function _refinanceFlashloanCallback(\n        address _borrower,\n        address _payOffToken,\n        uint256 _flashloanAmount,\n        bool _swapping,\n        RefinancingData memory _refinancingData,\n        LoanData.Offer memory _offer,\n        LoanData.Signature memory _lenderSignature,\n        LoanData.BorrowerSettings memory _borrowerSettings\n    ) internal override {\n        address refinancingAdapter = getRefinancingAdapter(_refinancingData.refinanceableContract);\n\n        (address payBackToken, uint256 payBackAmount) = _getPayoffDetails(\n            refinancingAdapter,\n            _refinancingData.refinanceableContract,\n            _refinancingData.loanIdentifier\n        );\n\n        if (_swapping) {\n            _swapFromWeth(_payOffToken, payBackAmount);\n        }\n\n        // pay off old loan\n        _payOffRefinancable(\n            refinancingAdapter,\n            _refinancingData.refinanceableContract,\n            _refinancingData.loanIdentifier,\n            payBackToken,\n            payBackAmount\n        );\n\n        // check collateral\n        (address collateralContract, uint256 collateralId) = _getCollateral(\n            refinancingAdapter,\n            _refinancingData.refinanceableContract,\n            _refinancingData.loanIdentifier\n        );\n\n        if (!_isNFTOwner(collateralContract, collateralId, address(this))) revert collateralNotOwned();\n\n        // check if we are in deficit and get it from the borrower in that case\n        _checkAndTransferDeficit(_borrower, _payOffToken, _flashloanAmount, _offer, _swapping);\n\n        //approve nft to target loan to create the new loan\n        _approveNFT(targetLoanContract, collateralContract, collateralId);\n\n        // start new loan\n        latestRefinancedLoanId = DirectLoanFixedOffer(targetLoanContract).acceptOffer(\n            _offer,\n            _lenderSignature,\n            _borrowerSettings\n        );\n\n        if (_swapping) {\n            _swapToWeth(_payOffToken, _flashloanAmount + dydxFee);\n            // we have to re-approve to soloMargin\n            IERC20(wethAddress).approve(address(soloMargin), _flashloanAmount + dydxFee);\n        }\n    }\n\n    /**\n     * @notice Checks if the flashloan payoff amount in the loan token is greater than the loan principal amount\n     *         and transfers the deficit from the borrower to the contract.\n     * @dev Used in the process of refinancing loans to handle the difference between the flashloan amount\n     *      and the actual loan payoff amount.\n     * @param _borrower Address of the borrower who needs to cover the deficit if any.\n     * @param _payOffToken Address of the token that is used to pay off the loan.\n     * @param _flashloanAmount The amount of tokens taken as a flashloan that needs to be covered.\n     * @param _offer The loan offer data containing the principal amount of the loan.\n     * @param _swapping A boolean indicating whether a swap operation is required.\n     */\n    function _checkAndTransferDeficit(\n        address _borrower,\n        address _payOffToken,\n        uint256 _flashloanAmount,\n        LoanData.Offer memory _offer,\n        bool _swapping\n    ) internal {\n        uint256 flashloanPayoffAmountInLoanToken = _calculateFlashloanPayoffAmountInLoanToken(\n            _payOffToken,\n            _flashloanAmount,\n            _swapping\n        );\n        if (flashloanPayoffAmountInLoanToken > _offer.loanPrincipalAmount) {\n            uint256 refinancingDeficit = (flashloanPayoffAmountInLoanToken) - _offer.loanPrincipalAmount;\n            IERC20(_payOffToken).safeTransferFrom(_borrower, address(this), refinancingDeficit);\n        }\n    }\n\n    /**\n     * @notice Calculates the flashloan payoff amount in the loan token.\n     * @dev Considers whether a token swap is necessary due to differing token types for repayment.\n     * @param _payOffToken Address of the token that is used to pay off the loan.\n     * @param _flashloanAmount The amount of the loan taken as a flashloan.\n     * @param _swapping A boolean indicating whether a token swap is needed.\n     * @return flashloanPayoffAmountInLoanToken The calculated amount that must be paid off in the loan token.\n     */\n    function _calculateFlashloanPayoffAmountInLoanToken(\n        address _payOffToken,\n        uint256 _flashloanAmount,\n        bool _swapping\n    ) internal returns (uint256 flashloanPayoffAmountInLoanToken) {\n        if (_swapping) {\n            flashloanPayoffAmountInLoanToken = getTokenAmountNeeded(_payOffToken, _flashloanAmount + dydxFee);\n        } else {\n            flashloanPayoffAmountInLoanToken = _flashloanAmount + dydxFee;\n        }\n    }\n\n    /**\n     * @notice Determines if a token swap is needed for the flashloan repayment and calculates the flashloan amount.\n     * @dev If the payoff token is not flashloanable, a swap to WETH is needed.\n     * @param _payOffToken Address of the token to be used for paying off the loan.\n     * @param _payOffAmount The amount needed to pay off the loan.\n     * @return swapping Boolean indicating if a token swap is required.\n     * @return flashloanAmount The amount required for the flashloan, considering any needed swap.\n     */\n    function _checkIfSwapNeededAndGetFlashloanParamters(\n        address _payOffToken,\n        uint256 _payOffAmount\n    ) internal returns (bool swapping, uint256 flashloanAmount) {\n        if (!tokenFlashloanble[_payOffToken]) {\n            swapping = true;\n            flashloanAmount = getWethAmountNeeded(_payOffToken, _payOffAmount); //swap fees included\n        } else {\n            swapping = false;\n            flashloanAmount = _payOffAmount;\n        }\n    }\n\n    /**\n     * @notice Mints a new loan obligation receipt NFT and sends it to the borrower.\n     * @dev The NFT represents the borrower's obligation after a loan has been refinanced.\n     * @param _borrower Address of the borrower to whom the obligation receipt NFT will be sent.\n     */\n    function _mintAndSendNewLoanObligationReceipt(address _borrower) internal {\n        DirectLoanFixedOffer(targetLoanContract).mintObligationReceipt(latestRefinancedLoanId);\n        DirectLoanFixedOffer directLoanFixedOffer = DirectLoanFixedOffer(targetLoanContract);\n        IDirectLoanCoordinator coordinator = IDirectLoanCoordinator(\n            directLoanFixedOffer.hub().getContract(directLoanFixedOffer.LOAN_COORDINATOR())\n        );\n        uint64 smartNftId = coordinator.getLoanData(latestRefinancedLoanId).smartNftId;\n        IERC721 obligationReceiptToken = IERC721(coordinator.obligationReceiptToken());\n        obligationReceiptToken.safeTransferFrom(address(this), _borrower, smartNftId);\n    }\n\n    /**\n     * @notice Transfers the role of borrower to a new borrower.\n     * (only applicable to loan type refinancables, not markets)\n     * This is a call to the adapter, which handles several types of refinancables trough an adapter\n     *\n     * @param _refinancingAdapter - Address of the refinancing adapter contract\n     * @param _refinanceableContract - Address of the refinanceable contract\n     * @param _loanIdentifier - Identifier of the loan\n     */\n    function _transferBorrowerRole(\n        address _refinancingAdapter,\n        address _refinanceableContract,\n        uint256 _loanIdentifier\n    ) private {\n        Address.functionDelegateCall(\n            _refinancingAdapter,\n            abi.encodeWithSelector(\n                IRefinancingAdapter(_refinancingAdapter).transferBorrowerRole.selector,\n                _refinanceableContract,\n                _loanIdentifier\n            ),\n            \"transferBorrowerRole error\"\n        );\n    }\n\n    /**\n     * @notice Pays back the refinancable\n     * This is a call to the adapter, which handles several types of refinancables trough an adapter\n     *\n     * @param _refinancingAdapter - Address of the refinancing adapter contract\n     * @param _refinanceableContract - Address of the refinanceable contract\n     * @param _loanIdentifier - Identifier of the loan\n     * @param _payBackToken - Address of the token used for paying back\n     * @param _payBackAmount - The amount required to pay back the loan\n     */\n    function _payOffRefinancable(\n        address _refinancingAdapter,\n        address _refinanceableContract,\n        uint256 _loanIdentifier,\n        address _payBackToken,\n        uint256 _payBackAmount\n    ) private {\n        Address.functionDelegateCall(\n            _refinancingAdapter,\n            abi.encodeWithSelector(\n                IRefinancingAdapter(_refinancingAdapter).payOffRefinancable.selector,\n                _refinanceableContract,\n                _loanIdentifier,\n                _payBackToken,\n                _payBackAmount\n            ),\n            \"payBackloan error\"\n        );\n    }\n\n    /**\n     * @notice Retrieves the borrower's address of a specific refinancable.\n     * (only applicable to loan type refinancables, not markets)\n     * This is a call to the adapter, which handles several types of refinancables trough an adapter\n     *\n     * @param _refinancingAdapter - Address of the refinancing adapter contract\n     * @param _refinanceableContract - Address of the refinanceable contract\n     * @param _loanIdentifier - Identifier of the loan\n     * @return Address of the borrower\n     */\n    function _getBorrowerAddress(\n        address _refinancingAdapter,\n        address _refinanceableContract,\n        uint256 _loanIdentifier\n    ) private returns (address) {\n        bytes memory returnData = Address.functionDelegateCall(\n            _refinancingAdapter,\n            abi.encodeWithSelector(\n                IRefinancingAdapter(_refinancingAdapter).getBorrowerAddress.selector,\n                _refinanceableContract,\n                _loanIdentifier\n            ),\n            \"getBorrowerAddress error\"\n        );\n\n        return abi.decode(returnData, (address));\n    }\n\n    /**\n     * @notice Retrieves the collateral details of a specific refinancable.\n     * This is a call to the adapter, which handles several types of refinancables trough an adapter\n     *\n     * @param _refinancingAdapter - Address of the refinancing adapter contract\n     * @param _refinanceableContract - Address of the refinanceable contract\n     * @param _loanIdentifier - Identifier of the loan\n     * @return Address of the collateral contract, Identifier of the collateral\n     */\n    function _getCollateral(\n        address _refinancingAdapter,\n        address _refinanceableContract,\n        uint256 _loanIdentifier\n    ) private returns (address, uint256) {\n        bytes memory returnData = Address.functionDelegateCall(\n            _refinancingAdapter,\n            abi.encodeWithSelector(\n                IRefinancingAdapter(_refinancingAdapter).getCollateral.selector,\n                _refinanceableContract,\n                _loanIdentifier\n            ),\n            \"getCollateral error\"\n        );\n\n        return abi.decode(returnData, (address, uint256));\n    }\n\n    /**\n     * @notice Retrieves the details related to the payoff of a specific refinancable, the payment token and amount\n     * This is a call to the adapter, which handles several types of refinancables trough an adapter\n     *\n     * @param _refinancingAdapter - Address of the refinancing adapter contract\n     * @param _refinanceableContract - Address of the refinanceable contract\n     * @param _loanIdentifier - Identifier of the loan\n     * @return Address of the payoff token, Amount required to pay off the loan\n     */\n    function _getPayoffDetails(\n        address _refinancingAdapter,\n        address _refinanceableContract,\n        uint256 _loanIdentifier\n    ) private returns (address, uint256) {\n        bytes memory returnData = Address.functionDelegateCall(\n            _refinancingAdapter,\n            abi.encodeWithSelector(\n                IRefinancingAdapter(_refinancingAdapter).getPayoffDetails.selector,\n                _refinanceableContract,\n                _loanIdentifier\n            ),\n            \"getPayoffDetails error\"\n        );\n\n        return abi.decode(returnData, (address, uint256));\n    }\n\n    /**\n     * @dev Checks if a specified address is the owner of an NFT trough the NFT adaptor.\n     *\n     * @param _nftCollateralContract - The contract address of the NFT.\n     * @param _nftCollateralId - The token ID of the NFT.\n     * @param _owner - The address to check ownership against.\n     *\n     * @return bool - Returns true if the specified address is the owner of the NFT.\n     */\n    function _isNFTOwner(\n        address _nftCollateralContract,\n        uint256 _nftCollateralId,\n        address _owner\n    ) internal returns (bool) {\n        address nftCollateralWrapper = _getWrapper(_nftCollateralContract);\n\n        bytes memory result = Address.functionDelegateCall(\n            nftCollateralWrapper,\n            abi.encodeWithSelector(\n                INftWrapper(nftCollateralWrapper).isOwner.selector,\n                _owner,\n                _nftCollateralContract,\n                _nftCollateralId\n            ),\n            \"NFT ownership check not successful\"\n        );\n\n        return abi.decode(result, (bool));\n    }\n\n    /**\n     * @dev Approves an NFT to be used by another address trough the NFT adaptor.\n     *\n     * @param _to - The address to approve to transfer or manage the NFT.\n     * @param _nftCollateralContract - The contract address of the NFT.\n     * @param _nftCollateralId - The token ID of the NFT.\n     *\n     * @return bool - Returns true if the approval was successful.\n     */\n    function _approveNFT(\n        address _to,\n        address _nftCollateralContract,\n        uint256 _nftCollateralId\n    ) internal returns (bool) {\n        address nftCollateralWrapper = _getWrapper(_nftCollateralContract);\n\n        bytes memory result = Address.functionDelegateCall(\n            nftCollateralWrapper,\n            abi.encodeWithSelector(\n                INftWrapper(nftCollateralWrapper).approveNFT.selector,\n                _to,\n                _nftCollateralContract,\n                _nftCollateralId\n            ),\n            \"NFT not successfully approved\"\n        );\n\n        return abi.decode(result, (bool));\n    }\n\n    /**\n     * @dev Checks that the collateral is a supported contracts and returns what wrapper to use for the loan's NFT\n     * collateral contract.\n     *\n     * @param _nftCollateralContract - The address of the the NFT collateral contract.\n     *\n     * @return Address of the NftWrapper to use for the loan's NFT collateral.\n     */\n    function _getWrapper(address _nftCollateralContract) internal view returns (address) {\n        return IPermittedNFTs(hub.getContract(ContractKeys.PERMITTED_NFTS)).getNFTWrapper(_nftCollateralContract);\n    }\n\n    /**\n     * @dev Checks that the collateral is a supported contracts and returns the collateral permit type\n     *\n     * @param _nftCollateralContract - The address of the the NFT collateral contract.\n     *\n     * @return Address of the NftWrapper to use for the loan's NFT collateral.\n     */\n    function _getPermit(address _nftCollateralContract) internal view returns (bytes32) {\n        return IPermittedNFTs(hub.getContract(ContractKeys.PERMITTED_NFTS)).getNFTPermit(_nftCollateralContract);\n    }\n\n    function _getDydxFee() internal view override returns (uint256) {\n        return dydxFee;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - Only the owner can call this method.\n     * - The contract must not be paused.\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - Only the owner can call this method.\n     * - The contract must be paused.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Sets the fee for flash loans.\n     * @param _dydxFee The fee percentage for flash loans.\n     */\n    function setDydxFee(uint256 _dydxFee) public onlyOwner {\n        dydxFee = _dydxFee;\n    }\n\n    /**\n     * @dev Sets the target loan contract address\n     * @param _targetLoanContract The address of the target loan contract.\n     */\n    function setTargetLoanContract(address _targetLoanContract) public onlyOwner {\n        targetLoanContract = _targetLoanContract;\n    }\n\n    /**\n     * @dev Sets the swap fee rates for multiple supported tokens in batch.\n     * @param _supportedTokens An array of addresses of the supported tokens.\n     * @param _swapFeeRates An array of corresponding swap fee rates for each supported token.\n     */\n    function setSupportedTokenSwapFeeRates(\n        address[] memory _supportedTokens,\n        uint24[] memory _swapFeeRates\n    ) external onlyOwner {\n        _setSupportedTokenFeeRates(_supportedTokens, _swapFeeRates);\n    }\n\n    /**\n     * @dev Sets the swap fee rate for a single supported token.\n     * @param _supportedToken The address of the supported token.\n     * @param _swapFeeRate The swap fee rate for the specified supported token.\n     */\n    function setSupportedTokenSwapFeeRate(address _supportedToken, uint24 _swapFeeRate) external onlyOwner {\n        _setSupportedTokenFeeRate(_supportedToken, _swapFeeRate);\n    }\n}\n"
    },
    "contracts/refinancing/refinancingAdapters/IRefinancingAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\n/**\n * @title IRefinancingAdapter\n * @author NFTfi\n *\n * @dev This is the interface for Refinancing Adapters. It provides several methods for managing and retrieving\n * information about contracts that are eligible for refinancing.\n *\n * Adapters should implement this interface\n */\ninterface IRefinancingAdapter {\n    /**\n     * @dev Returns the borrower's address for a specific refinancable\n     *\n     * @param _refinanceableContract Address of the contract containing the refinanceable\n     * @param _refinancableIdentifier Unique identifier for the refinanceable.\n     *\n     * @return Address of the borrower.\n     */\n    function getBorrowerAddress(\n        address _refinanceableContract,\n        uint256 _refinancableIdentifier\n    ) external returns (address);\n\n    /**\n     * @dev Transfers the role of borrower to refinancing contract for a specific refinanceable.\n     *\n     * @param _refinanceableContract Address of the contract containing the refinanceable\n     * @param _refinancableIdentifier Unique identifier for the loan.\n     *\n     * @return True if the operation was successful.\n     */\n    function transferBorrowerRole(\n        address _refinanceableContract,\n        uint256 _refinancableIdentifier\n    ) external returns (bool);\n\n    /**\n     * @dev Pays off a refinanceable with a specified amount of a specified token.\n     *\n     * @param _refinanceableContract Address of the contract containing the refinanceable\n     * @param _refinancableIdentifier Unique identifier for the refinanceable.\n     * @param _payBackToken Token used to pay back the refinanceable.\n     * @param _payBackAmount Amount of tokens used to pay back the refinanceable.\n     *\n     * @return True if the operation was successful.\n     */\n    function payOffRefinancable(\n        address _refinanceableContract,\n        uint256 _refinancableIdentifier,\n        address _payBackToken,\n        uint256 _payBackAmount\n    ) external returns (bool);\n\n    /**\n     * @dev Returns the collateral information for a specific refinancable.\n     *\n     * @param _refinanceableContract Address of the contract containing the refinanceable\n     * @param _refinancableIdentifier Unique identifier for the refinanceable.\n     *\n     * @return The address of the collateral token and the amount of collateral.\n     */\n    function getCollateral(\n        address _refinanceableContract,\n        uint256 _refinancableIdentifier\n    ) external view returns (address, uint256);\n\n    /**\n     * @dev Returns the payoff details for a specific refinancable.\n     *\n     * @param _refinanceableContract Address of the contract containing the refinanceable\n     * @param _refinancableIdentifier Unique identifier for the loan.\n     *\n     * @return The address of the payoff token and the required payoff amount.\n     */\n    function getPayoffDetails(\n        address _refinanceableContract,\n        uint256 _refinancableIdentifier\n    ) external view returns (address, uint256);\n}\n"
    },
    "contracts/refinancing/refinancingAdapters/NftfiRefinancingAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {IRefinancingAdapter} from \"./IRefinancingAdapter.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {\n    DirectLoanBaseMinimal,\n    IDirectLoanCoordinator,\n    IERC20\n} from \"../../loans/direct/loanTypes/DirectLoanBaseMinimal.sol\";\n\n/**\n * @title NftfiRefinancingAdapter\n * @author NFTfi\n * @dev This contract is an implementation of the IRefinancingAdapter for the NFTfi platform.\n * It handles operations related to refinancing NFTfi loans such as transferring the borrower role,\n * paying off loans, and retrieving loan and collateral details.\n */\ncontract NftfiRefinancingAdapter is IRefinancingAdapter {\n    error obligationReceiptDoesntExist();\n\n    /**\n     * @dev Gets the address of the borrower for a specific NFTfi loan.\n     * @param _loanContract The address of the contract containing the NFTfi loan.\n     * @param _loanIdentifier The unique identifier for the NFTfi loan.\n     * @return The address of the borrower.\n     */\n    function getBorrowerAddress(\n        address _loanContract,\n        uint256 _loanIdentifier\n    ) external view override returns (address) {\n        IDirectLoanCoordinator coordinator = _getCoordinator(_loanContract);\n        uint64 smartNftId = coordinator.getLoanData(uint32(_loanIdentifier)).smartNftId;\n        IERC721 obligationReceiptToken = IERC721(coordinator.obligationReceiptToken());\n        return obligationReceiptToken.ownerOf(smartNftId);\n    }\n\n    /**\n     * @dev Transfers the borrower role to this contract for a specific NFTfi loan.\n     * @param _loanContract The address of the contract containing the NFTfi loan.\n     * @param _loanIdentifier The unique identifier for the NFTfi loan.\n     * @return A boolean value indicating whether the operation was successful.\n     */\n    function transferBorrowerRole(address _loanContract, uint256 _loanIdentifier) external override returns (bool) {\n        IDirectLoanCoordinator coordinator = _getCoordinator(_loanContract);\n        uint64 smartNftId = coordinator.getLoanData(uint32(_loanIdentifier)).smartNftId;\n        IERC721 obligationReceiptToken = IERC721(coordinator.obligationReceiptToken());\n        address borrower = obligationReceiptToken.ownerOf(smartNftId);\n        if (borrower == address(0)) revert obligationReceiptDoesntExist();\n        obligationReceiptToken.transferFrom(borrower, address(this), smartNftId);\n        return (true);\n    }\n\n    /**\n     * @dev Pays off an NFTfi loan with a specified amount of a specified token.\n     * @param _loanContract The address of the contract containing the NFTfi loan.\n     * @param _loanIdentifier The unique identifier for the NFTfi loan.\n     * @param _payBackToken The token used to pay back the NFTfi loan.\n     * @param _payBackAmount The amount of tokens used to pay back the NFTfi loan.\n     * @return A boolean value indicating whether the operation was successful.\n     */\n    function payOffRefinancable(\n        address _loanContract,\n        uint256 _loanIdentifier,\n        address _payBackToken,\n        uint256 _payBackAmount\n    ) external override returns (bool) {\n        IERC20(_payBackToken).approve(_loanContract, _payBackAmount);\n        DirectLoanBaseMinimal(_loanContract).payBackLoan(uint32(_loanIdentifier));\n        return (true);\n    }\n\n    /**\n     * @dev Gets the collateral information for a specific NFTfi loan.\n     * @param _loanContract The address of the contract containing the NFTfi loan.\n     * @param _loanIdentifier The unique identifier for the NFTfi loan.\n     * @return nftCollateralContract nftCollateralId\n     * The address of the collateral token contract and the ID of the collateral.\n     */\n    function getCollateral(\n        address _loanContract,\n        uint256 _loanIdentifier\n    ) external view override returns (address nftCollateralContract, uint256 nftCollateralId) {\n        // struct LoanTerms {\n        //     uint256 loanPrincipalAmount;\n        //     uint256 maximumRepaymentAmount;\n        //     uint256 nftCollateralId;\n        //     address loanERC20Denomination;\n        //     uint32 loanDuration;\n        //     uint16 loanInterestRateForDurationInBasisPoints;\n        //     uint16 loanAdminFeeInBasisPoints;\n        //     address nftCollateralWrapper;\n        //     uint64 loanStartTime;\n        //     address nftCollateralContract;\n        //     address borrower;\n        // }\n\n        (, , nftCollateralId, , , , , , , nftCollateralContract, ) = DirectLoanBaseMinimal(_loanContract).loanIdToLoan(\n            uint32(_loanIdentifier)\n        );\n    }\n\n    /**\n     * @dev Retrieves the loan coordinator from a specific NFTfi loan contract.\n     * @param _loanContract The address of the contract containing the NFTfi loan.\n     * @return  The loan coordinator contract.\n     */\n\n    /**\n     * @dev Gets the collateral information for a specific NFTfi loan.\n     * @param _loanContract The address of the contract containing the NFTfi loan.\n     * @param _loanIdentifier The unique identifier for the NFTfi loan.\n     * @return loanERC20Denomination maximumRepaymentAmount\n     *  The address of the payoff token and the required payoff amount.\n     */\n    function getPayoffDetails(\n        address _loanContract,\n        uint256 _loanIdentifier\n    ) external view override returns (address loanERC20Denomination, uint256 maximumRepaymentAmount) {\n        // struct LoanTerms {\n        //     uint256 loanPrincipalAmount;\n        //     uint256 maximumRepaymentAmount;\n        //     uint256 nftCollateralId;\n        //     address loanERC20Denomination;\n        //     uint32 loanDuration;\n        //     uint16 loanInterestRateForDurationInBasisPoints;\n        //     uint16 loanAdminFeeInBasisPoints;\n        //     address nftCollateralWrapper;\n        //     uint64 loanStartTime;\n        //     address nftCollateralContract;\n        //     address borrower;\n        // }\n        (, maximumRepaymentAmount, , loanERC20Denomination, , , , , , , ) = DirectLoanBaseMinimal(_loanContract)\n            .loanIdToLoan(uint32(_loanIdentifier));\n    }\n\n    /**\n     * @dev Retrieves the loan coordinator from a specific NFTfi loan contract.\n     * @param _loanContract The address of the contract containing the NFTfi loan.\n     * @return The loan coordinator contract.\n     */\n    function _getCoordinator(address _loanContract) private view returns (IDirectLoanCoordinator) {\n        DirectLoanBaseMinimal directLoan = DirectLoanBaseMinimal(_loanContract);\n        return IDirectLoanCoordinator(directLoan.hub().getContract(directLoan.LOAN_COORDINATOR()));\n    }\n}\n"
    },
    "contracts/refinancing/refinancingAdapters/RefinancingAdapterRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {Ownable} from \"../../utils/Ownable.sol\";\nimport {ContractKeys} from \"../../utils/ContractKeys.sol\";\n\n/**\n * @title  PermittedNFTsAndTypeRegistry\n * @author NFTfi\n * @dev Registry for refinanceable contracts supported by NFTfi.\n * Each refinanceable contract is associated with a refinanceableType.\n */\ncontract RefinancingAdapterRegistry is Ownable {\n    mapping(bytes32 => address) private refinanceableTypes;\n    mapping(address => bytes32) private refinanceableContracts;\n\n    /* ****** */\n    /* EVENTS */\n    /* ****** */\n\n    /**\n     * @notice This event is fired whenever the admins register a refinancing type.\n     *\n     * @param refinanceableType - refinanceable type e.g. bytes32(\"DIRECT_LOAN_FIXED_OFFER\")\n     * @param refinancingAdapter - Address of the refinancing adapter contract.\n     */\n    event TypeUpdated(bytes32 indexed refinanceableType, address indexed refinancingAdapter);\n\n    /**\n     * @notice This event is fired whenever the admin sets a new refinanceable contract\n     *\n     * @param refinanceableContract - Address of the refinanceable contract.\n     * @param refinanceableType - refinanceable type e.g. bytes32(\"DIRECT_LOAN_FIXED_OFFER\")\n     */\n    event NewRefinanceableContract(address indexed refinanceableContract, bytes32 indexed refinanceableType);\n\n    /* *********** */\n    /* CONSTRUCTOR */\n    /* *********** */\n\n    /**\n     * @dev Initialize `refinanceableTypes` with a batch of permitted refinancing types.\n     *\n     * @param _admin - Initial admin of this contract.\n     */\n    /*\n     * @param _definedRefinanceableTypes - Array of defined refinancing types.\n     * @param _refinancingAdapters - Array of refinancing adapter contracts.\n     * @param _refinanceableTypes - Array of refinancing types  e.g. \"DIRECT_LOAN_FIXED_OFFER\"\n     * @param _refinanceableContracts - Array of refinanceable contract addresses.\n     * - \"\" means \"disable this permit\"\n     * - != \"\" means \"enable permit with the given Refinanceable Type\"\n     */\n    constructor(\n        address _admin,\n        string[] memory _definedRefinanceableTypes,\n        address[] memory _refinancingAdapters,\n        string[] memory _refinanceableTypes,\n        address[] memory _refinanceableContracts\n    ) Ownable(_admin) {\n        _setRefinanceableTypes(_definedRefinanceableTypes, _refinancingAdapters);\n        _setRefinanceableContracts(_refinanceableContracts, _refinanceableTypes);\n    }\n\n    /* ********* */\n    /* FUNCTIONS */\n    /* ********* */\n\n    /**\n     * @notice Changes the status of a refinanceable contract.\n     * This includes both adding a refinanceable contract to the permitted list and removing it.\n     *\n     * @param _refinanceableContract - Address of the refinanceable contract.\n     * @param _refinanceableType - Refinanceable type, e.g., \"DIRECT_LOAN_FIXED_OFFER\".\n     * - \"\" means \"disable this permit\"\n     * - != \"\" means \"enable permit with the given NFT Type\"\n     */\n    function setRefinanceableContract(\n        address _refinanceableContract,\n        string memory _refinanceableType\n    ) external onlyOwner {\n        _setRefinanceableContract(_refinanceableContract, _refinanceableType);\n    }\n\n    /**\n     * @notice Changes the status of a batch of refinanceable contracts.\n     * This includes both adding refinanceable contracts to the permitted list and removing them.\n     *\n     * @param _refinanceableContracts - Array of refinanceable contract addresses.\n     * @param _refinanceableTypes - Array of refinanceable types associated with the refinanceable contracts.\n     * - \"\" means \"disable this permit\"\n     * - != \"\" means \"enable permit with the given NFT Type\"\n     */\n    function setRefinanceableContracts(\n        address[] memory _refinanceableContracts,\n        string[] memory _refinanceableTypes\n    ) external onlyOwner {\n        _setRefinanceableContracts(_refinanceableContracts, _refinanceableTypes);\n    }\n\n    /**\n     * @notice Looks up the refinanceable type associated with a refinanceable contract.\n     *\n     * @param _refinanceableContract - Address of the refinanceable contract.\n     * @return The refinanceable type:\n     * - bytes32(\"\") means \"not registered\"\n     * - != bytes32(\"\") means \"permitted with the given refinanceable type\"\n     */\n    function getRefinanceableContract(address _refinanceableContract) external view returns (bytes32) {\n        return refinanceableContracts[_refinanceableContract];\n    }\n\n    /**\n     * @notice Looks up the address of the refinanceable adapter associated with the refinanceable contract type.\n     *\n     * @param _refinanceableContract - Address of the refinanceable contract.\n     * @return The address of the refinanceable adapter contract.\n     */\n    function getRefinancingAdapter(address _refinanceableContract) public view returns (address) {\n        bytes32 refinanceableType = refinanceableContracts[_refinanceableContract];\n        return getRefinancingAdapterOfType(refinanceableType);\n    }\n\n    /**\n     * @notice Sets or updates the address of the refinanceable adapter contract for the given refinanceable type.\n     * Set address(0) for a refinanceable type to unregister it.\n     *\n     * @param _refinanceableType - Refinanceable type, e.g., \"DIRECT_LOAN_FIXED_OFFER\"\n     * @param _refinancingAdapter - Address of the refinancing adapter contract that implements the refinanceable\n     * behavior for dealing with the correct refinanceable type\n     */\n    function setRefinanceableType(string memory _refinanceableType, address _refinancingAdapter) external onlyOwner {\n        _setRefinanceableType(_refinanceableType, _refinancingAdapter);\n    }\n\n    /**\n     * @notice Sets or updates the addresses of the refinanceable adapter\n     * contracts for the given batch of refinanceable types.\n     * Set address(0) for a refinanceable type to unregister it.\n     *\n     * @param _refinanceableTypes - Array of refinanceable types, e.g., \"DIRECT_LOAN_FIXED_OFFER\"\n     * @param _refinancingAdapters - Array of addresses of the refinancing adapter contracts that implement\n     * the refinanceable behavior for dealing with the correct refinanceable type\n     */\n    function setRefinanceableTypes(\n        string[] memory _refinanceableTypes,\n        address[] memory _refinancingAdapters\n    ) external onlyOwner {\n        _setRefinanceableTypes(_refinanceableTypes, _refinancingAdapters);\n    }\n\n    /**\n     * @notice Gets the address of the refinancing adapter contract that implements the given refinanceable type.\n     *\n     * @param  _refinanceableType - Refinanceable type, e.g., bytes32(\"DIRECT_LOAN_FIXED_OFFER\")\n     * @return The address of the refinancing adapter contract.\n     */\n    function getRefinancingAdapterOfType(bytes32 _refinanceableType) public view returns (address) {\n        return refinanceableTypes[_refinanceableType];\n    }\n\n    /**\n     * @notice Sets or updates the address of the refinancing adapter contract for the given refinanceable type.\n     * Set address(0) to unregister a refinanceable type.\n     *\n     * @param _refinanceableType - Refinanceable type, e.g., \"DIRECT_LOAN_FIXED_OFFER\"\n     * @param _refinancingAdapter - Address of the refinancing adapter contract that implements the\n     * refinanceable behavior for dealing with the correct refinanceable type\n     */\n\n    function _setRefinanceableType(string memory _refinanceableType, address _refinancingAdapter) internal {\n        // solhint-disable-next-line custom-errors\n        require(bytes(_refinanceableType).length != 0, \"refinanceableType is empty\");\n        bytes32 refinanceableTypeKey = ContractKeys.getIdFromStringKey(_refinanceableType);\n\n        refinanceableTypes[refinanceableTypeKey] = _refinancingAdapter;\n\n        emit TypeUpdated(refinanceableTypeKey, _refinancingAdapter);\n    }\n\n    /**\n     * @notice Batch sets or updates the addresses of the refinancing adapter\n     * contracts for the given batch of refinanceable types.\n     * Set address(0) to unregister a refinanceable type.\n     *\n     * @param _refinanceableTypes - Array of refinanceable types, e.g., \"DIRECT_LOAN_FIXED_OFFER\"\n     * @param _refinancingAdapters - Array of addresses of the refinancing adapter contracts that implement the\n     * refinanceable behavior for dealing with the correct refinanceable type\n     */\n    function _setRefinanceableTypes(\n        string[] memory _refinanceableTypes,\n        address[] memory _refinancingAdapters\n    ) internal {\n        // solhint-disable-next-line custom-errors\n        require(\n            _refinanceableTypes.length == _refinancingAdapters.length,\n            \"setRefinanceableTypes function information arity mismatch\"\n        );\n\n        for (uint256 i; i < _refinancingAdapters.length; ++i) {\n            _setRefinanceableType(_refinanceableTypes[i], _refinancingAdapters[i]);\n        }\n    }\n\n    /**\n     * @notice Changes the registered status of a refinanceable contract.\n     * This includes both adding a refinanceable contract to the registered list and removing it.\n     *\n     * @param _refinanceableContract - Address of the refinanceable contract.\n     * @param _refinanceableType - Refinanceable type, e.g., \"DIRECT_LOAN_FIXED_OFFER\".\n     * - bytes32(\"\") means \"disable this permit\"\n     * - != bytes32(\"\") means \"enable permit with the given NFT Type\"\n     */\n    function _setRefinanceableContract(address _refinanceableContract, string memory _refinanceableType) internal {\n        // solhint-disable-next-line custom-errors\n        require(_refinanceableContract != address(0), \"refinanceableContract is zero address\");\n        bytes32 refinanceableTypeKey = ContractKeys.getIdFromStringKey(_refinanceableType);\n\n        if (refinanceableTypeKey != 0) {\n            // solhint-disable-next-line custom-errors\n            require(\n                getRefinancingAdapterOfType(refinanceableTypeKey) != address(0),\n                \"refinanceable type not registered\"\n            );\n        }\n\n        refinanceableContracts[_refinanceableContract] = refinanceableTypeKey;\n        emit NewRefinanceableContract(_refinanceableContract, refinanceableTypeKey);\n    }\n\n    /**\n     * @notice Changes the registered status of multiple refinanceable contracts.\n     * This function can only be called by the contract owner.\n     * It includes both adding refinanceable contracts to the registered list and removing them.\n     *\n     * @param _refinanceableContracts - Array of refinanceable contract addresses.\n     * @param _refinanceableTypes - Array of refinanceable types associated with\n     * the refinanceable contracts, e.g., \"DIRECT_LOAN_FIXED_OFFER\".\n     * - \"\" means \"disable this permit\"\n     * - != \"\" means \"enable permit with the given NFT Type\"\n     */\n    function _setRefinanceableContracts(\n        address[] memory _refinanceableContracts,\n        string[] memory _refinanceableTypes\n    ) internal {\n        // solhint-disable-next-line custom-errors\n        require(\n            _refinanceableContracts.length == _refinanceableTypes.length,\n            \"setRefinanceableContracts function information arity mismatch\"\n        );\n\n        for (uint256 i; i < _refinanceableContracts.length; ++i) {\n            _setRefinanceableContract(_refinanceableContracts[i], _refinanceableTypes[i]);\n        }\n    }\n}\n"
    },
    "contracts/refinancing/SwapFlashloanWETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {ISwapRouter} from \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport {IQuoter} from \"@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract SwapFlashloanWETH {\n    // solhint-disable-next-line immutable-vars-naming\n    address public immutable swapRouterAddress;\n    // solhint-disable-next-line immutable-vars-naming\n    address public immutable quoterAddress;\n    // solhint-disable-next-line immutable-vars-naming\n    address public immutable wethAddress;\n\n    /**\n     * @dev stores the fee rates for tokens supported by this contract.\n     * The keys are token addresses, and the values are the associated fee rates.\n     */\n    mapping(address => uint24) public supportedTokenFeeRates;\n\n    error tokensFeeRatesArityMismatch();\n\n    /**\n     * @dev A struct to hold constructor parameters for the SwapFlashloanWETH contract.\n     * (there were too many parameters in the Refinancing constructor)\n     *\n     * @param swapRouterAddress The address of the Uniswap V3 swap router.\n     * @param quoterAddress The address of the Uniswap V3 quoter to estimate trade amounts.\n     * @param wethAddress The address of the WETH token contract.\n     * @param supportedTokens An array of token addresses that are supported for swaps.\n     * @param swapFeeRates An array of fee rates corresponding to the supported tokens.\n     */\n    struct SwapConstructorParams {\n        address swapRouterAddress;\n        address quoterAddress;\n        address wethAddress;\n        address[] supportedTokens;\n        uint24[] swapFeeRates;\n    }\n\n    /**\n     * @dev Creates an instance of the SwapFlashloanWETH contract.\n     *\n     * @param _params A `SwapConstructorParams` struct containing:\n     *                - swapRouterAddress: The address of the Uniswap V3 swap router.\n     *                - quoterAddress: The address of the Uniswap V3 quoter for trade estimations.\n     *                - wethAddress: The address of the WETH token contract.\n     *                - supportedTokens: An array of supported token addresses for swapping.\n     *                - swapFeeRates: An array of fee rates corresponding to each supported token.\n     *\n     * Requirements:\n     *\n     * - Each supported token address in `_params.supportedTokens` must have a corresponding\n     *   fee rate in `_params.swapFeeRates`.\n     */\n    constructor(SwapConstructorParams memory _params) {\n        swapRouterAddress = _params.swapRouterAddress;\n        quoterAddress = _params.quoterAddress;\n        wethAddress = _params.wethAddress;\n        _setSupportedTokenFeeRates(_params.supportedTokens, _params.swapFeeRates);\n    }\n\n    /**\n     * @dev Sets the fee rates for supported tokens in a single transaction.\n     *\n     * @param _supportedTokens An array of supported token addresses.\n     * @param _swapFeeRates An array of corresponding swap fee rates.\n     *\n     * Requirements:\n     *\n     * - The length of the `_supportedTokens` array must be equal to the length of the `_swapFeeRates` array.\n     */\n    function _setSupportedTokenFeeRates(address[] memory _supportedTokens, uint24[] memory _swapFeeRates) internal {\n        if (_supportedTokens.length != _swapFeeRates.length) revert tokensFeeRatesArityMismatch();\n\n        for (uint256 i; i < _supportedTokens.length; ++i) {\n            _setSupportedTokenFeeRate(_supportedTokens[i], _swapFeeRates[i]);\n        }\n    }\n\n    /**\n     * @dev Sets the fee rate for a single supported token.\n     *\n     * @param _supportedToken The address of the supported token.\n     * @param _swapFeeRate The swap fee rate for the token.\n     */\n    function _setSupportedTokenFeeRate(address _supportedToken, uint24 _swapFeeRate) internal {\n        supportedTokenFeeRates[_supportedToken] = _swapFeeRate;\n    }\n\n    /**\n     * @dev Retrieves the swap fee rate for a given token.\n     *\n     * @param _token The address of the token to query the fee rate for.\n     * @return uint24 The fee rate for swaps involving the specified token.\n     */\n    function getSwapFeeRate(address _token) public view returns (uint24) {\n        return supportedTokenFeeRates[_token];\n    }\n\n    /**\n     * @dev Estimates the amount of WETH needed to receive a specific amount of a given token.\n     *\n     * @param _tokenOut The address of the token to receive.\n     * @param _amountOut The desired amount of the token to receive.\n     * @return uint256 The estimated amount of WETH required.\n     */\n    function getWethAmountNeeded(address _tokenOut, uint256 _amountOut) public returns (uint256) {\n        return\n            IQuoter(quoterAddress).quoteExactOutputSingle(\n                wethAddress,\n                _tokenOut,\n                getSwapFeeRate(_tokenOut),\n                _amountOut,\n                uint160(0) // sqrtPriceLimitX96\n            );\n    }\n\n    /**\n     * @dev Estimates the amount of a token needed to receive a specific amount of WETH.\n     *\n     * @param _tokenIn The address of the token to provide.\n     * @param _amountOut The desired amount of WETH to receive.\n     * @return uint256 The estimated amount of the input token required.\n     */\n    function getTokenAmountNeeded(address _tokenIn, uint256 _amountOut) public returns (uint256) {\n        return\n            IQuoter(quoterAddress).quoteExactOutputSingle(\n                _tokenIn,\n                wethAddress,\n                getSwapFeeRate(_tokenIn),\n                _amountOut,\n                uint160(0) // sqrtPriceLimitX96\n            );\n    }\n\n    /**\n     * @dev Internal function to swap a token for WETH (Wrapped Ether) using the Uniswap V3 router.\n     *\n     * This function will attempt to swap the entirety of this contract's balance of the input token\n     * for the specified amount of WETH, at the fee rate applicable to the input token. If the swap\n     * cannot be completed, it will revert.\n     *\n     * @param _tokenIn The address of the token to be swapped for WETH.\n     * @param _amountOutWeth The desired amount of WETH to receive from the swap.\n     *\n     * Requirements:\n     *\n     * - The contract must have a balance of at least `_amountOutWeth` of the token at `_tokenIn`.\n     * - The contract must have approval to spend the input token on the Uniswap V3 router.\n     */\n    function _swapToWeth(address _tokenIn, uint256 _amountOutWeth) internal {\n        uint256 balance = IERC20(_tokenIn).balanceOf(address(this));\n        IERC20(_tokenIn).approve(swapRouterAddress, balance);\n\n        ISwapRouter(swapRouterAddress).exactOutputSingle(\n            ISwapRouter.ExactOutputSingleParams({\n                tokenIn: _tokenIn,\n                tokenOut: wethAddress,\n                fee: getSwapFeeRate(_tokenIn),\n                recipient: address(this),\n                deadline: block.timestamp + 15, // TODO double check\n                amountOut: _amountOutWeth,\n                amountInMaximum: balance,\n                sqrtPriceLimitX96: uint160(0)\n            })\n        );\n    }\n\n    /**\n     * @dev Internal function to swap WETH (Wrapped Ether) for another token using the Uniswap V3 router.\n     *\n     * This function will attempt to swap the entirety of this contract's balance of WETH\n     * for the specified amount of the output token, at the fee rate applicable to the output token.\n     * If the swap cannot be completed, it will revert.\n     *\n     * @param _tokenOut The address of the token to receive from the swap.\n     * @param _amountOutToken The desired amount of the output token to receive from the swap.\n     *\n     * Requirements:\n     *\n     * - The contract must have a balance of at least `_amountOutToken` worth of WETH.\n     * - The contract must have approval to spend WETH on the Uniswap V3 router.\n     */\n    function _swapFromWeth(address _tokenOut, uint256 _amountOutToken) internal {\n        uint256 balance = IERC20(wethAddress).balanceOf(address(this));\n        IERC20(wethAddress).approve(swapRouterAddress, balance);\n\n        ISwapRouter(swapRouterAddress).exactOutputSingle(\n            ISwapRouter.ExactOutputSingleParams({\n                tokenIn: wethAddress,\n                tokenOut: _tokenOut,\n                fee: getSwapFeeRate(_tokenOut),\n                recipient: address(this),\n                deadline: block.timestamp + 15, // TODO double check\n                amountOut: _amountOutToken,\n                amountInMaximum: balance,\n                sqrtPriceLimitX96: uint160(0)\n            })\n        );\n    }\n}\n"
    },
    "contracts/smartNft/SmartNft.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport {INftfiHub} from \"../interfaces/INftfiHub.sol\";\n\n/**\n * @title SmartNft\n * @author NFTfi\n * @dev An ERC721 token which represents a very basic implementation of the NFTfi V2 SmartNFT.\n */\ncontract SmartNft is ERC721, AccessControl {\n    using Address for address;\n    using Strings for uint256;\n\n    /**\n     * @dev This struct contains data needed to find the loan linked to a SmartNft.\n     */\n    struct Loan {\n        address loanCoordinator;\n        uint256 loanId;\n    }\n\n    /* ******* */\n    /* STORAGE */\n    /* ******* */\n\n    bytes32 public constant LOAN_COORDINATOR_ROLE = keccak256(\"LOAN_COORDINATOR_ROLE\");\n    bytes32 public constant BASE_URI_ROLE = keccak256(\"BASE_URI_ROLE\");\n\n    // solhint-disable-next-line immutable-vars-naming\n    INftfiHub public immutable hub;\n\n    // smartNftId => Loan\n    mapping(uint256 => Loan) public loans;\n\n    string public baseURI;\n\n    /**\n     * @dev Grants the contract the default admin role to `_admin`.\n     * Grants LOAN_COORDINATOR_ROLE to `_loanCoordinator`.\n     *\n     * @param _admin - Account to set as the admin of roles\n     * @param _nftfiHub - Address of the NftfiHub contract\n     * @param _loanCoordinator - Initial loan coordinator\n     * @param _name - Name for the SmarNFT\n     * @param _symbol - Symbol for the SmarNFT\n     * @param _customBaseURI - Base URI for the SmarNFT\n     */\n    constructor(\n        address _admin,\n        address _nftfiHub,\n        address _loanCoordinator,\n        string memory _name,\n        string memory _symbol,\n        string memory _customBaseURI\n    ) ERC721(_name, _symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        _setupRole(BASE_URI_ROLE, _admin);\n        _setupRole(LOAN_COORDINATOR_ROLE, _loanCoordinator);\n        _setBaseURI(_customBaseURI);\n        hub = INftfiHub(_nftfiHub);\n    }\n\n    /**\n     * @dev Grants LOAN_COORDINATOR_ROLE to `_account`.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function setLoanCoordinator(address _account) external {\n        grantRole(LOAN_COORDINATOR_ROLE, _account);\n    }\n\n    /**\n     * @dev Mints a new token with `_tokenId` and assigne to `_to`.\n     *\n     * Requirements:\n     *\n     * - the caller must have `LOAN_COORDINATOR_ROLE` role.\n     *\n     * @param _to The address reciving the SmartNft\n     * @param _tokenId The id of the new SmartNft\n     * @param _data Up to the first 32 bytes contains an integer which represents the loanId linked to the SmartNft\n     */\n    function mint(address _to, uint256 _tokenId, bytes calldata _data) external onlyRole(LOAN_COORDINATOR_ROLE) {\n        // solhint-disable-next-line custom-errors\n        require(_data.length > 0, \"data must contain loanId\");\n        uint256 loanId = abi.decode(_data, (uint256));\n        loans[_tokenId] = Loan({loanCoordinator: msg.sender, loanId: loanId});\n        _safeMint(_to, _tokenId, _data);\n    }\n\n    /**\n     * @dev Burns `_tokenId` token.\n     *\n     * Requirements:\n     *\n     * - the caller must have `LOAN_COORDINATOR_ROLE` role.\n     */\n    function burn(uint256 _tokenId) external onlyRole(LOAN_COORDINATOR_ROLE) {\n        _burn(_tokenId);\n    }\n\n    /**\n     * @dev Sets baseURI.\n     * @param _customBaseURI - Base URI for the SmarNFT\n     */\n    function setBaseURI(string memory _customBaseURI) external onlyRole(BASE_URI_ROLE) {\n        _setBaseURI(_customBaseURI);\n    }\n\n    function exists(uint256 _tokenId) external view returns (bool) {\n        return _exists(_tokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override(ERC721, AccessControl) returns (bool) {\n        return super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @dev Sets baseURI.\n     */\n    function _setBaseURI(string memory _customBaseURI) internal virtual {\n        baseURI = bytes(_customBaseURI).length > 0\n            ? string(abi.encodePacked(_customBaseURI, _getChainID().toString(), \"/\"))\n            : \"\";\n    }\n\n    /** @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`.\n     */\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n    /**\n     * @dev This function gets the current chain ID.\n     */\n    function _getChainID() internal view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n}\n"
    },
    "contracts/test/DummyPunks.sol": {
      "content": "// SPDX-License-Identifier: -\n\npragma solidity ^0.8.19;\n\nimport {IPunks} from \"../interfaces/IPunks.sol\";\n\ncontract DummyPunks is IPunks {\n    string public standard = \"CryptoPunks\";\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    uint256 public punksRemainingToAssign = 0;\n\n    struct Offer {\n        bool isForSale;\n        uint256 punkIndex;\n        address seller;\n        uint256 minValue; // in ether\n        address onlySellTo; // specify to sell only to a specific person\n    }\n\n    // A record of punks that are offered for sale at a specific minimum value, and perhaps to a specific person\n    mapping(uint256 => Offer) public punksOfferedForSale;\n\n    //mapping (address => uint) public addressToPunkIndex;\n    mapping(uint256 => address) public override punkIndexToAddress;\n\n    /* This creates an array with all balances */\n    mapping(address => uint256) public override balanceOf;\n\n    mapping(address => uint256) public pendingWithdrawals;\n\n    event Assign(address indexed to, uint256 punkIndex);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event PunkTransfer(address indexed from, address indexed to, uint256 punkIndex);\n    event PunkOffered(uint256 indexed punkIndex, uint256 minValue, address indexed toAddress);\n    event PunkBought(uint256 indexed punkIndex, uint256 value, address indexed fromAddress, address indexed toAddress);\n    event PunkNoLongerForSale(uint256 indexed punkIndex);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    constructor() payable {\n        totalSupply = 10000; // Update total supply\n        punksRemainingToAssign = totalSupply;\n        name = \"CRYPTOPUNKS\"; // Set the name for display purposes\n        symbol = \"C\"; // Set the symbol for display purposes\n        decimals = 0; // Amount of decimals for display purposes\n    }\n\n    function mintPunk(address to, uint256 punkIndex) public {\n        // solhint-disable-next-line custom-errors\n        require(punkIndex < 10000, \"index >= 10000\");\n        if (punkIndexToAddress[punkIndex] != to) {\n            if (punkIndexToAddress[punkIndex] != address(0)) {\n                balanceOf[punkIndexToAddress[punkIndex]]--;\n            } else {\n                punksRemainingToAssign--;\n            }\n            punkIndexToAddress[punkIndex] = to;\n            balanceOf[to]++;\n            emit Assign(to, punkIndex);\n        }\n    }\n\n    function mintPunks(address[] memory addresses, uint256[] memory indices) public {\n        uint256 n = addresses.length;\n        for (uint256 i; i < n; ++i) {\n            mintPunk(addresses[i], indices[i]);\n        }\n    }\n\n    // Transfer ownership of a punk to another user without requiring payment\n    function transferPunk(address to, uint256 punkIndex) public override {\n        // solhint-disable-next-line custom-errors\n        require(punkIndexToAddress[punkIndex] == msg.sender, \"sender not owner\");\n        // solhint-disable-next-line custom-errors\n        require(punkIndex < 10000, \"index >= 10000\");\n        punkIndexToAddress[punkIndex] = to;\n        balanceOf[msg.sender]--;\n        balanceOf[to]++;\n        emit Transfer(msg.sender, to, 1);\n        emit PunkTransfer(msg.sender, to, punkIndex);\n    }\n\n    function offerPunkForSaleToAddress(\n        uint256 punkIndex,\n        uint256 minSalePriceInWei,\n        address toAddress\n    ) external override {\n        // solhint-disable-next-line custom-errors\n        require(punkIndexToAddress[punkIndex] == msg.sender, \"sender not owner\");\n        // solhint-disable-next-line custom-errors\n        require(punkIndex < 10000, \"index >= 10000\");\n        punksOfferedForSale[punkIndex] = Offer(true, punkIndex, msg.sender, minSalePriceInWei, toAddress);\n        emit PunkOffered(punkIndex, minSalePriceInWei, toAddress);\n    }\n\n    function buyPunk(uint256 punkIndex) external payable override {\n        Offer memory offer = punksOfferedForSale[punkIndex];\n        // solhint-disable-next-line custom-errors\n        require(punkIndex < 10000, \"index >= 10000\");\n        // solhint-disable-next-line custom-errors\n        require(offer.isForSale, \"punk not for sale\");\n        // solhint-disable-next-line custom-errors\n        require(offer.onlySellTo == address(0) || offer.onlySellTo == msg.sender, \"shouldnt be sold to this user\");\n        // solhint-disable-next-line custom-errors\n        require(msg.value >= offer.minValue, \"not enough ETH sent\");\n        // solhint-disable-next-line custom-errors\n        require(punkIndexToAddress[punkIndex] == offer.seller, \"seller not owner\");\n\n        address seller = offer.seller;\n\n        punkIndexToAddress[punkIndex] = msg.sender;\n        balanceOf[seller]--;\n        balanceOf[msg.sender]++;\n        emit Transfer(seller, msg.sender, 1);\n\n        punkNoLongerForSale(punkIndex);\n        emit PunkBought(punkIndex, msg.value, seller, msg.sender);\n    }\n\n    function punkNoLongerForSale(uint256 punkIndex) public {\n        // solhint-disable-next-line custom-errors\n        require(punkIndexToAddress[punkIndex] == msg.sender, \"sender not owner\");\n        // solhint-disable-next-line custom-errors\n        require(punkIndex < 10000, \"index >= 10000\");\n        punksOfferedForSale[punkIndex] = Offer(false, punkIndex, msg.sender, 0, address(0));\n        emit PunkNoLongerForSale(punkIndex);\n    }\n}\n"
    },
    "contracts/test/FakeNftWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.19;\n\ncontract FakeNftWrapper {\n    function transferNFT(address, address, address, uint256) public {\n        selfdestruct(payable(msg.sender));\n    }\n}\n"
    },
    "contracts/test/MockDyDxFlashloan.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {ISoloMargin, IFlashloanDyDx} from \"../refinancing/flashloan/dydx/ISoloMargin.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title MockDyDxFlashloan\n * @author NFTfi\n * @dev This contract is a mock of the dYdX flash loan system for testing purposes.\n * It implements the ISoloMargin interface to mimic the behavior of dYdX flash loans on a local network.\n */\ncontract MockDyDxFlashloan is ISoloMargin {\n    mapping(uint256 => address) public markets;\n\n    /**\n     * @dev Contract constructor that sets the ERC20 markets.\n     * @param _erc20s The address of the ERC20 tokens\n     * @param _marketIds The id of the markets\n     */\n    constructor(address[] memory _erc20s, uint256[] memory _marketIds) {\n        setMarkets(_erc20s, _marketIds);\n    }\n\n    /**\n     * @dev Updates the ERC20 token address.\n     * @param _erc20 The new address of the ERC20 token.\n     */\n    function setMarket(address _erc20, uint256 _marketId) public {\n        markets[_marketId] = _erc20;\n    }\n\n    function setMarkets(address[] memory _erc20s, uint256[] memory _marketIds) public {\n        // solhint-disable-next-line custom-errors\n        require(_erc20s.length == _marketIds.length, \"setMarkets function information arity mismatch\");\n        for (uint256 i; i < _erc20s.length; ++i) {\n            setMarket(_erc20s[i], _marketIds[i]);\n        }\n    }\n\n    /**\n     * @dev Mocks a flash loan operation. It transfers the loan amount to the borrower,\n     * calls the function on the borrower's contract, and then transfers the repayment from the borrower.\n     * @param accountInfo Information about the account.\n     * @param actions Actions to be performed during the flash loan operation.\n     */\n    function operate(\n        IFlashloanDyDx.AccountInfo[] memory accountInfo,\n        IFlashloanDyDx.ActionArgs[] memory actions\n    ) external override {\n        IERC20(markets[actions[0].primaryMarketId]).transfer(msg.sender, actions[0].amount.value);\n        IFlashloanDyDx(msg.sender).callFunction(msg.sender, accountInfo[0], actions[1].data);\n        IERC20(markets[actions[2].primaryMarketId]).transferFrom(msg.sender, address(this), actions[2].amount.value);\n    }\n\n    /**\n     * @dev Returns the address of the ERC20 token. This mocks the function in the real dYdX contract which\n     * returns the address of the token for a given market id.\n     * @param *_marketId The id of the market (not used in this mock contract).\n     * @return The address of the ERC20 token.\n     */\n    function getMarketTokenAddress(uint256 _marketId) external view override returns (address) {\n        return markets[_marketId];\n    }\n}\n"
    },
    "contracts/test/oldNftTypes/OldCryptoKittiesWrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {OldINftWrapper} from \"./OldINftWrapper.sol\";\nimport {ICryptoKitties} from \"../../interfaces/ICryptoKitties.sol\";\n\n/**\n * @title CryptoKittiesWrapper\n * @author NFTfi\n * @dev Provides logic to transfer CryptoKitties\n */\ncontract OldCryptoKittiesWrapper is OldINftWrapper {\n    /**\n     * @dev Transfers Kitty `_nftId` handled by the contract `_nftContract` from `_sender` to `_recipient`\n     *\n     * @param _sender - The current owner of the Kitty\n     * @param _recipient - The new owner of the Kitty\n     * @param _nftContract - CryptoKitties contract\n     * @param _nftId - Kitty id\n     *\n     * @return true if successfully transferred, false otherwise\n     */\n    function transferNFT(\n        address _sender,\n        address _recipient,\n        address _nftContract,\n        uint256 _nftId\n    ) external override returns (bool) {\n        if (_sender == address(this)) {\n            ICryptoKitties(_nftContract).transfer(_recipient, _nftId);\n        } else {\n            ICryptoKitties(_nftContract).transferFrom(_sender, _recipient, _nftId);\n        }\n\n        return true;\n    }\n\n    function isOwner(address _owner, address _nftContract, uint256 _tokenId) external view override returns (bool) {\n        return ICryptoKitties(_nftContract).ownerOf(_tokenId) == _owner;\n    }\n}\n"
    },
    "contracts/test/oldNftTypes/OldERC1155Wrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {OldINftWrapper} from \"./OldINftWrapper.sol\";\n\n/**\n * @title ERC1155Wrapper\n * @dev Provides logic to transfer ERC1155 tokens\n */\ncontract OldERC1155Wrapper is OldINftWrapper {\n    /**\n     * @dev Transfer the nft to the `recipient`\n     *\n     * @param _sender Address of the current owner of the nft\n     * @param _recipient Address that will receive the nft\n     * @param _nftContract Address of the nft contract\n     * @param _nftId Id of the nft\n     *\n     * @return true if successfully transferred, false otherwise\n     */\n    function transferNFT(\n        address _sender,\n        address _recipient,\n        address _nftContract,\n        uint256 _nftId\n    ) external override returns (bool) {\n        // Warning:\n        // Since we permit ERC1155s in their entirety, the given nftId may represent a fungible token (amount > 1),\n        // in which case they are treated as non-fungible by hard coding the amount to 1.\n        IERC1155(_nftContract).safeTransferFrom(_sender, _recipient, _nftId, 1, \"\");\n        return true;\n    }\n\n    function isOwner(address _owner, address _nftContract, uint256 _tokenId) external view override returns (bool) {\n        return IERC1155(_nftContract).balanceOf(_owner, _tokenId) > 0;\n    }\n}\n"
    },
    "contracts/test/oldNftTypes/OldERC721LegacyWrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {OldINftWrapper} from \"./OldINftWrapper.sol\";\n\n/**\n * @title ERC721LegacyWrapper\n * @author NFTfi\n * @dev Provides logic to transfer ERC721, uses regular transferFrom instead of safe\n */\ncontract OldERC721LegacyWrapper is OldINftWrapper {\n    /**\n     * @dev Transfers ERC721 `_nftId` handled by the contract `_nftContract` from `_sender` to `_recipient`\n     *\n     * @param _sender - The current owner of the ERC721\n     * @param _recipient - The new owner of the ERC721\n     * @param _nftContract - ERC721 contract\n     * @param _nftId - ERC721 id\n     *\n     * @return true if successfully transferred, false otherwise\n     */\n    function transferNFT(\n        address _sender,\n        address _recipient,\n        address _nftContract,\n        uint256 _nftId\n    ) external override returns (bool) {\n        IERC721(_nftContract).transferFrom(_sender, _recipient, _nftId);\n        return true;\n    }\n\n    function isOwner(address _owner, address _nftContract, uint256 _tokenId) external view override returns (bool) {\n        return IERC721(_nftContract).ownerOf(_tokenId) == _owner;\n    }\n}\n"
    },
    "contracts/test/oldNftTypes/OldERC721Wrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {OldINftWrapper} from \"./OldINftWrapper.sol\";\n\n/**\n * @title ERC721Wrapper\n * @author NFTfi\n * @dev Provides logic to transfer ERC721\n */\ncontract OldERC721Wrapper is OldINftWrapper {\n    /**\n     * @dev Transfers ERC721 `_nftId` handled by the contract `_nftContract` from `_sender` to `_recipient`\n     *\n     * @param _sender - The current owner of the ERC721\n     * @param _recipient - The new owner of the ERC721\n     * @param _nftContract - ERC721 contract\n     * @param _nftId - ERC721 id\n     *\n     * @return true if successfully transferred, false otherwise\n     */\n    function transferNFT(\n        address _sender,\n        address _recipient,\n        address _nftContract,\n        uint256 _nftId\n    ) external override returns (bool) {\n        IERC721(_nftContract).safeTransferFrom(_sender, _recipient, _nftId);\n        return true;\n    }\n\n    function isOwner(address _owner, address _nftContract, uint256 _tokenId) external view override returns (bool) {\n        return IERC721(_nftContract).ownerOf(_tokenId) == _owner;\n    }\n}\n"
    },
    "contracts/test/oldNftTypes/OldINftWrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\n/**\n * @title INftTypeRegistry\n * @author NFTfi\n * @dev Interface for NFT Wrappers.\n */\ninterface OldINftWrapper {\n    function transferNFT(address from, address to, address nftContract, uint256 tokenId) external returns (bool);\n\n    function isOwner(address owner, address nftContract, uint256 tokenId) external view returns (bool);\n}\n"
    },
    "contracts/test/oldNftTypes/OldPunkWrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {OldINftWrapper} from \"./OldINftWrapper.sol\";\nimport {IPunks} from \"../../interfaces/IPunks.sol\";\n\n/**\n * @title PunkWrapper\n * @author NFTfi\n * @dev Provides logic to transfer Punks\n */\ncontract OldPunkWrapper is OldINftWrapper {\n    /**\n     * @dev Transfers Punk `_nftId` handled by the contract `_nftContract` from `_sender` to `_recipient`\n     *\n     * @param _sender - The current owner of the Punk\n     * @param _recipient - The new owner of the Punk\n     * @param _nftContract - Punk contract\n     * @param _nftId - Punk id\n     *\n     * @return true if successfully transferred, false otherwise\n     */\n    function transferNFT(\n        address _sender,\n        address _recipient,\n        address _nftContract,\n        uint256 _nftId\n    ) external override returns (bool) {\n        if (address(this) == _sender) {\n            IPunks(_nftContract).transferPunk(_recipient, _nftId);\n        } else {\n            // solhint-disable-next-line custom-errors\n            require(isOwner(_sender, _nftContract, _nftId), \"PunkWrapper:sender must be owner\");\n            IPunks(_nftContract).buyPunk(_nftId);\n        }\n        return true;\n    }\n\n    function isOwner(address _owner, address _nftContract, uint256 _tokenId) public view override returns (bool) {\n        return IPunks(_nftContract).punkIndexToAddress(_tokenId) == _owner;\n    }\n}\n"
    },
    "contracts/test/TestBaseLoan.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {BaseLoan} from \"../loans/BaseLoan.sol\";\n\ncontract TestBaseLoan is BaseLoan {\n    constructor(address _admin) BaseLoan(_admin) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n"
    },
    "contracts/test/TestCryptoKitties.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {ICryptoKitties} from \"../interfaces/ICryptoKitties.sol\";\n\n/**\n * @title TestCryptoKitties\n * @dev Test contract with CryptoKitties ERC721 related functionalities.\n * Extracted from https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code\n */\ncontract TestCryptoKitties is ICryptoKitties {\n    // @notice Name and symbol of the non fungible token, as defined in ERC721.\n    string public constant name = \"CryptoKitties\";\n    string public constant symbol = \"CK\";\n\n    bytes4 public constant InterfaceSignature_ERC165 = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n\n    bytes4 public constant InterfaceSignature_ERC721 =\n        bytes4(keccak256(\"name()\")) ^\n            bytes4(keccak256(\"symbol()\")) ^\n            bytes4(keccak256(\"totalSupply()\")) ^\n            bytes4(keccak256(\"balanceOf(address)\")) ^\n            bytes4(keccak256(\"ownerOf(uint256)\")) ^\n            bytes4(keccak256(\"approve(address,uint256)\")) ^\n            bytes4(keccak256(\"transfer(address,uint256)\")) ^\n            bytes4(keccak256(\"transferFrom(address,address,uint256)\")) ^\n            bytes4(keccak256(\"tokensOfOwner(address)\")) ^\n            bytes4(keccak256(\"tokenMetadata(uint256,string)\"));\n\n    /*** DATA TYPES ***/\n\n    /// @dev The main Kitty struct. Every cat in CryptoKitties is represented by a copy\n    ///  of this structure, so great care was taken to ensure that it fits neatly into\n    ///  exactly two 256-bit words. Note that the order of the members in this structure\n    ///  is important because of the byte-packing rules used by Ethereum.\n    ///  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html\n    struct Kitty {\n        // The Kitty's genetic code is packed into these 256-bits, the format is\n        // sooper-sekret! A cat's genes never change.\n        uint256 genes;\n        // The timestamp from the block when this cat came into existence.\n        uint64 birthTime;\n        // The minimum timestamp after which this cat can engage in breeding\n        // activities again. This same timestamp is used for the pregnancy\n        // timer (for matrons) as well as the siring cooldown.\n        uint64 cooldownEndBlock;\n        // The ID of the parents of this kitty, set to 0 for gen0 cats.\n        // Note that using 32-bit unsigned integers limits us to a \"mere\"\n        // 4 billion cats. This number might seem small until you realize\n        // that Ethereum currently has a limit of about 500 million\n        // transactions per year! So, this definitely won't be a problem\n        // for several years (even as Ethereum learns to scale).\n        uint32 matronId;\n        uint32 sireId;\n        // Set to the ID of the sire cat for matrons that are pregnant,\n        // zero otherwise. A non-zero value here is how we know a cat\n        // is pregnant. Used to retrieve the genetic material for the new\n        // kitten when the birth transpires.\n        uint32 siringWithId;\n        // Set to the index in the cooldown array (see below) that represents\n        // the current cooldown duration for this Kitty. This starts at zero\n        // for gen0 cats, and is initialized to floor(generation/2) for others.\n        // Incremented by one for each successful breeding action, regardless\n        // of whether this cat is acting as matron or sire.\n        uint16 cooldownIndex;\n        // The \"generation number\" of this cat. Cats minted by the CK contract\n        // for sale are called \"gen0\" and have a generation number of 0. The\n        // generation number of all other cats is the larger of the two generation\n        // numbers of their parents, plus one.\n        // (i.e. max(matron.generation, sire.generation) + 1)\n        uint16 generation;\n    }\n\n    /*** CONSTANTS ***/\n\n    /// @dev A mapping from cat IDs to the address that owns them. All cats have\n    ///  some valid owner address, even gen0 cats are created with a non-zero owner.\n    mapping(uint256 => address) public kittyIndexToOwner;\n\n    // @dev A mapping from owner address to count of tokens that address owns.\n    //  Used internally inside balanceOf() to resolve ownership count.\n    mapping(address => uint256) public ownershipTokenCount;\n\n    /// @dev A mapping from KittyIDs to an address that has been approved to call\n    ///  transferFrom(). Each Kitty can only have one approved address for transfer\n    ///  at any time. A zero value means no approval is outstanding.\n    mapping(uint256 => address) public kittyIndexToApproved;\n\n    /// @dev A mapping from KittyIDs to an address that has been approved to use\n    ///  this Kitty for siring via breedWith(). Each Kitty can only have one approved\n    ///  address for siring at any time. A zero value means no approval is outstanding.\n    mapping(uint256 => address) public sireAllowedToAddress;\n\n    /// @dev An array containing the Kitty struct for all Kitties in existence. The ID\n    ///  of each cat is actually an index into this array. Note that ID 0 is a negacat,\n    ///  the unKitty, the mythical beast that is the parent of all gen0 cats. A bizarre\n    ///  creature that is both matron and sire... to itself! Has an invalid genetic code.\n    ///  In other words, cat ID 0 is invalid... ;-)\n    Kitty[] public kitties;\n\n    /// @dev The Birth event is fired whenever a new kitten comes into existence. This obviously\n    ///  includes any time a cat is created through the giveBirth method, but it is also called\n    ///  when a new gen0 cat is created.\n    event Birth(address owner, uint256 kittyId, uint256 matronId, uint256 sireId, uint256 genes);\n\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\n    ///  ERC-165 (obviously!) and ERC-721.\n    function supportsInterface(bytes4 _interfaceID) external pure override returns (bool) {\n        // DEBUG ONLY\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\n\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\n    }\n\n    /// @notice Returns the number of Kitties owned by a specific address.\n    /// @param _owner The owner address to check.\n    /// @dev Required for ERC-721 compliance\n    function balanceOf(address _owner) public view override returns (uint256 count) {\n        return ownershipTokenCount[_owner];\n    }\n\n    function mint(address _owner) external returns (uint256) {\n        return _createKitty(0, 0, 0, 0, _owner);\n    }\n\n    /// @notice Transfers a Kitty to another address. If transferring to a smart\n    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or\n    ///  CryptoKitties specifically) or your Kitty may be lost forever. Seriously.\n    /// @param _to The address of the recipient, can be a user or contract.\n    /// @param _tokenId The ID of the Kitty to transfer.\n    /// @dev Required for ERC-721 compliance.\n    function transfer(address _to, uint256 _tokenId) external override {\n        // Safety check to prevent against an unexpected 0x0 default.\n        // solhint-disable-next-line custom-errors\n        require(_to != address(0), \"\");\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any kitties (except very briefly\n        // after a gen0 cat is created and before it goes on auction).\n        // solhint-disable-next-line custom-errors\n        require(_to != address(this), \"\");\n        // Disallow transfers to the auction contracts to prevent accidental\n        // misuse. Auction contracts should only take ownership of kitties\n        // through the allow + transferFrom flow.\n        // require(_to != address(saleAuction));\n        // require(_to != address(siringAuction));\n\n        // You can only send your own cat.\n        // solhint-disable-next-line custom-errors\n        require(_owns(msg.sender, _tokenId), \"\");\n\n        // Reassign ownership, clear pending approvals, emit Transfer event.\n        _transfer(msg.sender, _to, _tokenId);\n    }\n\n    /// @notice Grant another address the right to transfer a specific Kitty via\n    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n    /// @param _to The address to be granted transfer approval. Pass address(0) to\n    ///  clear all approvals.\n    /// @param _tokenId The ID of the Kitty that can be transferred if this call succeeds.\n    /// @dev Required for ERC-721 compliance.\n    function approve(address _to, uint256 _tokenId) external override {\n        // Only an owner can grant transfer approval.\n        // solhint-disable-next-line custom-errors\n        require(_owns(msg.sender, _tokenId), \"\");\n\n        // Register the approval (replacing any previous approval).\n        _approve(_tokenId, _to);\n\n        // Emit approval event.\n        emit Approval(msg.sender, _to, _tokenId);\n    }\n\n    /// @notice Transfer a Kitty owned by another address, for which the calling address\n    ///  has previously been granted transfer approval by the owner.\n    /// @param _from The address that owns the Kitty to be transfered.\n    /// @param _to The address that should take ownership of the Kitty. Can be any address,\n    ///  including the caller.\n    /// @param _tokenId The ID of the Kitty to be transferred.\n    /// @dev Required for ERC-721 compliance.\n    function transferFrom(address _from, address _to, uint256 _tokenId) external override {\n        // Safety check to prevent against an unexpected 0x0 default.\n        // solhint-disable-next-line custom-errors\n        require(_to != address(0), \"\");\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any kitties (except very briefly\n        // after a gen0 cat is created and before it goes on auction).\n        // solhint-disable-next-line custom-errors\n        require(_to != address(this), \"\");\n        // Check for approval and valid ownership\n        // solhint-disable-next-line custom-errors\n        require(_approvedFor(msg.sender, _tokenId), \"\");\n        // solhint-disable-next-line custom-errors\n        require(_owns(_from, _tokenId), \"\");\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Returns the total number of Kitties currently in existence.\n    /// @dev Required for ERC-721 compliance.\n    function totalSupply() public view override returns (uint256) {\n        return kitties.length - 1;\n    }\n\n    /// @notice Returns the address currently assigned ownership of a given Kitty.\n    /// @dev Required for ERC-721 compliance.\n    function ownerOf(uint256 _tokenId) external view override returns (address owner) {\n        owner = kittyIndexToOwner[_tokenId];\n\n        // solhint-disable-next-line custom-errors\n        require(owner != address(0), \"\");\n    }\n\n    /// @notice Returns a list of all Kitty IDs assigned to an address.\n    /// @param _owner The owner whose Kitties we are interested in.\n    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Kitty array looking for cats belonging to owner),\n    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n    ///  not contract-to-contract calls.\n    function tokensOfOwner(address _owner) external view returns (uint256[] memory ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalCats = totalSupply();\n            uint256 resultIndex = 0;\n\n            // We count on the fact that all cats have IDs starting at 1 and increasing\n            // sequentially up to the totalCat count.\n            uint256 catId;\n\n            for (catId = 1; catId <= totalCats; catId++) {\n                if (kittyIndexToOwner[catId] == _owner) {\n                    result[resultIndex] = catId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n\n    /// @dev Assigns ownership of a specific Kitty to an address.\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n        // Since the number of kittens is capped to 2^32 we can't overflow this\n        ownershipTokenCount[_to]++;\n        // transfer ownership\n        kittyIndexToOwner[_tokenId] = _to;\n        // When creating new kittens _from is 0x0, but we can't account that address.\n        if (_from != address(0)) {\n            ownershipTokenCount[_from]--;\n            // once the kitten is transferred also clear sire allowances\n            delete sireAllowedToAddress[_tokenId];\n            // clear any previously approved ownership exchange\n            delete kittyIndexToApproved[_tokenId];\n        }\n        // Emit the transfer event.\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @dev An internal method that creates a new kitty and stores it. This\n    ///  method doesn't do any checking and should only be called when the\n    ///  input data is known to be valid. Will generate both a Birth event\n    ///  and a Transfer event.\n    /// @param _matronId The kitty ID of the matron of this cat (zero for gen0)\n    /// @param _sireId The kitty ID of the sire of this cat (zero for gen0)\n    /// @param _generation The generation number of this cat, must be computed by caller.\n    /// @param _genes The kitty's genetic code.\n    /// @param _owner The inital owner of this cat, must be non-zero (except for the unKitty, ID 0)\n    function _createKitty(\n        uint256 _matronId,\n        uint256 _sireId,\n        uint256 _generation,\n        uint256 _genes,\n        address _owner\n    ) internal returns (uint256) {\n        // These requires are not strictly necessary, our calling code should make\n        // sure that these conditions are never broken. However! _createKitty() is already\n        // an expensive call (for storage), and it doesn't hurt to be especially careful\n        // to ensure our data structures are always valid.\n        // solhint-disable-next-line custom-errors\n        require(_matronId == uint256(uint32(_matronId)), \"bad _matronId\");\n        // solhint-disable-next-line custom-errors\n        require(_sireId == uint256(uint32(_sireId)), \"bad _sireId\");\n        // solhint-disable-next-line custom-errors\n        require(_generation == uint256(uint16(_generation)), \"bad _generation\");\n\n        // New kitty starts with the same cooldown as parent gen/2\n        uint16 cooldownIndex = uint16(_generation / 2);\n        if (cooldownIndex > 13) {\n            cooldownIndex = 13;\n        }\n\n        Kitty memory _kitty = Kitty({\n            genes: _genes,\n            birthTime: uint64(block.timestamp),\n            cooldownEndBlock: 0,\n            matronId: uint32(_matronId),\n            sireId: uint32(_sireId),\n            siringWithId: 0,\n            cooldownIndex: cooldownIndex,\n            generation: uint16(_generation)\n        });\n        kitties.push(_kitty);\n        uint256 newKittenId = kitties.length - 1;\n\n        // It's probably never going to happen, 4 billion cats is A LOT, but\n        // let's just be 100% sure we never let this happen.\n        // solhint-disable-next-line custom-errors\n        require(newKittenId == uint256(uint32(newKittenId)), \"bad newKittenId\");\n\n        // emit the birth event\n        emit Birth(_owner, newKittenId, uint256(_kitty.matronId), uint256(_kitty.sireId), _kitty.genes);\n\n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(address(0), _owner, newKittenId);\n\n        return newKittenId;\n    }\n\n    /// @dev Checks if a given address is the current owner of a particular Kitty.\n    /// @param _claimant the address we are validating against.\n    /// @param _tokenId kitten id, only valid when > 0\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return kittyIndexToOwner[_tokenId] == _claimant;\n    }\n\n    /// @dev Checks if a given address currently has transferApproval for a particular Kitty.\n    /// @param _claimant the address we are confirming kitten is approved for.\n    /// @param _tokenId kitten id, only valid when > 0\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return kittyIndexToApproved[_tokenId] == _claimant;\n    }\n\n    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n    ///  approval. Setting _approved to address(0) clears all transfer approval.\n    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\n    ///  _approve() and transferFrom() are used together for putting Kitties on auction, and\n    ///  there is no value in spamming the log with Approval events in that case.\n    function _approve(uint256 _tokenId, address _approved) internal {\n        kittyIndexToApproved[_tokenId] = _approved;\n    }\n}\n"
    },
    "contracts/test/TestERC1155.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\ncontract TestERC1155 is ERC1155 {\n    constructor() ERC1155(\"\") {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function mint(address to, uint256 id, uint256 value, bytes memory data) public {\n        _mint(to, id, value, data);\n    }\n\n    function mintToSender(uint256 id, uint256 value, bytes memory data) public {\n        _mint(msg.sender, id, value, data);\n    }\n}\n"
    },
    "contracts/test/TestERC721.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract TestERC721 is ERC721 {\n    constructor() ERC721(\"TestERC721\", \"T721\") {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function mint(address _to, uint256 _tokenId) public {\n        _safeMint(_to, _tokenId);\n    }\n\n    function mintToSender(uint256 _tokenId) public {\n        _safeMint(msg.sender, _tokenId);\n    }\n}\n"
    },
    "contracts/test/TestGaspMasks.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {\n    ERC721PresetMinterPauserAutoId\n} from \"@openzeppelin/contracts/token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol\";\n\ncontract TestGaspMasks is ERC721PresetMinterPauserAutoId {\n    constructor() ERC721PresetMinterPauserAutoId(\"GaspMasks\", \"WTF\", \"https://example.com/token/\") {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n"
    },
    "contracts/test/TestLegacyERC721.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Receiver.sol\n\n/* solhint-disable one-contract-per-file */\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n *  from ERC721 asset contracts.\n */\nabstract contract LegacyERC721Receiver {\n    /**\n     * @dev Magic value to be returned upon successful reception of an NFT\n     *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\n     *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n     */\n    bytes4 public constant ERC721_RECEIVED = 0xf0b9e5ba;\n\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     *  after a `safetransfer`. This function MAY throw to revert and reject the\n     *  transfer. This function MUST use 50,000 gas or less. Return of other\n     *  than the magic value MUST result in the transaction being reverted.\n     *  Note: the contract address is always the message sender.\n     * @param _from The sending address\n     * @param _tokenId The NFT identifier which is being transfered\n     * @param _data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address _from, uint256 _tokenId, bytes memory _data) public virtual returns (bytes4);\n}\n\ncontract LegacyERC721BasicToken {\n    using SafeMath for uint256;\n    using AddressUtils for address;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\n    // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n    bytes4 public constant ERC721_RECEIVED = 0xf0b9e5ba;\n\n    // Mapping from token ID to owner\n    mapping(uint256 => address) internal tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) internal tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping(address => uint256) internal ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) internal operatorApprovals;\n\n    /**\n     * @dev Guarantees msg.sender is owner of the given token\n     * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n     */\n    modifier onlyOwnerOf(uint256 _tokenId) {\n        // solhint-disable-next-line custom-errors\n        require(ownerOf(_tokenId) == msg.sender, \"onlyOwnerOf\");\n        _;\n    }\n\n    /**\n     * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\n     * @param _tokenId uint256 ID of the token to validate\n     */\n    modifier canTransfer(uint256 _tokenId) {\n        // solhint-disable-next-line custom-errors\n        require(isApprovedOrOwner(msg.sender, _tokenId), \"canTransfer\");\n        _;\n    }\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /**\n     * @dev Gets the balance of the specified address\n     * @param _owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address _owner) public view returns (uint256) {\n        // solhint-disable-next-line custom-errors\n        require(_owner != address(0), \"0 address\");\n        return ownedTokensCount[_owner];\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID\n     * @param _tokenId uint256 ID of the token to query the owner of\n     * @return owner address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 _tokenId) public view returns (address) {\n        address owner = tokenOwner[_tokenId];\n        // solhint-disable-next-line custom-errors\n        require(owner != address(0), \"0 address\");\n        return owner;\n    }\n\n    /**\n     * @dev Returns whether the specified token exists\n     * @param _tokenId uint256 ID of the token to query the existance of\n     * @return whether the token exists\n     */\n    function exists(uint256 _tokenId) public view returns (bool) {\n        address owner = tokenOwner[_tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * @dev The zero address indicates there is no approved address.\n     * @dev There can only be one approved address per token at a given time.\n     * @dev Can only be called by the token owner or an approved operator.\n     * @param _to address to be approved for the given token ID\n     * @param _tokenId uint256 ID of the token to be approved\n     */\n    function approve(address _to, uint256 _tokenId) public {\n        address owner = ownerOf(_tokenId);\n        // solhint-disable-next-line custom-errors\n        require(_to != owner, \"same owner\");\n        // solhint-disable-next-line custom-errors\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"sender not owner\");\n\n        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n            tokenApprovals[_tokenId] = _to;\n            emit Approval(owner, _to, _tokenId);\n        }\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * @param _tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for a the given token ID\n     */\n    function getApproved(uint256 _tokenId) public view returns (address) {\n        return tokenApprovals[_tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * @dev An operator is allowed to transfer all tokens of the sender on their behalf\n     * @param _to operator address to set the approval\n     * @param _approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address _to, bool _approved) public {\n        // solhint-disable-next-line custom-errors\n        require(_to != msg.sender, \"to sender\");\n        operatorApprovals[msg.sender][_to] = _approved;\n        emit ApprovalForAll(msg.sender, _to, _approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner\n     * @param _owner owner address which you want to query the approval of\n     * @param _operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n        return operatorApprovals[_owner][_operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address\n     * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n     * @dev Requires the msg sender to be the owner, approved, or operator\n     * @param _from current owner of the token\n     * @param _to address to receive the ownership of the given token ID\n     * @param _tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\n        // solhint-disable-next-line custom-errors\n        require(_from != address(0), \"from 0 address\");\n        // solhint-disable-next-line custom-errors\n        require(_to != address(0), \"to 0 address\");\n\n        clearApproval(_from, _tokenId);\n        removeTokenFrom(_from, _tokenId);\n        addTokenTo(_to, _tokenId);\n\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * @dev If the target address is a contract, it must implement `onERC721Received`,\n     *  which is called upon a safe transfer, and return the magic value\n     *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n     *  the transfer is reverted.\n     * @dev Requires the msg sender to be the owner, approved, or operator\n     * @param _from current owner of the token\n     * @param _to address to receive the ownership of the given token ID\n     * @param _tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\n        // solium-disable-next-line arg-overflow\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * @dev If the target address is a contract, it must implement `onERC721Received`,\n     *  which is called upon a safe transfer, and return the magic value\n     *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n     *  the transfer is reverted.\n     * @dev Requires the msg sender to be the owner, approved, or operator\n     * @param _from current owner of the token\n     * @param _to address to receive the ownership of the given token ID\n     * @param _tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) public canTransfer(_tokenId) {\n        transferFrom(_from, _to, _tokenId);\n        // solium-disable-next-line arg-overflow\n        // solhint-disable-next-line custom-errors\n        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data), \"safe transfer failed\");\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param _spender address of the spender to query\n     * @param _tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *  is an operator of the owner, or is the owner of the token\n     */\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\n        address owner = ownerOf(_tokenId);\n        return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\n    }\n\n    /**\n     * @dev Internal function to mint a new token\n     * @dev Reverts if the given token ID already exists\n     * @param _to The address that will own the minted token\n     * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n     */\n    function _mint(address _to, uint256 _tokenId) internal virtual {\n        // solhint-disable-next-line custom-errors\n        require(_to != address(0), \"to 0 address\");\n        addTokenTo(_to, _tokenId);\n        emit Transfer(address(0), _to, _tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * @dev Reverts if the token does not exist\n     * @param _tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address _owner, uint256 _tokenId) internal virtual {\n        clearApproval(_owner, _tokenId);\n        removeTokenFrom(_owner, _tokenId);\n        emit Transfer(_owner, address(0), _tokenId);\n    }\n\n    /**\n     * @dev Internal function to clear current approval of a given token ID\n     * @dev Reverts if the given address is not indeed the owner of the token\n     * @param _owner owner of the token\n     * @param _tokenId uint256 ID of the token to be transferred\n     */\n    function clearApproval(address _owner, uint256 _tokenId) internal {\n        // solhint-disable-next-line custom-errors\n        require(ownerOf(_tokenId) == _owner, \"address not owner\");\n        if (tokenApprovals[_tokenId] != address(0)) {\n            tokenApprovals[_tokenId] = address(0);\n            emit Approval(_owner, address(0), _tokenId);\n        }\n    }\n\n    /**\n     * @dev Internal function to add a token ID to the list of a given address\n     * @param _to address representing the new owner of the given token ID\n     * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function addTokenTo(address _to, uint256 _tokenId) internal virtual {\n        // solhint-disable-next-line custom-errors\n        require(tokenOwner[_tokenId] == address(0), \"already owner of token\");\n        tokenOwner[_tokenId] = _to;\n        ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n    }\n\n    /**\n     * @dev Internal function to remove a token ID from the list of a given address\n     * @param _from address representing the previous owner of the given token ID\n     * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function removeTokenFrom(address _from, uint256 _tokenId) internal virtual {\n        // solhint-disable-next-line custom-errors\n        require(ownerOf(_tokenId) == _from, \"address not owner\");\n        ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n        tokenOwner[_tokenId] = address(0);\n    }\n\n    /**\n     * @dev Internal function to invoke `onERC721Received` on a target address\n     * @dev The call is not executed if the target address is not a contract\n     * @param _from address representing the previous owner of the given token ID\n     * @param _to target address that will receive the tokens\n     * @param _tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return whether the call correctly returned the expected magic value\n     */\n    function checkAndCallSafeTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (!_to.isContract()) {\n            return true;\n        }\n        bytes4 retval = LegacyERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\n        return (retval == ERC721_RECEIVED);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        if (a == 0) {\n            return 0;\n        }\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary AddressUtils {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     *  as the code is not actually created until after the constructor finishes.\n     * @param addr address to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(addr)\n        } // solium-disable-line security/no-inline-assembly\n        return size > 0;\n    }\n}\n\ncontract TestLegacyERC721 is LegacyERC721BasicToken {\n    uint256 public tokenId;\n\n    function mint(address _to) public {\n        _mint(_to, tokenId);\n        tokenId++;\n    }\n\n    function mintToSender() public {\n        _mint(msg.sender, tokenId);\n        tokenId++;\n    }\n}\n\n/* solhint-enable one-contract-per-file */\n"
    },
    "contracts/test/TestnetPunks.sol": {
      "content": "// SPDX-License-Identifier: -\n\npragma solidity ^0.8.19;\n\nimport {IPunks} from \"../interfaces/IPunks.sol\";\n\ncontract TestnetPunks is IPunks {\n    string public standard = \"CryptoPunks\";\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    uint256 public counter = 0;\n\n    struct Offer {\n        bool isForSale;\n        uint256 punkIndex;\n        address seller;\n        uint256 minValue; // in ether\n        address onlySellTo; // specify to sell only to a specific person\n    }\n\n    // A record of punks that are offered for sale at a specific minimum value, and perhaps to a specific person\n    mapping(uint256 => Offer) public punksOfferedForSale;\n\n    //mapping (address => uint) public addressToPunkIndex;\n    mapping(uint256 => address) public override punkIndexToAddress;\n\n    /* This creates an array with all balances */\n    mapping(address => uint256) public override balanceOf;\n\n    mapping(address => uint256) public pendingWithdrawals;\n\n    event Assign(address indexed to, uint256 punkIndex);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event PunkTransfer(address indexed from, address indexed to, uint256 punkIndex);\n    event PunkOffered(uint256 indexed punkIndex, uint256 minValue, address indexed toAddress);\n    event PunkBought(uint256 indexed punkIndex, uint256 value, address indexed fromAddress, address indexed toAddress);\n    event PunkNoLongerForSale(uint256 indexed punkIndex);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    constructor() payable {\n        totalSupply = 10000; // Update total supply\n        name = \"TESTNETPUNKS\"; // Set the name for display purposes\n        symbol = \"TC\"; // Set the symbol for display purposes\n        decimals = 0; // Amount of decimals for display purposes\n    }\n\n    function mintPunk(address to) public {\n        uint256 punkIndex = counter;\n        punkIndexToAddress[punkIndex] = to;\n        balanceOf[to]++;\n        counter++;\n        emit Assign(to, punkIndex);\n    }\n\n    // Transfer ownership of a punk to another user without requiring payment\n    function transferPunk(address to, uint256 punkIndex) public override {\n        // solhint-disable-next-line custom-errors\n        require(punkIndexToAddress[punkIndex] == msg.sender, \"sender not owner\");\n        // solhint-disable-next-line custom-errors\n        require(punkIndex < 10000, \"index >= 10000\");\n        punkIndexToAddress[punkIndex] = to;\n        balanceOf[msg.sender]--;\n        balanceOf[to]++;\n        emit Transfer(msg.sender, to, 1);\n        emit PunkTransfer(msg.sender, to, punkIndex);\n    }\n\n    function offerPunkForSaleToAddress(\n        uint256 punkIndex,\n        uint256 minSalePriceInWei,\n        address toAddress\n    ) external override {\n        // solhint-disable-next-line custom-errors\n        require(punkIndexToAddress[punkIndex] == msg.sender, \"sender not owner\");\n        // solhint-disable-next-line custom-errors\n        require(punkIndex < 10000, \"index >= 10000\");\n        punksOfferedForSale[punkIndex] = Offer(true, punkIndex, msg.sender, minSalePriceInWei, toAddress);\n        emit PunkOffered(punkIndex, minSalePriceInWei, toAddress);\n    }\n\n    function buyPunk(uint256 punkIndex) external payable override {\n        Offer memory offer = punksOfferedForSale[punkIndex];\n        // solhint-disable-next-line custom-errors\n        require(punkIndex < 10000, \"index >= 10000\");\n        // solhint-disable-next-line custom-errors\n        require(offer.isForSale, \"punk not for sale\");\n        // solhint-disable-next-line custom-errors\n        require(offer.onlySellTo == address(0) || offer.onlySellTo == msg.sender, \"shouldnt be sold to this user\");\n        // solhint-disable-next-line custom-errors\n        require(msg.value >= offer.minValue, \"not enough ETH sent\");\n        // solhint-disable-next-line custom-errors\n        require(punkIndexToAddress[punkIndex] == offer.seller, \"seller not owner\");\n\n        address seller = offer.seller;\n\n        punkIndexToAddress[punkIndex] = msg.sender;\n        balanceOf[seller]--;\n        balanceOf[msg.sender]++;\n        emit Transfer(seller, msg.sender, 1);\n\n        punkNoLongerForSale(punkIndex);\n        emit PunkBought(punkIndex, msg.value, seller, msg.sender);\n    }\n\n    function punkNoLongerForSale(uint256 punkIndex) public {\n        // solhint-disable-next-line custom-errors\n        require(punkIndexToAddress[punkIndex] == msg.sender, \"sender not owner\");\n        // solhint-disable-next-line custom-errors\n        require(punkIndex < 10000, \"index >= 10000\");\n        punksOfferedForSale[punkIndex] = Offer(false, punkIndex, msg.sender, 0, address(0));\n        emit PunkNoLongerForSale(punkIndex);\n    }\n}\n"
    },
    "contracts/test/TestNftReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {NftReceiver} from \"../utils/NftReceiver.sol\";\n\ncontract TestNftReceiver is NftReceiver {\n    constructor() {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n"
    },
    "contracts/test/TestOwnable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {Ownable} from \"../utils/Ownable.sol\";\n\ncontract TestOwnable is Ownable {\n    constructor(address _admin) Ownable(_admin) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n"
    },
    "contracts/test/TestRealsies.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {ERC20PresetMinterPauser, ERC20} from \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\n/* solhint-disable one-contract-per-file */\n\n/**\n * @title Blacklistable Token\n * @dev Allows accounts to be blacklisted by a \"blacklister\" role\n */\ncontract TestBlacklistable {\n    address public blacklister;\n    mapping(address => bool) internal blacklisted;\n\n    event Blacklisted(address indexed _account);\n    event UnBlacklisted(address indexed _account);\n    event BlacklisterChanged(address indexed newBlacklister);\n\n    /**\n     * @dev Throws if argument account is blacklisted\n     * @param _account The address to check\n     */\n    modifier notBlacklisted(address _account) {\n        // solhint-disable-next-line custom-errors\n        require(!blacklisted[_account], \"Blacklistable: account is blacklisted\");\n        _;\n    }\n\n    /**\n     * @dev Checks if account is blacklisted\n     * @param _account The address to check\n     */\n    function isBlacklisted(address _account) external view returns (bool) {\n        return blacklisted[_account];\n    }\n\n    /**\n     * @dev Adds account to blacklist\n     * @param _account The address to blacklist\n     */\n    function blacklist(address _account) external {\n        blacklisted[_account] = true;\n        emit Blacklisted(_account);\n    }\n\n    /**\n     * @dev Removes account from blacklist\n     * @param _account The address to remove from the blacklist\n     */\n    function unBlacklist(address _account) external {\n        blacklisted[_account] = false;\n        emit UnBlacklisted(_account);\n    }\n\n    function updateBlacklister(address _newBlacklister) external {\n        // solhint-disable-next-line custom-errors\n        require(_newBlacklister != address(0), \"Blacklistable: new blacklister is the zero address\");\n        blacklister = _newBlacklister;\n        emit BlacklisterChanged(blacklister);\n    }\n}\n\ncontract TestRealsies is ERC20PresetMinterPauser, ERC20Permit, TestBlacklistable {\n    constructor() ERC20PresetMinterPauser(\"Realsies\", \"RRR\") ERC20Permit(\"Realsies\") {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20PresetMinterPauser, ERC20) notBlacklisted(from) notBlacklisted(to) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n\n/* solhint-enable one-contract-per-file */\n"
    },
    "contracts/test/TestSignerContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {NftReceiver} from \"../utils/NftReceiver.sol\";\n\ninterface ILoan {\n    function liquidateOverdueLoan(uint32 _loanId) external;\n}\n\n/**\n * @title  TestSignerContract\n * @author NFTfi\n * @notice Test implementation of a signing contract\n */\ncontract TestSignerContract is NftReceiver {\n    address public admin;\n\n    constructor(address _admin) {\n        admin = _admin;\n    }\n\n    function isValidSignature(bytes32 _hash, bytes calldata _signature) external view returns (bytes4) {\n        // Validate signatures\n        if (ECDSA.recover(_hash, _signature) == admin) {\n            return 0x1626ba7e;\n        } else {\n            return 0xffffffff;\n        }\n    }\n\n    function approveNFT(address _token, address _to, uint256 _tokenId) external {\n        IERC721(_token).approve(_to, _tokenId);\n    }\n\n    function approveERC20(address _token, address _to, uint256 _amount) external {\n        IERC20(_token).approve(_to, _amount);\n    }\n\n    function liquidateOverdueLoan(address _loanContract, uint32 _loanId) external {\n        ILoan(_loanContract).liquidateOverdueLoan(_loanId);\n    }\n}\n"
    },
    "contracts/test/TestSigningUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {LoanData} from \"../loans/direct/loanTypes/LoanData.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {NFTfiSigningUtils} from \"../utils/NFTfiSigningUtils.sol\";\n\n/**\n * @title  TestSigningUtils\n * @author NFTfi\n * @notice Wrapping the NFTfiSigningUtils library in a contract so it can be unit tested\n */\ncontract TestSigningUtils {\n    function getChainID() public view returns (uint256) {\n        return NFTfiSigningUtils.getChainID();\n    }\n\n    function isValidLenderSignature(\n        LoanData.Offer memory _offer,\n        LoanData.Signature memory _signature\n    ) public view returns (bool) {\n        return NFTfiSigningUtils.isValidLenderSignature(_offer, _signature);\n    }\n\n    function isValidLenderRenegotiationSignature(\n        uint32 _loanId,\n        uint32 _newLoanDuration,\n        uint256 _newMaximumRepaymentAmount,\n        uint256 _renegotiationFee,\n        LoanData.Signature memory _signature\n    ) public view returns (bool) {\n        return\n            NFTfiSigningUtils.isValidLenderRenegotiationSignature(\n                _loanId,\n                _newLoanDuration,\n                _newMaximumRepaymentAmount,\n                _renegotiationFee,\n                _signature\n            );\n    }\n}\n"
    },
    "contracts/utils/ContractKeys.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\n/**\n * @title ContractKeys\n * @author NFTfi\n * @dev Common library for contract keys\n */\nlibrary ContractKeys {\n    bytes32 public constant PERMITTED_ERC20S = bytes32(\"PERMITTED_ERC20S\");\n    bytes32 public constant PERMITTED_NFTS = bytes32(\"PERMITTED_NFTS\");\n    bytes32 public constant PERMITTED_PARTNERS = bytes32(\"PERMITTED_PARTNERS\");\n    bytes32 public constant NFT_TYPE_REGISTRY = bytes32(\"NFT_TYPE_REGISTRY\");\n    bytes32 public constant LOAN_REGISTRY = bytes32(\"LOAN_REGISTRY\");\n    bytes32 public constant PERMITTED_SNFT_RECEIVER = bytes32(\"PERMITTED_SNFT_RECEIVER\");\n\n    /**\n     * @notice Returns the bytes32 representation of a string\n     * @param _key the string key\n     * @return id bytes32 representation\n     */\n    function getIdFromStringKey(string memory _key) external pure returns (bytes32 id) {\n        // solhint-disable-next-line custom-errors\n        require(bytes(_key).length <= 32, \"invalid key\");\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := mload(add(_key, 32))\n        }\n    }\n}\n"
    },
    "contracts/utils/NFTfiCollectionOfferSigningUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {LoanData} from \"../loans/direct/loanTypes/LoanData.sol\";\nimport {SignatureChecker, ECDSA} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\n/**\n * @title  NFTfiCollectionOfferSigningUtils\n * @author NFTfi\n * @notice Helper contract for NFTfi. This contract manages verifying signatures from off-chain NFTfi orders.\n * Based on the version of this same contract used on NFTfi V1\n */\nlibrary NFTfiCollectionOfferSigningUtils {\n    /* ********* */\n    /* FUNCTIONS */\n    /* ********* */\n\n    /**\n     * @dev This function gets the current chain ID.\n     */\n    function getChainID() internal view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    /**\n     * @notice This function is when the borrower accepts a lender's offer, to validate the lender's signature that the\n     * lender provided off-chain to verify that it did indeed made such offer.\n     *\n     * @param _offer - The offer struct containing:\n     * - loanERC20Denomination: The address of the ERC20 contract of the currency being used as principal/interest\n     * for this loan.\n     * - loanPrincipalAmount: The original sum of money transferred from lender to borrower at the beginning of\n     * the loan, measured in loanERC20Denomination's smallest units.\n     * - maximumRepaymentAmount: The maximum amount of money that the borrower would be required to retrieve their\n     * collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have\n     * to pay this amount to retrieve their collateral, regardless of whether they repay early.\n     * - nftCollateralContract: The address of the ERC721 contract of the NFT collateral.\n     * - nftCollateralId: The ID within the NFTCollateralContract for the NFT being used as collateral for this\n     * loan. The NFT is stored within this contract during the duration of the loan.\n     * - referrer: The address of the referrer who found the lender matching the listing, Zero address to signal\n     * this there is no referrer.\n     * - loanDuration: The amount of time (measured in seconds) that can elapse before the lender can liquidate the\n     * loan and seize the underlying collateral NFT.\n     * - loanInterestRateForDurationInBasisPoints: This is the interest rate (measured in basis points, e.g.\n     * hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan\n     * or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and\n     * is irrelevant so it should be set to 0.\n     * - loanAdminFeeInBasisPoints: The percent (measured in basis points) of the interest earned that will be\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\n     * earned.\n     * @param _idRange - min and max (inclusive) Id ranges for collection offers on collections,\n     * like ArtBlocks, where multiple collections are defined on one contract differentiated by id-ranges\n     * @param _signature - The signature structure containing:\n     * - signer: The address of the signer. The borrower for `acceptOffer`\n     * - nonce: The nonce referred here is not the same as an Ethereum account's nonce.\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\n     * off-chain order. Each nonce can be used at most once peruser within NFTfi, regardless of whether they are the\n     * lender or the borrower in that situation. This serves two purposes:\n     *   - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\n     *   - Second, it allows a user to cancel an off-chain order by calling\n     * NFTfi.cancelLoanCommitmentBeforeLoanHasBegun(), which marks the nonce as used and prevents any future loan from\n     * using the user's off-chain order that contains that nonce.\n     * - expiry: Date when the signature expires\n     * - signature: The ECDSA signature of the lender, obtained off-chain ahead of time, signing the following\n     * combination of parameters:\n     *   - offer.loanERC20Denomination\n     *   - offer.loanPrincipalAmount\n     *   - offer.maximumRepaymentAmount\n     *   - offer.nftCollateralContract\n     *   - offer.nftCollateralId\n     *   - offer.referrer\n     *   - offer.loanDuration\n     *   - offer.loanAdminFeeInBasisPoints,\n     *   - idRange.minId,\n     *   - idRange.maxId,\n     *   - signature.signer,\n     *   - signature.nonce,\n     *   - signature.expiry,\n     *   - address of this contract\n     *   - chainId\n     */\n    function isValidLenderSignatureWithIdRange(\n        LoanData.Offer memory _offer,\n        LoanData.CollectionIdRange memory _idRange,\n        LoanData.Signature memory _signature\n    ) internal view returns (bool) {\n        return isValidLenderSignatureWithIdRange(_offer, _idRange, _signature, address(this));\n    }\n\n    /**\n     * @dev This function overload the previous function to allow the caller to specify the address of the contract\n     *\n     */\n    function isValidLenderSignatureWithIdRange(\n        LoanData.Offer memory _offer,\n        LoanData.CollectionIdRange memory _idRange,\n        LoanData.Signature memory _signature,\n        address _loanContract\n    ) internal view returns (bool) {\n        // solhint-disable-next-line custom-errors\n        require(block.timestamp <= _signature.expiry, \"Lender Signature has expired\");\n        // solhint-disable-next-line custom-errors\n        require(_loanContract != address(0), \"Loan is zero address\");\n        if (_signature.signer == address(0)) {\n            return false;\n        } else {\n            bytes32 message = keccak256(\n                abi.encodePacked(\n                    getEncodedOffer(_offer),\n                    abi.encodePacked(_idRange.minId, _idRange.maxId),\n                    getEncodedSignature(_signature),\n                    _loanContract,\n                    getChainID()\n                )\n            );\n\n            return\n                SignatureChecker.isValidSignatureNow(\n                    _signature.signer,\n                    ECDSA.toEthSignedMessageHash(message),\n                    _signature.signature\n                );\n        }\n    }\n\n    /**\n     * @dev We need this to avoid stack too deep errors.\n     */\n    function getEncodedOffer(LoanData.Offer memory _offer) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _offer.loanERC20Denomination,\n                _offer.loanPrincipalAmount,\n                _offer.maximumRepaymentAmount,\n                _offer.nftCollateralContract,\n                _offer.nftCollateralId,\n                _offer.referrer,\n                _offer.loanDuration,\n                _offer.loanAdminFeeInBasisPoints\n            );\n    }\n\n    /**\n     * @dev We need this to avoid stack too deep errors.\n     */\n    function getEncodedSignature(LoanData.Signature memory _signature) internal pure returns (bytes memory) {\n        return abi.encodePacked(_signature.signer, _signature.nonce, _signature.expiry);\n    }\n}\n"
    },
    "contracts/utils/NFTfiCollectionOfferSigningUtilsContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {NFTfiCollectionOfferSigningUtils} from \"./NFTfiCollectionOfferSigningUtils.sol\";\nimport {LoanData} from \"../loans/direct/loanTypes/LoanData.sol\";\n\n/**\n * @title  NFTfiCollectionOfferSigningUtilsContract\n * @author NFTfi\n * @notice Helper contract for NFTfi. This contract manages verifying signatures from off-chain NFTfi orders.\n * Based on the version of this same contract used on NFTfi V1\n */\ncontract NFTfiCollectionOfferSigningUtilsContract {\n    /* ********* */\n    /* FUNCTIONS */\n    /* ********* */\n\n    /**\n     * @dev This function overload the previous function to allow the caller to specify the address of the contract\n     *\n     */\n    function isValidLenderSignatureWithIdRange(\n        LoanData.Offer memory _offer,\n        LoanData.CollectionIdRange memory _idRange,\n        LoanData.Signature memory _signature,\n        address _loanContract\n    ) public view returns (bool) {\n        return\n            NFTfiCollectionOfferSigningUtils.isValidLenderSignatureWithIdRange(\n                _offer,\n                _idRange,\n                _signature,\n                _loanContract\n            );\n    }\n}\n"
    },
    "contracts/utils/NFTfiSigningUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {LoanData} from \"../loans/direct/loanTypes/LoanData.sol\";\nimport {SignatureChecker, ECDSA} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\n/**\n * @title  NFTfiSigningUtils\n * @author NFTfi\n * @notice Helper contract for NFTfi. This contract manages verifying signatures from off-chain NFTfi orders.\n * Based on the version of this same contract used on NFTfi V1\n */\nlibrary NFTfiSigningUtils {\n    /* ********* */\n    /* FUNCTIONS */\n    /* ********* */\n\n    /**\n     * @dev This function gets the current chain ID.\n     */\n    function getChainID() internal view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    /**\n     * @notice This function is when the borrower accepts a lender's offer, to validate the lender's signature that the\n     * lender provided off-chain to verify that it did indeed made such offer.\n     *\n     * @param _offer - The offer struct containing:\n     * - loanERC20Denomination: The address of the ERC20 contract of the currency being used as principal/interest\n     * for this loan.\n     * - loanPrincipalAmount: The original sum of money transferred from lender to borrower at the beginning of\n     * the loan, measured in loanERC20Denomination's smallest units.\n     * - maximumRepaymentAmount: The maximum amount of money that the borrower would be required to retrieve their\n     * collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have\n     * to pay this amount to retrieve their collateral, regardless of whether they repay early.\n     * - nftCollateralContract: The address of the ERC721 contract of the NFT collateral.\n     * - nftCollateralId: The ID within the NFTCollateralContract for the NFT being used as collateral for this\n     * loan. The NFT is stored within this contract during the duration of the loan.\n     * - referrer: The address of the referrer who found the lender matching the listing, Zero address to signal\n     * this there is no referrer.\n     * - loanDuration: The amount of time (measured in seconds) that can elapse before the lender can liquidate the\n     * loan and seize the underlying collateral NFT.\n     * - loanInterestRateForDurationInBasisPoints: This is the interest rate (measured in basis points, e.g.\n     * hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan\n     * or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and\n     * is irrelevant so it should be set to 0.\n     * - loanAdminFeeInBasisPoints: The percent (measured in basis points) of the interest earned that will be\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\n     * earned.\n     * @param _signature - The signature structure containing:\n     * - signer: The address of the signer. The borrower for `acceptOffer`\n     * - nonce: The nonce referred here is not the same as an Ethereum account's nonce.\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\n     * off-chain order. Each nonce can be used at most once peruser within NFTfi, regardless of whether they are the\n     * lender or the borrower in that situation. This serves two purposes:\n     *   - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\n     *   - Second, it allows a user to cancel an off-chain order by calling\n     * NFTfi.cancelLoanCommitmentBeforeLoanHasBegun(), which marks the nonce as used and prevents any future loan from\n     * using the user's off-chain order that contains that nonce.\n     * - expiry: Date when the signature expires\n     * - signature: The ECDSA signature of the lender, obtained off-chain ahead of time, signing the following\n     * combination of parameters:\n     *   - offer.loanERC20Denomination\n     *   - offer.loanPrincipalAmount\n     *   - offer.maximumRepaymentAmount\n     *   - offer.nftCollateralContract\n     *   - offer.nftCollateralId\n     *   - offer.referrer\n     *   - offer.loanDuration\n     *   - offer.loanAdminFeeInBasisPoints\n     *   - signature.signer,\n     *   - signature.nonce,\n     *   - signature.expiry,\n     *   - address of this contract\n     *   - chainId\n     */\n    function isValidLenderSignature(\n        LoanData.Offer memory _offer,\n        LoanData.Signature memory _signature\n    ) external view returns (bool) {\n        return isValidLenderSignature(_offer, _signature, address(this));\n    }\n\n    /**\n     * @dev This function overload the previous function to allow the caller to specify the address of the contract\n     *\n     */\n    function isValidLenderSignature(\n        LoanData.Offer memory _offer,\n        LoanData.Signature memory _signature,\n        address _loanContract\n    ) public view returns (bool) {\n        // solhint-disable-next-line custom-errors\n        require(block.timestamp <= _signature.expiry, \"Lender Signature has expired\");\n        // solhint-disable-next-line custom-errors\n        require(_loanContract != address(0), \"Loan is zero address\");\n        if (_signature.signer == address(0)) {\n            return false;\n        } else {\n            bytes32 message = keccak256(\n                abi.encodePacked(getEncodedOffer(_offer), getEncodedSignature(_signature), _loanContract, getChainID())\n            );\n\n            return\n                SignatureChecker.isValidSignatureNow(\n                    _signature.signer,\n                    ECDSA.toEthSignedMessageHash(message),\n                    _signature.signature\n                );\n        }\n    }\n\n    /**\n     * @notice This function is called in renegotiateLoan() to validate the lender's signature that the lender provided\n     * off-chain to verify that they did indeed want to agree to this loan renegotiation according to these terms.\n     *\n     * @param _loanId - The unique identifier for the loan to be renegotiated\n     * @param _newLoanDuration - The new amount of time (measured in seconds) that can elapse before the lender can\n     * liquidate the loan and seize the underlying collateral NFT.\n     * @param _newMaximumRepaymentAmount - The new maximum amount of money that the borrower would be required to\n     * retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The\n     * borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay\n     * early.\n     * @param _renegotiationFee Agreed upon fee in ether that borrower pays for the lender for the renegitiation\n     * @param _signature - The signature structure containing:\n     * - signer: The address of the signer. The borrower for `acceptOffer`\n     * - nonce: The nonce referred here is not the same as an Ethereum account's nonce.\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\n     * off-chain order. Each nonce can be used at most once peruser within NFTfi, regardless of whether they are the\n     * lender or the borrower in that situation. This serves two purposes:\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\n     * , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\n     * that nonce.\n     * - expiry - The date when the renegotiation offer expires\n     * - lenderSignature - The ECDSA signature of the lender, obtained off-chain ahead of time, signing the\n     * following combination of parameters:\n     * - _loanId\n     * - _newLoanDuration\n     * - _newMaximumRepaymentAmount\n     * - _lender\n     * - _lenderNonce\n     * - _expiry\n     * - address of this contract\n     * - chainId\n     */\n    function isValidLenderRenegotiationSignature(\n        uint256 _loanId,\n        uint32 _newLoanDuration,\n        uint256 _newMaximumRepaymentAmount,\n        uint256 _renegotiationFee,\n        LoanData.Signature memory _signature\n    ) external view returns (bool) {\n        return\n            isValidLenderRenegotiationSignature(\n                _loanId,\n                _newLoanDuration,\n                _newMaximumRepaymentAmount,\n                _renegotiationFee,\n                _signature,\n                address(this)\n            );\n    }\n\n    /**\n     * @dev This function overload the previous function to allow the caller to specify the address of the contract\n     *\n     */\n    function isValidLenderRenegotiationSignature(\n        uint256 _loanId,\n        uint32 _newLoanDuration,\n        uint256 _newMaximumRepaymentAmount,\n        uint256 _renegotiationFee,\n        LoanData.Signature memory _signature,\n        address _loanContract\n    ) public view returns (bool) {\n        // solhint-disable-next-line custom-errors\n        require(block.timestamp <= _signature.expiry, \"Renegotiation Signature expired\");\n        // solhint-disable-next-line custom-errors\n        require(_loanContract != address(0), \"Loan is zero address\");\n        if (_signature.signer == address(0)) {\n            return false;\n        } else {\n            bytes32 message = keccak256(\n                abi.encodePacked(\n                    _loanId,\n                    _newLoanDuration,\n                    _newMaximumRepaymentAmount,\n                    _renegotiationFee,\n                    getEncodedSignature(_signature),\n                    _loanContract,\n                    getChainID()\n                )\n            );\n\n            return\n                SignatureChecker.isValidSignatureNow(\n                    _signature.signer,\n                    ECDSA.toEthSignedMessageHash(message),\n                    _signature.signature\n                );\n        }\n    }\n\n    /**\n     * @dev We need this to avoid stack too deep errors.\n     */\n    function getEncodedOffer(LoanData.Offer memory _offer) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _offer.loanERC20Denomination,\n                _offer.loanPrincipalAmount,\n                _offer.maximumRepaymentAmount,\n                _offer.nftCollateralContract,\n                _offer.nftCollateralId,\n                _offer.referrer,\n                _offer.loanDuration,\n                _offer.loanAdminFeeInBasisPoints\n            );\n    }\n\n    /**\n     * @dev We need this to avoid stack too deep errors.\n     */\n    function getEncodedSignature(LoanData.Signature memory _signature) internal pure returns (bytes memory) {\n        return abi.encodePacked(_signature.signer, _signature.nonce, _signature.expiry);\n    }\n}\n"
    },
    "contracts/utils/NFTfiSigningUtilsContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {NFTfiSigningUtils} from \"./NFTfiSigningUtils.sol\";\nimport {LoanData} from \"../loans/direct/loanTypes/LoanData.sol\";\n\n/**\n * @title  NFTfiSigningUtilsContract\n * @author NFTfi\n * @notice Helper contract for NFTfi. This contract manages externally verifying signatures from off-chain NFTfi orders.\n */\ncontract NFTfiSigningUtilsContract {\n    /* ********* */\n    /* FUNCTIONS */\n    /* ********* */\n\n    /**\n     * @notice This function is when the borrower accepts a lender's offer, to validate the lender's signature that the\n     * lender provided off-chain to verify that it did indeed made such offer.\n     *\n     * @param _offer - The offer struct containing:\n     * - loanERC20Denomination: The address of the ERC20 contract of the currency being used as principal/interest\n     * for this loan.\n     * - loanPrincipalAmount: The original sum of money transferred from lender to borrower at the beginning of\n     * the loan, measured in loanERC20Denomination's smallest units.\n     * - maximumRepaymentAmount: The maximum amount of money that the borrower would be required to retrieve their\n     * collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have\n     * to pay this amount to retrieve their collateral, regardless of whether they repay early.\n     * - nftCollateralContract: The address of the ERC721 contract of the NFT collateral.\n     * - nftCollateralId: The ID within the NFTCollateralContract for the NFT being used as collateral for this\n     * loan. The NFT is stored within this contract during the duration of the loan.\n     * - referrer: The address of the referrer who found the lender matching the listing, Zero address to signal\n     * this there is no referrer.\n     * - loanDuration: The amount of time (measured in seconds) that can elapse before the lender can liquidate the\n     * loan and seize the underlying collateral NFT.\n     * - loanInterestRateForDurationInBasisPoints: This is the interest rate (measured in basis points, e.g.\n     * hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan\n     * or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and\n     * is irrelevant so it should be set to 0.\n     * - loanAdminFeeInBasisPoints: The percent (measured in basis points) of the interest earned that will be\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\n     * earned.\n     * @param _signature - The signature structure containing:\n     * - signer: The address of the signer. The borrower for `acceptOffer`\n     * - nonce: The nonce referred here is not the same as an Ethereum account's nonce.\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\n     * off-chain order. Each nonce can be used at most once peruser within NFTfi, regardless of whether they are the\n     * lender or the borrower in that situation. This serves two purposes:\n     *   - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\n     *   - Second, it allows a user to cancel an off-chain order by calling\n     * NFTfi.cancelLoanCommitmentBeforeLoanHasBegun(), which marks the nonce as used and prevents any future loan from\n     * using the user's off-chain order that contains that nonce.\n     * - expiry: Date when the signature expires\n     * - signature: The ECDSA signature of the lender, obtained off-chain ahead of time, signing the following\n     * combination of parameters:\n     *   - offer.loanERC20Denomination\n     *   - offer.loanPrincipalAmount\n     *   - offer.maximumRepaymentAmount\n     *   - offer.nftCollateralContract\n     *   - offer.nftCollateralId\n     *   - offer.referrer\n     *   - offer.loanDuration\n     *   - offer.loanAdminFeeInBasisPoints\n     *   - signature.signer,\n     *   - signature.nonce,\n     *   - signature.expiry,\n     *   - loan contract address,\n     *   - chainId\n     * @param _loanContract - Address of the loan contract where the signature is going to be used\n     */\n    function isValidLenderSignature(\n        LoanData.Offer memory _offer,\n        LoanData.Signature memory _signature,\n        address _loanContract\n    ) external view returns (bool) {\n        return NFTfiSigningUtils.isValidLenderSignature(_offer, _signature, _loanContract);\n    }\n\n    /**\n     * @notice This function is called in renegotiateLoan() to validate the lender's signature that the lender provided\n     * off-chain to verify that they did indeed want to agree to this loan renegotiation according to these terms.\n     *\n     * @param _loanId - The unique identifier for the loan to be renegotiated\n     * @param _newLoanDuration - The new amount of time (measured in seconds) that can elapse before the lender can\n     * liquidate the loan and seize the underlying collateral NFT.\n     * @param _newMaximumRepaymentAmount - The new maximum amount of money that the borrower would be required to\n     * retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The\n     * borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay\n     * early.\n     * @param _renegotiationFee Agreed upon fee in ether that borrower pays for the lender for the renegitiation\n     * @param _signature - The signature structure containing:\n     * - signer: The address of the signer. The borrower for `acceptOffer`\n     * - nonce: The nonce referred here is not the same as an Ethereum account's nonce.\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\n     * off-chain order. Each nonce can be used at most once peruser within NFTfi, regardless of whether they are the\n     * lender or the borrower in that situation. This serves two purposes:\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\n     * , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\n     * that nonce.\n     * - expiry - The date when the renegotiation offer expires\n     * - lenderSignature - The ECDSA signature of the lender, obtained off-chain ahead of time, signing the\n     * following combination of parameters:\n     * - _loanId\n     * - _newLoanDuration\n     * - _newMaximumRepaymentAmount\n     * - _lender\n     * - _lenderNonce\n     * - _expiry\n     *  - loan contract address,\n     * - chainId\n     * @param _loanContract - Address of the loan contract where the signature is going to be used\n     */\n    function isValidLenderRenegotiationSignature(\n        uint256 _loanId,\n        uint32 _newLoanDuration,\n        uint256 _newMaximumRepaymentAmount,\n        uint256 _renegotiationFee,\n        LoanData.Signature memory _signature,\n        address _loanContract\n    ) external view returns (bool) {\n        return\n            NFTfiSigningUtils.isValidLenderRenegotiationSignature(\n                _loanId,\n                _newLoanDuration,\n                _newMaximumRepaymentAmount,\n                _renegotiationFee,\n                _signature,\n                _loanContract\n            );\n    }\n}\n"
    },
    "contracts/utils/NftReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {IERC1155Receiver, IERC165} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {ERC721Holder, IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\n/**\n * @title NftReceiver\n * @author NFTfi\n * @dev Base contract with capabilities for receiving ERC1155 and ERC721 tokens\n */\nabstract contract NftReceiver is IERC1155Receiver, ERC721Holder {\n    /**\n     *  @dev Handles the receipt of a single ERC1155 token type. This function is called at the end of a\n     * `safeTransferFrom` after the balance has been updated.\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if allowed\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     *  @dev Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a\n     * `safeBatchTransferFrom` after the balances have been updated.\n     *  @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if allowed\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual override returns (bytes4) {\n        // solhint-disable-next-line custom-errors\n        revert(\"ERC1155 batch not supported\");\n    }\n\n    /**\n     * @dev Checks whether this contract implements the interface defined by `interfaceId`.\n     * @param _interfaceId Id of the interface\n     * @return true if this contract implements the interface\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IERC1155Receiver).interfaceId ||\n            _interfaceId == type(IERC721Receiver).interfaceId ||\n            _interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\n * Modified version from openzeppelin/contracts/access/Ownable.sol that allows to\n * initialize the owner using a parameter in the constructor\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    address private _ownerCandidate;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        // solhint-disable-next-line custom-errors\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor(address _initialOwner) {\n        _setOwner(_initialOwner);\n    }\n\n    /**\n     * @dev Requests transferring ownership of the contract to a new account (`_newOwnerCandidate`).\n     * Can only be called by the current owner.\n     */\n    function requestTransferOwnership(address _newOwnerCandidate) public virtual onlyOwner {\n        // solhint-disable-next-line custom-errors\n        require(_newOwnerCandidate != address(0), \"Ownable: new owner is the zero address\");\n        _ownerCandidate = _newOwnerCandidate;\n    }\n\n    function acceptTransferOwnership() public virtual {\n        // solhint-disable-next-line custom-errors\n        require(_ownerCandidate == _msgSender(), \"Ownable: not owner candidate\");\n        _setOwner(_ownerCandidate);\n        delete _ownerCandidate;\n    }\n\n    function cancelTransferOwnership() public virtual onlyOwner {\n        delete _ownerCandidate;\n    }\n\n    function rejectTransferOwnership() public virtual {\n        // solhint-disable-next-line custom-errors\n        require(_ownerCandidate == _msgSender(), \"Ownable: not owner candidate\");\n        delete _ownerCandidate;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Sets the owner.\n     */\n    function _setOwner(address _newOwner) internal {\n        address oldOwner = _owner;\n        _owner = _newOwner;\n        emit OwnershipTransferred(oldOwner, _newOwner);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    }
  }
}
