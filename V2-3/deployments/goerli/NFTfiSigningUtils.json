{
  "address": "0x69890a5B92C8a21EF3539622Cd2881Ea65b8b8fB",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_loanId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "_newLoanDuration",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "_newMaximumRepaymentAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_renegotiationFee",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "signer",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct LoanData.Signature",
          "name": "_signature",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "_loanContract",
          "type": "address"
        }
      ],
      "name": "isValidLenderRenegotiationSignature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_loanId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "_newLoanDuration",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "_newMaximumRepaymentAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_renegotiationFee",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "signer",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct LoanData.Signature",
          "name": "_signature",
          "type": "tuple"
        }
      ],
      "name": "isValidLenderRenegotiationSignature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "loanPrincipalAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maximumRepaymentAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nftCollateralId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "nftCollateralContract",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "loanDuration",
              "type": "uint32"
            },
            {
              "internalType": "uint16",
              "name": "loanAdminFeeInBasisPoints",
              "type": "uint16"
            },
            {
              "internalType": "address",
              "name": "loanERC20Denomination",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "referrer",
              "type": "address"
            }
          ],
          "internalType": "struct LoanData.Offer",
          "name": "_offer",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "signer",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct LoanData.Signature",
          "name": "_signature",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "_loanContract",
          "type": "address"
        }
      ],
      "name": "isValidLenderSignature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "loanPrincipalAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maximumRepaymentAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nftCollateralId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "nftCollateralContract",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "loanDuration",
              "type": "uint32"
            },
            {
              "internalType": "uint16",
              "name": "loanAdminFeeInBasisPoints",
              "type": "uint16"
            },
            {
              "internalType": "address",
              "name": "loanERC20Denomination",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "referrer",
              "type": "address"
            }
          ],
          "internalType": "struct LoanData.Offer",
          "name": "_offer",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "signer",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct LoanData.Signature",
          "name": "_signature",
          "type": "tuple"
        }
      ],
      "name": "isValidLenderSignature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x090d497270784742110e623a6034f215d496572fd48ca134a505a46bb510ce30",
  "receipt": {
    "to": null,
    "from": "0x02e037F56728E947e92Af2c05baF7FeF387Ddd06",
    "contractAddress": "0x69890a5B92C8a21EF3539622Cd2881Ea65b8b8fB",
    "transactionIndex": 10,
    "gasUsed": "692808",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x726a072f25e935c395fabba0110a9f9a063f271e579d5b9eeebeb41348f1452d",
    "transactionHash": "0x090d497270784742110e623a6034f215d496572fd48ca134a505a46bb510ce30",
    "logs": [],
    "blockNumber": 9762994,
    "cumulativeGasUsed": "4778285",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "103c7252f85cc80233118bf16e4e3c05",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_newLoanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_newMaximumRepaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_renegotiationFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LoanData.Signature\",\"name\":\"_signature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_loanContract\",\"type\":\"address\"}],\"name\":\"isValidLenderRenegotiationSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_newLoanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_newMaximumRepaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_renegotiationFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LoanData.Signature\",\"name\":\"_signature\",\"type\":\"tuple\"}],\"name\":\"isValidLenderRenegotiationSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRepaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"loanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"loanAdminFeeInBasisPoints\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"loanERC20Denomination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"internalType\":\"struct LoanData.Offer\",\"name\":\"_offer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LoanData.Signature\",\"name\":\"_signature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_loanContract\",\"type\":\"address\"}],\"name\":\"isValidLenderSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRepaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"loanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"loanAdminFeeInBasisPoints\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"loanERC20Denomination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"internalType\":\"struct LoanData.Offer\",\"name\":\"_offer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LoanData.Signature\",\"name\":\"_signature\",\"type\":\"tuple\"}],\"name\":\"isValidLenderSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"NFTfi\",\"kind\":\"dev\",\"methods\":{\"isValidLenderRenegotiationSignature(uint256,uint32,uint256,uint256,LoanData.Signature)\":{\"params\":{\"_loanId\":\"- The unique identifier for the loan to be renegotiated\",\"_newLoanDuration\":\"- The new amount of time (measured in seconds) that can elapse before the lender can liquidate the loan and seize the underlying collateral NFT.\",\"_newMaximumRepaymentAmount\":\"- The new maximum amount of money that the borrower would be required to retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay early.\",\"_renegotiationFee\":\"Agreed upon fee in ether that borrower pays for the lender for the renegitiation\",\"_signature\":\"- The signature structure containing: - signer: The address of the signer. The borrower for `acceptOffer` - nonce: The nonce referred here is not the same as an Ethereum account's nonce. We are referring instead to a nonce that is used by the lender or the borrower when they are first signing off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an off-chain order. Each nonce can be used at most once per\\u00a0user within NFTfi, regardless of whether they are the lender or the borrower in that situation. This serves two purposes: - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once. - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun() , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains that nonce. - expiry - The date when the renegotiation offer expires - lenderSignature - The ECDSA signature of the lender, obtained off-chain ahead of time, signing the following combination of parameters: - _loanId - _newLoanDuration - _newMaximumRepaymentAmount - _lender - _lenderNonce - _expiry - address of this contract - chainId\"}},\"isValidLenderRenegotiationSignature(uint256,uint32,uint256,uint256,LoanData.Signature,address)\":{\"details\":\"This function overload the previous function to allow the caller to specify the address of the contract\"},\"isValidLenderSignature(LoanData.Offer,LoanData.Signature)\":{\"params\":{\"_offer\":\"- The offer struct containing: - loanERC20Denomination: The address of the ERC20 contract of the currency being used as principal/interest for this loan. - loanPrincipalAmount: The original sum of money transferred from lender to borrower at the beginning of the loan, measured in loanERC20Denomination's smallest units. - maximumRepaymentAmount: The maximum amount of money that the borrower would be required to retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay early. - nftCollateralContract: The address of the ERC721 contract of the NFT collateral. - nftCollateralId: The ID within the NFTCollateralContract for the NFT being used as collateral for this loan. The NFT is stored within this contract during the duration of the loan. - referrer: The address of the referrer who found the lender matching the listing, Zero address to signal this there is no referrer. - loanDuration: The amount of time (measured in seconds) that can elapse before the lender can liquidate the loan and seize the underlying collateral NFT. - loanInterestRateForDurationInBasisPoints: This is the interest rate (measured in basis points, e.g. hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and is irrelevant so it should be set to 0. - loanAdminFeeInBasisPoints: The percent (measured in basis points) of the interest earned that will be taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest earned.\",\"_signature\":\"- The signature structure containing: - signer: The address of the signer. The borrower for `acceptOffer` - nonce: The nonce referred here is not the same as an Ethereum account's nonce. We are referring instead to a nonce that is used by the lender or the borrower when they are first signing off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an off-chain order. Each nonce can be used at most once per\\u00a0user within NFTfi, regardless of whether they are the lender or the borrower in that situation. This serves two purposes:   - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.   - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun(), which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains that nonce. - expiry: Date when the signature expires - signature: The ECDSA signature of the lender, obtained off-chain ahead of time, signing the following combination of parameters:   - offer.loanERC20Denomination   - offer.loanPrincipalAmount   - offer.maximumRepaymentAmount   - offer.nftCollateralContract   - offer.nftCollateralId   - offer.referrer   - offer.loanDuration   - offer.loanAdminFeeInBasisPoints   - signature.signer,   - signature.nonce,   - signature.expiry,   - address of this contract   - chainId\"}},\"isValidLenderSignature(LoanData.Offer,LoanData.Signature,address)\":{\"details\":\"This function overload the previous function to allow the caller to specify the address of the contract\"}},\"title\":\"NFTfiSigningUtils\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"isValidLenderRenegotiationSignature(uint256,uint32,uint256,uint256,LoanData.Signature)\":{\"notice\":\"This function is called in renegotiateLoan() to validate the lender's signature that the lender provided off-chain to verify that they did indeed want to agree to this loan renegotiation according to these terms.\"},\"isValidLenderSignature(LoanData.Offer,LoanData.Signature)\":{\"notice\":\"This function is when the borrower accepts a lender's offer, to validate the lender's signature that the lender provided off-chain to verify that it did indeed made such offer.\"}},\"notice\":\"Helper contract for NFTfi. This contract manages verifying signatures from off-chain NFTfi orders. Based on the version of this same contract used on NFTfi V1\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/utils/NFTfiSigningUtils.sol\":\"NFTfiSigningUtils\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x0705a4b1b86d7b0bd8432118f226ba139c44b9dcaba0a6eafba2dd7d0639c544\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0x809bc3edb4bcbef8263fa616c1b60ee0004b50a8a1bfa164d8f57fd31f520c58\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        return\\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\\n            isValidERC1271SignatureNow(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\\n     * against the signer smart contract using ERC1271.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidERC1271SignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\",\"keccak256\":\"0x3af3ca86df39aac39a0514c84459d691434a108d2151c8ce9d69f32e315cab80\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"contracts/loans/direct/loanTypes/LoanData.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title  LoanData\\n * @author NFTfi\\n * @notice An interface containg the main Loan struct shared by Direct Loans types.\\n */\\ninterface LoanData {\\n    /* ********** */\\n    /* DATA TYPES */\\n    /* ********** */\\n\\n    /**\\n     * @notice The main Loan Terms struct. This data is saved upon loan creation.\\n     *\\n     * @param loanERC20Denomination - The address of the ERC20 contract of the currency being used as principal/interest\\n     * for this loan.\\n     * @param loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * @param maximumRepaymentAmount - The maximum amount of money that the borrower would be required to retrieve their\\n     * collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have\\n     * to pay this amount to retrieve their collateral, regardless of whether they repay early.\\n     * @param nftCollateralContract - The address of the the NFT collateral contract.\\n     * @param nftCollateralWrapper - The NFTfi wrapper of the NFT collateral contract.\\n     * @param nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\\n     * loan. The NFT is stored within this contract during the duration of the loan.\\n     * @param loanStartTime - The block.timestamp when the loan first began (measured in seconds).\\n     * @param loanDuration - The amount of time (measured in seconds) that can elapse before the lender can liquidate\\n     * the loan and seize the underlying collateral NFT.\\n     * @param loanInterestRateForDurationInBasisPoints - This is the interest rate (measured in basis points, e.g.\\n     * hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan\\n     * or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and\\n     * is irrelevant so it should be set to 0.\\n     * @param loanAdminFeeInBasisPoints - The percent (measured in basis points) of the interest earned that will be\\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\\n     * earned.\\n     * @param borrower\\n     */\\n    struct LoanTerms {\\n        uint256 loanPrincipalAmount;\\n        uint256 maximumRepaymentAmount;\\n        uint256 nftCollateralId;\\n        address loanERC20Denomination;\\n        uint32 loanDuration;\\n        uint16 loanInterestRateForDurationInBasisPoints;\\n        uint16 loanAdminFeeInBasisPoints;\\n        address nftCollateralWrapper;\\n        uint64 loanStartTime;\\n        address nftCollateralContract;\\n        address borrower;\\n    }\\n\\n    /**\\n     * @notice Some extra Loan's settings struct. This data is saved upon loan creation.\\n     * We need this to avoid stack too deep errors.\\n     *\\n     * @param revenueSharePartner - The address of the partner that will receive the revenue share.\\n     * @param revenueShareInBasisPoints - The percent (measured in basis points) of the admin fee amount that will be\\n     * taken as a revenue share for a t\\n     * @param referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.he partner, at the moment\\n     * the loan is begun.\\n     */\\n    struct LoanExtras {\\n        address revenueSharePartner;\\n        uint16 revenueShareInBasisPoints;\\n        uint16 referralFeeInBasisPoints;\\n    }\\n\\n    /**\\n     * @notice The offer made by the lender. Used as parameter on both acceptOffer (initiated by the borrower)\\n     *\\n     * @param loanERC20Denomination - The address of the ERC20 contract of the currency being used as principal/interest\\n     * for this loan.\\n     * @param loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * @param maximumRepaymentAmount - The maximum amount of money that the borrower would be required to retrieve their\\n     *  collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always\\n     * have to pay this amount to retrieve their collateral, regardless of whether they repay early.\\n     * @param nftCollateralContract - The address of the ERC721 contract of the NFT collateral.\\n     * @param nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\\n     * loan. The NFT is stored within this contract during the duration of the loan.\\n     * @param referrer - The address of the referrer who found the lender matching the listing, Zero address to signal\\n     * this there is no referrer.\\n     * @param loanDuration - The amount of time (measured in seconds) that can elapse before the lender can liquidate\\n     * the loan and seize the underlying collateral NFT.\\n     * @param loanAdminFeeInBasisPoints - The percent (measured in basis points) of the interest earned that will be\\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\\n     * earned.\\n     */\\n    struct Offer {\\n        uint256 loanPrincipalAmount;\\n        uint256 maximumRepaymentAmount;\\n        uint256 nftCollateralId;\\n        address nftCollateralContract;\\n        uint32 loanDuration;\\n        uint16 loanAdminFeeInBasisPoints;\\n        address loanERC20Denomination;\\n        address referrer;\\n    }\\n\\n    /**\\n     * @notice Signature related params. Used as parameter on both acceptOffer (containing borrower signature)\\n     *\\n     * @param signer - The address of the signer. The borrower for `acceptOffer`\\n     * @param nonce - The nonce referred here is not the same as an Ethereum account's nonce.\\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\\n     * off-chain order. Each nonce can be used at most once per\\u00a0user within NFTfi, regardless of whether they are the\\n     * lender or the borrower in that situation. This serves two purposes:\\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\\n     * , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\\n     * that nonce.\\n     * @param expiry - Date when the signature expires\\n     * @param signature - The ECDSA signature of the borrower or the lender, obtained off-chain ahead of time, signing\\n     * the following combination of parameters:\\n     * - Lender:\\n     *   - Offer.loanERC20Denomination\\n     *   - Offer.loanPrincipalAmount\\n     *   - Offer.maximumRepaymentAmount\\n     *   - Offer.nftCollateralContract\\n     *   - Offer.nftCollateralId\\n     *   - Offer.referrer\\n     *   - Offer.loanDuration\\n     *   - Offer.loanAdminFeeInBasisPoints\\n     *   - Signature.signer,\\n     *   - Signature.nonce,\\n     *   - Signature.expiry,\\n     *   - address of the loan type contract\\n     *   - chainId\\n     */\\n    struct Signature {\\n        uint256 nonce;\\n        uint256 expiry;\\n        address signer;\\n        bytes signature;\\n    }\\n\\n    /**\\n     * inclusive min and max Id ranges for collection offers on collections,\\n     * like ArtBlocks, where multiple collections are defined on one contract differentiated by id-ranges\\n     */\\n    struct CollectionIdRange {\\n        uint256 minId;\\n        uint256 maxId;\\n    }\\n\\n    /**\\n     * @notice Some extra parameters that the borrower needs to set when accepting an offer.\\n     *\\n     * @param revenueSharePartner - The address of the partner that will receive the revenue share.\\n     * @param referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.\\n     */\\n    struct BorrowerSettings {\\n        address revenueSharePartner;\\n        uint16 referralFeeInBasisPoints;\\n    }\\n}\\n\",\"keccak256\":\"0x5b34cadd1ddbfe45c67df3e8ce8d3960e0243632b71f20455ea99e993a828d80\",\"license\":\"BUSL-1.1\"},\"contracts/utils/NFTfiSigningUtils.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../loans/direct/loanTypes/LoanData.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\n\\n/**\\n * @title  NFTfiSigningUtils\\n * @author NFTfi\\n * @notice Helper contract for NFTfi. This contract manages verifying signatures from off-chain NFTfi orders.\\n * Based on the version of this same contract used on NFTfi V1\\n */\\nlibrary NFTfiSigningUtils {\\n    /* ********* */\\n    /* FUNCTIONS */\\n    /* ********* */\\n\\n    /**\\n     * @dev This function gets the current chain ID.\\n     */\\n    function getChainID() internal view returns (uint256) {\\n        uint256 id;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n\\n    /**\\n     * @notice This function is when the borrower accepts a lender's offer, to validate the lender's signature that the\\n     * lender provided off-chain to verify that it did indeed made such offer.\\n     *\\n     * @param _offer - The offer struct containing:\\n     * - loanERC20Denomination: The address of the ERC20 contract of the currency being used as principal/interest\\n     * for this loan.\\n     * - loanPrincipalAmount: The original sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * - maximumRepaymentAmount: The maximum amount of money that the borrower would be required to retrieve their\\n     * collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have\\n     * to pay this amount to retrieve their collateral, regardless of whether they repay early.\\n     * - nftCollateralContract: The address of the ERC721 contract of the NFT collateral.\\n     * - nftCollateralId: The ID within the NFTCollateralContract for the NFT being used as collateral for this\\n     * loan. The NFT is stored within this contract during the duration of the loan.\\n     * - referrer: The address of the referrer who found the lender matching the listing, Zero address to signal\\n     * this there is no referrer.\\n     * - loanDuration: The amount of time (measured in seconds) that can elapse before the lender can liquidate the\\n     * loan and seize the underlying collateral NFT.\\n     * - loanInterestRateForDurationInBasisPoints: This is the interest rate (measured in basis points, e.g.\\n     * hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan\\n     * or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and\\n     * is irrelevant so it should be set to 0.\\n     * - loanAdminFeeInBasisPoints: The percent (measured in basis points) of the interest earned that will be\\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\\n     * earned.\\n     * @param _signature - The signature structure containing:\\n     * - signer: The address of the signer. The borrower for `acceptOffer`\\n     * - nonce: The nonce referred here is not the same as an Ethereum account's nonce.\\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\\n     * off-chain order. Each nonce can be used at most once per\\u00a0user within NFTfi, regardless of whether they are the\\n     * lender or the borrower in that situation. This serves two purposes:\\n     *   - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\\n     *   - Second, it allows a user to cancel an off-chain order by calling\\n     * NFTfi.cancelLoanCommitmentBeforeLoanHasBegun(), which marks the nonce as used and prevents any future loan from\\n     * using the user's off-chain order that contains that nonce.\\n     * - expiry: Date when the signature expires\\n     * - signature: The ECDSA signature of the lender, obtained off-chain ahead of time, signing the following\\n     * combination of parameters:\\n     *   - offer.loanERC20Denomination\\n     *   - offer.loanPrincipalAmount\\n     *   - offer.maximumRepaymentAmount\\n     *   - offer.nftCollateralContract\\n     *   - offer.nftCollateralId\\n     *   - offer.referrer\\n     *   - offer.loanDuration\\n     *   - offer.loanAdminFeeInBasisPoints\\n     *   - signature.signer,\\n     *   - signature.nonce,\\n     *   - signature.expiry,\\n     *   - address of this contract\\n     *   - chainId\\n     */\\n    function isValidLenderSignature(LoanData.Offer memory _offer, LoanData.Signature memory _signature)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return isValidLenderSignature(_offer, _signature, address(this));\\n    }\\n\\n    /**\\n     * @dev This function overload the previous function to allow the caller to specify the address of the contract\\n     *\\n     */\\n    function isValidLenderSignature(\\n        LoanData.Offer memory _offer,\\n        LoanData.Signature memory _signature,\\n        address _loanContract\\n    ) public view returns (bool) {\\n        require(block.timestamp <= _signature.expiry, \\\"Lender Signature has expired\\\");\\n        require(_loanContract != address(0), \\\"Loan is zero address\\\");\\n        if (_signature.signer == address(0)) {\\n            return false;\\n        } else {\\n            bytes32 message = keccak256(\\n                abi.encodePacked(getEncodedOffer(_offer), getEncodedSignature(_signature), _loanContract, getChainID())\\n            );\\n\\n            return\\n                SignatureChecker.isValidSignatureNow(\\n                    _signature.signer,\\n                    ECDSA.toEthSignedMessageHash(message),\\n                    _signature.signature\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @notice This function is called in renegotiateLoan() to validate the lender's signature that the lender provided\\n     * off-chain to verify that they did indeed want to agree to this loan renegotiation according to these terms.\\n     *\\n     * @param _loanId - The unique identifier for the loan to be renegotiated\\n     * @param _newLoanDuration - The new amount of time (measured in seconds) that can elapse before the lender can\\n     * liquidate the loan and seize the underlying collateral NFT.\\n     * @param _newMaximumRepaymentAmount - The new maximum amount of money that the borrower would be required to\\n     * retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The\\n     * borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay\\n     * early.\\n     * @param _renegotiationFee Agreed upon fee in ether that borrower pays for the lender for the renegitiation\\n     * @param _signature - The signature structure containing:\\n     * - signer: The address of the signer. The borrower for `acceptOffer`\\n     * - nonce: The nonce referred here is not the same as an Ethereum account's nonce.\\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\\n     * off-chain order. Each nonce can be used at most once per\\u00a0user within NFTfi, regardless of whether they are the\\n     * lender or the borrower in that situation. This serves two purposes:\\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\\n     * , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\\n     * that nonce.\\n     * - expiry - The date when the renegotiation offer expires\\n     * - lenderSignature - The ECDSA signature of the lender, obtained off-chain ahead of time, signing the\\n     * following combination of parameters:\\n     * - _loanId\\n     * - _newLoanDuration\\n     * - _newMaximumRepaymentAmount\\n     * - _lender\\n     * - _lenderNonce\\n     * - _expiry\\n     * - address of this contract\\n     * - chainId\\n     */\\n    function isValidLenderRenegotiationSignature(\\n        uint256 _loanId,\\n        uint32 _newLoanDuration,\\n        uint256 _newMaximumRepaymentAmount,\\n        uint256 _renegotiationFee,\\n        LoanData.Signature memory _signature\\n    ) external view returns (bool) {\\n        return\\n            isValidLenderRenegotiationSignature(\\n                _loanId,\\n                _newLoanDuration,\\n                _newMaximumRepaymentAmount,\\n                _renegotiationFee,\\n                _signature,\\n                address(this)\\n            );\\n    }\\n\\n    /**\\n     * @dev This function overload the previous function to allow the caller to specify the address of the contract\\n     *\\n     */\\n    function isValidLenderRenegotiationSignature(\\n        uint256 _loanId,\\n        uint32 _newLoanDuration,\\n        uint256 _newMaximumRepaymentAmount,\\n        uint256 _renegotiationFee,\\n        LoanData.Signature memory _signature,\\n        address _loanContract\\n    ) public view returns (bool) {\\n        require(block.timestamp <= _signature.expiry, \\\"Renegotiation Signature expired\\\");\\n        require(_loanContract != address(0), \\\"Loan is zero address\\\");\\n        if (_signature.signer == address(0)) {\\n            return false;\\n        } else {\\n            bytes32 message = keccak256(\\n                abi.encodePacked(\\n                    _loanId,\\n                    _newLoanDuration,\\n                    _newMaximumRepaymentAmount,\\n                    _renegotiationFee,\\n                    getEncodedSignature(_signature),\\n                    _loanContract,\\n                    getChainID()\\n                )\\n            );\\n\\n            return\\n                SignatureChecker.isValidSignatureNow(\\n                    _signature.signer,\\n                    ECDSA.toEthSignedMessageHash(message),\\n                    _signature.signature\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @dev We need this to avoid stack too deep errors.\\n     */\\n    function getEncodedOffer(LoanData.Offer memory _offer) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                _offer.loanERC20Denomination,\\n                _offer.loanPrincipalAmount,\\n                _offer.maximumRepaymentAmount,\\n                _offer.nftCollateralContract,\\n                _offer.nftCollateralId,\\n                _offer.referrer,\\n                _offer.loanDuration,\\n                _offer.loanAdminFeeInBasisPoints\\n            );\\n    }\\n\\n    /**\\n     * @dev We need this to avoid stack too deep errors.\\n     */\\n    function getEncodedSignature(LoanData.Signature memory _signature) internal pure returns (bytes memory) {\\n        return abi.encodePacked(_signature.signer, _signature.nonce, _signature.expiry);\\n    }\\n}\\n\",\"keccak256\":\"0x742f8c9af4c498712d21f45b3813a19d502c89433dadf46781ea3fc7847bbd19\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x610b9161003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100565760003560e01c80636ab81ec01461005b57806387c0a57314610082578063d06ff74114610095578063eb2ac63f146100a8575b600080fd5b61006e610069366004610862565b6100bb565b604051901515815260200160405180910390f35b61006e6100903660046108c3565b6101bd565b61006e6100a336600461093c565b6102b1565b61006e6100b63660046109a6565b6102c1565b600082602001514211156101165760405162461bcd60e51b815260206004820152601c60248201527f4c656e646572205369676e61747572652068617320657870697265640000000060448201526064015b60405180910390fd5b6001600160a01b03821661013c5760405162461bcd60e51b815260040161010d906109f6565b60408301516001600160a01b0316610156575060006101b6565b6000610161856102ce565b61016a8561038d565b844660405160200161017f9493929190610a48565b6040516020818303038152906040528051906020012090506101b284604001516101a8836103d0565b8660600151610403565b9150505b9392505050565b600082602001514211156102135760405162461bcd60e51b815260206004820152601f60248201527f52656e65676f74696174696f6e205369676e6174757265206578706972656400604482015260640161010d565b6001600160a01b0382166102395760405162461bcd60e51b815260040161010d906109f6565b60408301516001600160a01b0316610253575060006102a7565b6000878787876102628861038d565b874660405160200161027a9796959493929190610a93565b6040516020818303038152906040528051906020012090506102a384604001516101a8836103d0565b9150505b9695505050505050565b60006102a78686868686306101bd565b60006101b68383306100bb565b60608160c0015182600001518360200151846060015185604001518660e0015187608001518860a00151604051602001610377989796959493929190606098891b6001600160601b031990811682526014820198909852603481019690965293871b86166054860152606885019290925290941b909216608882015260e09290921b6001600160e01b031916609c83015260f01b6001600160f01b03191660a082015260a20190565b6040516020818303038152906040529050919050565b60608160400151826000015183602001516040516020016103779392919060609390931b6001600160601b03191683526014830191909152603482015260540190565b7f19457468657265756d205369676e6564204d6573736167653a0a3332000000006000908152601c91909152603c902090565b6000806000610412858561045a565b9092509050600081600481111561042b5761042b610aff565b1480156104495750856001600160a01b0316826001600160a01b0316145b806102a757506102a786868661049f565b60008082516041036104905760208301516040840151606085015160001a6104848782858561058b565b94509450505050610498565b506000905060025b9250929050565b6000806000856001600160a01b0316631626ba7e60e01b86866040516024016104c9929190610b15565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516105079190610b4f565b600060405180830381855afa9150503d8060008114610542576040519150601f19603f3d011682016040523d82523d6000602084013e610547565b606091505b509150915081801561055b57506020815110155b80156102a757508051630b135d3f60e11b906105809083016020908101908401610b6b565b149695505050505050565b6000806fa2a8918ca85bafe22016d0b997e4df60600160ff1b038311156105b8575060009050600361063c565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa15801561060c573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166106355760006001925092505061063c565b9150600090505b94509492505050565b634e487b7160e01b600052604160045260246000fd5b60405161010081016001600160401b038111828210171561067e5761067e610645565b60405290565b604051608081016001600160401b038111828210171561067e5761067e610645565b604051601f8201601f191681016001600160401b03811182821017156106ce576106ce610645565b604052919050565b80356001600160a01b03811681146106ed57600080fd5b919050565b803563ffffffff811681146106ed57600080fd5b6000610100828403121561071957600080fd5b61072161065b565b9050813581526020820135602082015260408201356040820152610747606083016106d6565b6060820152610758608083016106f2565b608082015260a082013561ffff8116811461077257600080fd5b60a082015261078360c083016106d6565b60c082015261079460e083016106d6565b60e082015292915050565b6000608082840312156107b157600080fd5b6107b9610684565b905081358152602080830135818301526107d5604084016106d6565b604083015260608301356001600160401b03808211156107f457600080fd5b818501915085601f83011261080857600080fd5b81358181111561081a5761081a610645565b61082c601f8201601f191685016106a6565b9150808252868482850101111561084257600080fd5b808484018584013760008482840101525080606085015250505092915050565b6000806000610140848603121561087857600080fd5b6108828585610706565b92506101008401356001600160401b0381111561089e57600080fd5b6108aa8682870161079f565b9250506108ba61012085016106d6565b90509250925092565b60008060008060008060c087890312156108dc57600080fd5b863595506108ec602088016106f2565b9450604087013593506060870135925060808701356001600160401b0381111561091557600080fd5b61092189828a0161079f565b92505061093060a088016106d6565b90509295509295509295565b600080600080600060a0868803121561095457600080fd5b85359450610964602087016106f2565b9350604086013592506060860135915060808601356001600160401b0381111561098d57600080fd5b6109998882890161079f565b9150509295509295909350565b60008061012083850312156109ba57600080fd5b6109c48484610706565b91506101008301356001600160401b038111156109e057600080fd5b6109ec8582860161079f565b9150509250929050565b6020808252601490820152734c6f616e206973207a65726f206164647265737360601b604082015260600190565b60005b83811015610a3f578181015183820152602001610a27565b50506000910152565b60008551610a5a818460208a01610a24565b855190830190610a6e818360208a01610a24565b60609590951b6001600160601b03191694019384525050601482015260340192915050565b87815263ffffffff60e01b8760e01b16602082015285602482015284604482015260008451610ac9816064850160208901610a24565b80830190506bffffffffffffffffffffffff198560601b1660648201528360788201526098810191505098975050505050505050565b634e487b7160e01b600052602160045260246000fd5b8281526040602082015260008251806040840152610b3a816060850160208701610a24565b601f01601f1916919091016060019392505050565b60008251610b61818460208701610a24565b9190910192915050565b600060208284031215610b7d57600080fd5b505191905056fea164736f6c6343000813000a",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100565760003560e01c80636ab81ec01461005b57806387c0a57314610082578063d06ff74114610095578063eb2ac63f146100a8575b600080fd5b61006e610069366004610862565b6100bb565b604051901515815260200160405180910390f35b61006e6100903660046108c3565b6101bd565b61006e6100a336600461093c565b6102b1565b61006e6100b63660046109a6565b6102c1565b600082602001514211156101165760405162461bcd60e51b815260206004820152601c60248201527f4c656e646572205369676e61747572652068617320657870697265640000000060448201526064015b60405180910390fd5b6001600160a01b03821661013c5760405162461bcd60e51b815260040161010d906109f6565b60408301516001600160a01b0316610156575060006101b6565b6000610161856102ce565b61016a8561038d565b844660405160200161017f9493929190610a48565b6040516020818303038152906040528051906020012090506101b284604001516101a8836103d0565b8660600151610403565b9150505b9392505050565b600082602001514211156102135760405162461bcd60e51b815260206004820152601f60248201527f52656e65676f74696174696f6e205369676e6174757265206578706972656400604482015260640161010d565b6001600160a01b0382166102395760405162461bcd60e51b815260040161010d906109f6565b60408301516001600160a01b0316610253575060006102a7565b6000878787876102628861038d565b874660405160200161027a9796959493929190610a93565b6040516020818303038152906040528051906020012090506102a384604001516101a8836103d0565b9150505b9695505050505050565b60006102a78686868686306101bd565b60006101b68383306100bb565b60608160c0015182600001518360200151846060015185604001518660e0015187608001518860a00151604051602001610377989796959493929190606098891b6001600160601b031990811682526014820198909852603481019690965293871b86166054860152606885019290925290941b909216608882015260e09290921b6001600160e01b031916609c83015260f01b6001600160f01b03191660a082015260a20190565b6040516020818303038152906040529050919050565b60608160400151826000015183602001516040516020016103779392919060609390931b6001600160601b03191683526014830191909152603482015260540190565b7f19457468657265756d205369676e6564204d6573736167653a0a3332000000006000908152601c91909152603c902090565b6000806000610412858561045a565b9092509050600081600481111561042b5761042b610aff565b1480156104495750856001600160a01b0316826001600160a01b0316145b806102a757506102a786868661049f565b60008082516041036104905760208301516040840151606085015160001a6104848782858561058b565b94509450505050610498565b506000905060025b9250929050565b6000806000856001600160a01b0316631626ba7e60e01b86866040516024016104c9929190610b15565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516105079190610b4f565b600060405180830381855afa9150503d8060008114610542576040519150601f19603f3d011682016040523d82523d6000602084013e610547565b606091505b509150915081801561055b57506020815110155b80156102a757508051630b135d3f60e11b906105809083016020908101908401610b6b565b149695505050505050565b6000806fa2a8918ca85bafe22016d0b997e4df60600160ff1b038311156105b8575060009050600361063c565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa15801561060c573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166106355760006001925092505061063c565b9150600090505b94509492505050565b634e487b7160e01b600052604160045260246000fd5b60405161010081016001600160401b038111828210171561067e5761067e610645565b60405290565b604051608081016001600160401b038111828210171561067e5761067e610645565b604051601f8201601f191681016001600160401b03811182821017156106ce576106ce610645565b604052919050565b80356001600160a01b03811681146106ed57600080fd5b919050565b803563ffffffff811681146106ed57600080fd5b6000610100828403121561071957600080fd5b61072161065b565b9050813581526020820135602082015260408201356040820152610747606083016106d6565b6060820152610758608083016106f2565b608082015260a082013561ffff8116811461077257600080fd5b60a082015261078360c083016106d6565b60c082015261079460e083016106d6565b60e082015292915050565b6000608082840312156107b157600080fd5b6107b9610684565b905081358152602080830135818301526107d5604084016106d6565b604083015260608301356001600160401b03808211156107f457600080fd5b818501915085601f83011261080857600080fd5b81358181111561081a5761081a610645565b61082c601f8201601f191685016106a6565b9150808252868482850101111561084257600080fd5b808484018584013760008482840101525080606085015250505092915050565b6000806000610140848603121561087857600080fd5b6108828585610706565b92506101008401356001600160401b0381111561089e57600080fd5b6108aa8682870161079f565b9250506108ba61012085016106d6565b90509250925092565b60008060008060008060c087890312156108dc57600080fd5b863595506108ec602088016106f2565b9450604087013593506060870135925060808701356001600160401b0381111561091557600080fd5b61092189828a0161079f565b92505061093060a088016106d6565b90509295509295509295565b600080600080600060a0868803121561095457600080fd5b85359450610964602087016106f2565b9350604086013592506060860135915060808601356001600160401b0381111561098d57600080fd5b6109998882890161079f565b9150509295509295909350565b60008061012083850312156109ba57600080fd5b6109c48484610706565b91506101008301356001600160401b038111156109e057600080fd5b6109ec8582860161079f565b9150509250929050565b6020808252601490820152734c6f616e206973207a65726f206164647265737360601b604082015260600190565b60005b83811015610a3f578181015183820152602001610a27565b50506000910152565b60008551610a5a818460208a01610a24565b855190830190610a6e818360208a01610a24565b60609590951b6001600160601b03191694019384525050601482015260340192915050565b87815263ffffffff60e01b8760e01b16602082015285602482015284604482015260008451610ac9816064850160208901610a24565b80830190506bffffffffffffffffffffffff198560601b1660648201528360788201526098810191505098975050505050505050565b634e487b7160e01b600052602160045260246000fd5b8281526040602082015260008251806040840152610b3a816060850160208701610a24565b601f01601f1916919091016060019392505050565b60008251610b61818460208701610a24565b9190910192915050565b600060208284031215610b7d57600080fd5b505191905056fea164736f6c6343000813000a",
  "devdoc": {
    "author": "NFTfi",
    "kind": "dev",
    "methods": {
      "isValidLenderRenegotiationSignature(uint256,uint32,uint256,uint256,LoanData.Signature)": {
        "params": {
          "_loanId": "- The unique identifier for the loan to be renegotiated",
          "_newLoanDuration": "- The new amount of time (measured in seconds) that can elapse before the lender can liquidate the loan and seize the underlying collateral NFT.",
          "_newMaximumRepaymentAmount": "- The new maximum amount of money that the borrower would be required to retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay early.",
          "_renegotiationFee": "Agreed upon fee in ether that borrower pays for the lender for the renegitiation",
          "_signature": "- The signature structure containing: - signer: The address of the signer. The borrower for `acceptOffer` - nonce: The nonce referred here is not the same as an Ethereum account's nonce. We are referring instead to a nonce that is used by the lender or the borrower when they are first signing off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an off-chain order. Each nonce can be used at most once peruser within NFTfi, regardless of whether they are the lender or the borrower in that situation. This serves two purposes: - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once. - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun() , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains that nonce. - expiry - The date when the renegotiation offer expires - lenderSignature - The ECDSA signature of the lender, obtained off-chain ahead of time, signing the following combination of parameters: - _loanId - _newLoanDuration - _newMaximumRepaymentAmount - _lender - _lenderNonce - _expiry - address of this contract - chainId"
        }
      },
      "isValidLenderRenegotiationSignature(uint256,uint32,uint256,uint256,LoanData.Signature,address)": {
        "details": "This function overload the previous function to allow the caller to specify the address of the contract"
      },
      "isValidLenderSignature(LoanData.Offer,LoanData.Signature)": {
        "params": {
          "_offer": "- The offer struct containing: - loanERC20Denomination: The address of the ERC20 contract of the currency being used as principal/interest for this loan. - loanPrincipalAmount: The original sum of money transferred from lender to borrower at the beginning of the loan, measured in loanERC20Denomination's smallest units. - maximumRepaymentAmount: The maximum amount of money that the borrower would be required to retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay early. - nftCollateralContract: The address of the ERC721 contract of the NFT collateral. - nftCollateralId: The ID within the NFTCollateralContract for the NFT being used as collateral for this loan. The NFT is stored within this contract during the duration of the loan. - referrer: The address of the referrer who found the lender matching the listing, Zero address to signal this there is no referrer. - loanDuration: The amount of time (measured in seconds) that can elapse before the lender can liquidate the loan and seize the underlying collateral NFT. - loanInterestRateForDurationInBasisPoints: This is the interest rate (measured in basis points, e.g. hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and is irrelevant so it should be set to 0. - loanAdminFeeInBasisPoints: The percent (measured in basis points) of the interest earned that will be taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest earned.",
          "_signature": "- The signature structure containing: - signer: The address of the signer. The borrower for `acceptOffer` - nonce: The nonce referred here is not the same as an Ethereum account's nonce. We are referring instead to a nonce that is used by the lender or the borrower when they are first signing off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an off-chain order. Each nonce can be used at most once peruser within NFTfi, regardless of whether they are the lender or the borrower in that situation. This serves two purposes:   - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.   - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun(), which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains that nonce. - expiry: Date when the signature expires - signature: The ECDSA signature of the lender, obtained off-chain ahead of time, signing the following combination of parameters:   - offer.loanERC20Denomination   - offer.loanPrincipalAmount   - offer.maximumRepaymentAmount   - offer.nftCollateralContract   - offer.nftCollateralId   - offer.referrer   - offer.loanDuration   - offer.loanAdminFeeInBasisPoints   - signature.signer,   - signature.nonce,   - signature.expiry,   - address of this contract   - chainId"
        }
      },
      "isValidLenderSignature(LoanData.Offer,LoanData.Signature,address)": {
        "details": "This function overload the previous function to allow the caller to specify the address of the contract"
      }
    },
    "title": "NFTfiSigningUtils",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "isValidLenderRenegotiationSignature(uint256,uint32,uint256,uint256,LoanData.Signature)": {
        "notice": "This function is called in renegotiateLoan() to validate the lender's signature that the lender provided off-chain to verify that they did indeed want to agree to this loan renegotiation according to these terms."
      },
      "isValidLenderSignature(LoanData.Offer,LoanData.Signature)": {
        "notice": "This function is when the borrower accepts a lender's offer, to validate the lender's signature that the lender provided off-chain to verify that it did indeed made such offer."
      }
    },
    "notice": "Helper contract for NFTfi. This contract manages verifying signatures from off-chain NFTfi orders. Based on the version of this same contract used on NFTfi V1",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}