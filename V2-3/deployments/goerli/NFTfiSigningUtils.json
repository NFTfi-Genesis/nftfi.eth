{
  "address": "0x6AFd80bBc24123Ab9ec630b239D0DEFb40D35e38",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_loanId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "_newLoanDuration",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "_newMaximumRepaymentAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_renegotiationFee",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "signer",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct LoanData.Signature",
          "name": "_signature",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "_loanContract",
          "type": "address"
        }
      ],
      "name": "isValidLenderRenegotiationSignature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_loanId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "_newLoanDuration",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "_newMaximumRepaymentAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_renegotiationFee",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "signer",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct LoanData.Signature",
          "name": "_signature",
          "type": "tuple"
        }
      ],
      "name": "isValidLenderRenegotiationSignature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "loanPrincipalAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maximumRepaymentAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nftCollateralId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "nftCollateralContract",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "loanDuration",
              "type": "uint32"
            },
            {
              "internalType": "uint16",
              "name": "loanAdminFeeInBasisPoints",
              "type": "uint16"
            },
            {
              "internalType": "address",
              "name": "loanERC20Denomination",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "referrer",
              "type": "address"
            }
          ],
          "internalType": "struct LoanData.Offer",
          "name": "_offer",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "signer",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct LoanData.Signature",
          "name": "_signature",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "_loanContract",
          "type": "address"
        }
      ],
      "name": "isValidLenderSignature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "loanPrincipalAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maximumRepaymentAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nftCollateralId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "nftCollateralContract",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "loanDuration",
              "type": "uint32"
            },
            {
              "internalType": "uint16",
              "name": "loanAdminFeeInBasisPoints",
              "type": "uint16"
            },
            {
              "internalType": "address",
              "name": "loanERC20Denomination",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "referrer",
              "type": "address"
            }
          ],
          "internalType": "struct LoanData.Offer",
          "name": "_offer",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "signer",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct LoanData.Signature",
          "name": "_signature",
          "type": "tuple"
        }
      ],
      "name": "isValidLenderSignature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xe9afdced7451254dee3325fd08a30459827ed3db0754c2fe45e4671d6aad67e6",
  "receipt": {
    "to": null,
    "from": "0x02e037F56728E947e92Af2c05baF7FeF387Ddd06",
    "contractAddress": "0x6AFd80bBc24123Ab9ec630b239D0DEFb40D35e38",
    "transactionIndex": 3,
    "gasUsed": "742007",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc711e53f697bb2183e1cc0b80f3485c7cec9c1051d33062cd63347fec3602e6d",
    "transactionHash": "0xe9afdced7451254dee3325fd08a30459827ed3db0754c2fe45e4671d6aad67e6",
    "logs": [],
    "blockNumber": 9337967,
    "cumulativeGasUsed": "835497",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "54de0b2a48f04d02d32721198484cdf8",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_newLoanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_newMaximumRepaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_renegotiationFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LoanData.Signature\",\"name\":\"_signature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_loanContract\",\"type\":\"address\"}],\"name\":\"isValidLenderRenegotiationSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_newLoanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_newMaximumRepaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_renegotiationFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LoanData.Signature\",\"name\":\"_signature\",\"type\":\"tuple\"}],\"name\":\"isValidLenderRenegotiationSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRepaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"loanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"loanAdminFeeInBasisPoints\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"loanERC20Denomination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"internalType\":\"struct LoanData.Offer\",\"name\":\"_offer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LoanData.Signature\",\"name\":\"_signature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_loanContract\",\"type\":\"address\"}],\"name\":\"isValidLenderSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRepaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"loanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"loanAdminFeeInBasisPoints\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"loanERC20Denomination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"internalType\":\"struct LoanData.Offer\",\"name\":\"_offer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct LoanData.Signature\",\"name\":\"_signature\",\"type\":\"tuple\"}],\"name\":\"isValidLenderSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"NFTfi\",\"kind\":\"dev\",\"methods\":{\"isValidLenderRenegotiationSignature(uint256,uint32,uint256,uint256,LoanData.Signature)\":{\"params\":{\"_loanId\":\"- The unique identifier for the loan to be renegotiated\",\"_newLoanDuration\":\"- The new amount of time (measured in seconds) that can elapse before the lender can liquidate the loan and seize the underlying collateral NFT.\",\"_newMaximumRepaymentAmount\":\"- The new maximum amount of money that the borrower would be required to retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay early.\",\"_renegotiationFee\":\"Agreed upon fee in ether that borrower pays for the lender for the renegitiation\",\"_signature\":\"- The signature structure containing: - signer: The address of the signer. The borrower for `acceptOffer` - nonce: The nonce referred here is not the same as an Ethereum account's nonce. We are referring instead to a nonce that is used by the lender or the borrower when they are first signing off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an off-chain order. Each nonce can be used at most once per\\u00a0user within NFTfi, regardless of whether they are the lender or the borrower in that situation. This serves two purposes: - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once. - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun() , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains that nonce. - expiry - The date when the renegotiation offer expires - lenderSignature - The ECDSA signature of the lender, obtained off-chain ahead of time, signing the following combination of parameters: - _loanId - _newLoanDuration - _newMaximumRepaymentAmount - _lender - _lenderNonce - _expiry - address of this contract - chainId\"}},\"isValidLenderRenegotiationSignature(uint256,uint32,uint256,uint256,LoanData.Signature,address)\":{\"details\":\"This function overload the previous function to allow the caller to specify the address of the contract\"},\"isValidLenderSignature(LoanData.Offer,LoanData.Signature)\":{\"params\":{\"_offer\":\"- The offer struct containing: - loanERC20Denomination: The address of the ERC20 contract of the currency being used as principal/interest for this loan. - loanPrincipalAmount: The original sum of money transferred from lender to borrower at the beginning of the loan, measured in loanERC20Denomination's smallest units. - maximumRepaymentAmount: The maximum amount of money that the borrower would be required to retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay early. - nftCollateralContract: The address of the ERC721 contract of the NFT collateral. - nftCollateralId: The ID within the NFTCollateralContract for the NFT being used as collateral for this loan. The NFT is stored within this contract during the duration of the loan. - referrer: The address of the referrer who found the lender matching the listing, Zero address to signal this there is no referrer. - loanDuration: The amount of time (measured in seconds) that can elapse before the lender can liquidate the loan and seize the underlying collateral NFT. - loanInterestRateForDurationInBasisPoints: This is the interest rate (measured in basis points, e.g. hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and is irrelevant so it should be set to 0. - loanAdminFeeInBasisPoints: The percent (measured in basis points) of the interest earned that will be taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest earned.\",\"_signature\":\"- The signature structure containing: - signer: The address of the signer. The borrower for `acceptOffer` - nonce: The nonce referred here is not the same as an Ethereum account's nonce. We are referring instead to a nonce that is used by the lender or the borrower when they are first signing off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an off-chain order. Each nonce can be used at most once per\\u00a0user within NFTfi, regardless of whether they are the lender or the borrower in that situation. This serves two purposes:   - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.   - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun(), which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains that nonce. - expiry: Date when the signature expires - signature: The ECDSA signature of the lender, obtained off-chain ahead of time, signing the following combination of parameters:   - offer.loanERC20Denomination   - offer.loanPrincipalAmount   - offer.maximumRepaymentAmount   - offer.nftCollateralContract   - offer.nftCollateralId   - offer.referrer   - offer.loanDuration   - offer.loanAdminFeeInBasisPoints   - signature.signer,   - signature.nonce,   - signature.expiry,   - address of this contract   - chainId\"}},\"isValidLenderSignature(LoanData.Offer,LoanData.Signature,address)\":{\"details\":\"This function overload the previous function to allow the caller to specify the address of the contract\"}},\"title\":\"NFTfiSigningUtils\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"isValidLenderRenegotiationSignature(uint256,uint32,uint256,uint256,LoanData.Signature)\":{\"notice\":\"This function is called in renegotiateLoan() to validate the lender's signature that the lender provided off-chain to verify that they did indeed want to agree to this loan renegotiation according to these terms.\"},\"isValidLenderSignature(LoanData.Offer,LoanData.Signature)\":{\"notice\":\"This function is when the borrower accepts a lender's offer, to validate the lender's signature that the lender provided off-chain to verify that it did indeed made such offer.\"}},\"notice\":\"Helper contract for NFTfi. This contract manages verifying signatures from off-chain NFTfi orders. Based on the version of this same contract used on NFTfi V1\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/utils/NFTfiSigningUtils.sol\":\"NFTfiSigningUtils\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x0705a4b1b86d7b0bd8432118f226ba139c44b9dcaba0a6eafba2dd7d0639c544\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x32c202bd28995dd20c4347b7c6467a6d3241c74c8ad3edcbb610cd9205916c45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x3c07f43e60e099b3b157243b3152722e73b80eeb7985c2cd73712828d7f7da29\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../Address.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\\n            return true;\\n        }\\n\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\\n    }\\n}\\n\",\"keccak256\":\"0xc8add71d80d05a1390e1c656686a0ea10ffaebfcc433cc397a63fd725f376b7e\",\"license\":\"MIT\"},\"contracts/loans/direct/loanTypes/LoanData.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title  LoanData\\n * @author NFTfi\\n * @notice An interface containg the main Loan struct shared by Direct Loans types.\\n */\\ninterface LoanData {\\n    /* ********** */\\n    /* DATA TYPES */\\n    /* ********** */\\n\\n    /**\\n     * @notice The main Loan Terms struct. This data is saved upon loan creation.\\n     *\\n     * @param loanERC20Denomination - The address of the ERC20 contract of the currency being used as principal/interest\\n     * for this loan.\\n     * @param loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * @param maximumRepaymentAmount - The maximum amount of money that the borrower would be required to retrieve their\\n     * collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have\\n     * to pay this amount to retrieve their collateral, regardless of whether they repay early.\\n     * @param nftCollateralContract - The address of the the NFT collateral contract.\\n     * @param nftCollateralWrapper - The NFTfi wrapper of the NFT collateral contract.\\n     * @param nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\\n     * loan. The NFT is stored within this contract during the duration of the loan.\\n     * @param loanStartTime - The block.timestamp when the loan first began (measured in seconds).\\n     * @param loanDuration - The amount of time (measured in seconds) that can elapse before the lender can liquidate\\n     * the loan and seize the underlying collateral NFT.\\n     * @param loanInterestRateForDurationInBasisPoints - This is the interest rate (measured in basis points, e.g.\\n     * hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan\\n     * or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and\\n     * is irrelevant so it should be set to 0.\\n     * @param loanAdminFeeInBasisPoints - The percent (measured in basis points) of the interest earned that will be\\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\\n     * earned.\\n     * @param borrower\\n     */\\n    struct LoanTerms {\\n        uint256 loanPrincipalAmount;\\n        uint256 maximumRepaymentAmount;\\n        uint256 nftCollateralId;\\n        address loanERC20Denomination;\\n        uint32 loanDuration;\\n        uint16 loanInterestRateForDurationInBasisPoints;\\n        uint16 loanAdminFeeInBasisPoints;\\n        address nftCollateralWrapper;\\n        uint64 loanStartTime;\\n        address nftCollateralContract;\\n        address borrower;\\n    }\\n\\n    /**\\n     * @notice Some extra Loan's settings struct. This data is saved upon loan creation.\\n     * We need this to avoid stack too deep errors.\\n     *\\n     * @param revenueSharePartner - The address of the partner that will receive the revenue share.\\n     * @param revenueShareInBasisPoints - The percent (measured in basis points) of the admin fee amount that will be\\n     * taken as a revenue share for a t\\n     * @param referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.he partner, at the moment\\n     * the loan is begun.\\n     */\\n    struct LoanExtras {\\n        address revenueSharePartner;\\n        uint16 revenueShareInBasisPoints;\\n        uint16 referralFeeInBasisPoints;\\n    }\\n\\n    /**\\n     * @notice The offer made by the lender. Used as parameter on both acceptOffer (initiated by the borrower)\\n     *\\n     * @param loanERC20Denomination - The address of the ERC20 contract of the currency being used as principal/interest\\n     * for this loan.\\n     * @param loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * @param maximumRepaymentAmount - The maximum amount of money that the borrower would be required to retrieve their\\n     *  collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always\\n     * have to pay this amount to retrieve their collateral, regardless of whether they repay early.\\n     * @param nftCollateralContract - The address of the ERC721 contract of the NFT collateral.\\n     * @param nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\\n     * loan. The NFT is stored within this contract during the duration of the loan.\\n     * @param referrer - The address of the referrer who found the lender matching the listing, Zero address to signal\\n     * this there is no referrer.\\n     * @param loanDuration - The amount of time (measured in seconds) that can elapse before the lender can liquidate\\n     * the loan and seize the underlying collateral NFT.\\n     * @param loanAdminFeeInBasisPoints - The percent (measured in basis points) of the interest earned that will be\\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\\n     * earned.\\n     */\\n    struct Offer {\\n        uint256 loanPrincipalAmount;\\n        uint256 maximumRepaymentAmount;\\n        uint256 nftCollateralId;\\n        address nftCollateralContract;\\n        uint32 loanDuration;\\n        uint16 loanAdminFeeInBasisPoints;\\n        address loanERC20Denomination;\\n        address referrer;\\n    }\\n\\n    /**\\n     * @notice Signature related params. Used as parameter on both acceptOffer (containing borrower signature)\\n     *\\n     * @param signer - The address of the signer. The borrower for `acceptOffer`\\n     * @param nonce - The nonce referred here is not the same as an Ethereum account's nonce.\\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\\n     * off-chain order. Each nonce can be used at most once per\\u00a0user within NFTfi, regardless of whether they are the\\n     * lender or the borrower in that situation. This serves two purposes:\\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\\n     * , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\\n     * that nonce.\\n     * @param expiry - Date when the signature expires\\n     * @param signature - The ECDSA signature of the borrower or the lender, obtained off-chain ahead of time, signing\\n     * the following combination of parameters:\\n     * - Lender:\\n     *   - Offer.loanERC20Denomination\\n     *   - Offer.loanPrincipalAmount\\n     *   - Offer.maximumRepaymentAmount\\n     *   - Offer.nftCollateralContract\\n     *   - Offer.nftCollateralId\\n     *   - Offer.referrer\\n     *   - Offer.loanDuration\\n     *   - Offer.loanAdminFeeInBasisPoints\\n     *   - Signature.signer,\\n     *   - Signature.nonce,\\n     *   - Signature.expiry,\\n     *   - address of the loan type contract\\n     *   - chainId\\n     */\\n    struct Signature {\\n        uint256 nonce;\\n        uint256 expiry;\\n        address signer;\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Signed message contents contents:\\n     *  - Signature.signature,\\n     *  - borrower address, - (msg.sender)\\n     *  - Offer.nftCollateralId, - (actual id here, since in CollateralOffer the original offer signature's id is 0)\\n     *  - Signature.signer, - porotocol address\\n     *  - Signature.expiry,\\n     */\\n    struct ProtocolSignature {\\n        uint256 expiry;\\n        address signer;\\n        bytes signature;\\n    }\\n\\n    /**\\n     * inclusive min and max Id ranges for collection offers on collections,\\n     * like ArtBlocks, where multiple collections are defined on one contract differentiated by id-ranges\\n     */\\n    struct CollectionIdRange {\\n        uint256 minId;\\n        uint256 maxId;\\n    }\\n\\n    /**\\n     * @notice Some extra parameters that the borrower needs to set when accepting an offer.\\n     *\\n     * @param revenueSharePartner - The address of the partner that will receive the revenue share.\\n     * @param referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.\\n     */\\n    struct BorrowerSettings {\\n        address revenueSharePartner;\\n        uint16 referralFeeInBasisPoints;\\n    }\\n}\\n\",\"keccak256\":\"0xbf97205ebecde91026a470773a0f4d6b196c367c7b1cc6f458eaca7fc635d717\",\"license\":\"BUSL-1.1\"},\"contracts/utils/NFTfiSigningUtils.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"../loans/direct/loanTypes/LoanData.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\n\\n/**\\n * @title  NFTfiSigningUtils\\n * @author NFTfi\\n * @notice Helper contract for NFTfi. This contract manages verifying signatures from off-chain NFTfi orders.\\n * Based on the version of this same contract used on NFTfi V1\\n */\\nlibrary NFTfiSigningUtils {\\n    /* ********* */\\n    /* FUNCTIONS */\\n    /* ********* */\\n\\n    /**\\n     * @dev This function gets the current chain ID.\\n     */\\n    function getChainID() internal view returns (uint256) {\\n        uint256 id;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n\\n    /**\\n     * @notice This function is when the borrower accepts a lender's offer, to validate the lender's signature that the\\n     * lender provided off-chain to verify that it did indeed made such offer.\\n     *\\n     * @param _offer - The offer struct containing:\\n     * - loanERC20Denomination: The address of the ERC20 contract of the currency being used as principal/interest\\n     * for this loan.\\n     * - loanPrincipalAmount: The original sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * - maximumRepaymentAmount: The maximum amount of money that the borrower would be required to retrieve their\\n     * collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have\\n     * to pay this amount to retrieve their collateral, regardless of whether they repay early.\\n     * - nftCollateralContract: The address of the ERC721 contract of the NFT collateral.\\n     * - nftCollateralId: The ID within the NFTCollateralContract for the NFT being used as collateral for this\\n     * loan. The NFT is stored within this contract during the duration of the loan.\\n     * - referrer: The address of the referrer who found the lender matching the listing, Zero address to signal\\n     * this there is no referrer.\\n     * - loanDuration: The amount of time (measured in seconds) that can elapse before the lender can liquidate the\\n     * loan and seize the underlying collateral NFT.\\n     * - loanInterestRateForDurationInBasisPoints: This is the interest rate (measured in basis points, e.g.\\n     * hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan\\n     * or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and\\n     * is irrelevant so it should be set to 0.\\n     * - loanAdminFeeInBasisPoints: The percent (measured in basis points) of the interest earned that will be\\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\\n     * earned.\\n     * @param _signature - The signature structure containing:\\n     * - signer: The address of the signer. The borrower for `acceptOffer`\\n     * - nonce: The nonce referred here is not the same as an Ethereum account's nonce.\\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\\n     * off-chain order. Each nonce can be used at most once per\\u00a0user within NFTfi, regardless of whether they are the\\n     * lender or the borrower in that situation. This serves two purposes:\\n     *   - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\\n     *   - Second, it allows a user to cancel an off-chain order by calling\\n     * NFTfi.cancelLoanCommitmentBeforeLoanHasBegun(), which marks the nonce as used and prevents any future loan from\\n     * using the user's off-chain order that contains that nonce.\\n     * - expiry: Date when the signature expires\\n     * - signature: The ECDSA signature of the lender, obtained off-chain ahead of time, signing the following\\n     * combination of parameters:\\n     *   - offer.loanERC20Denomination\\n     *   - offer.loanPrincipalAmount\\n     *   - offer.maximumRepaymentAmount\\n     *   - offer.nftCollateralContract\\n     *   - offer.nftCollateralId\\n     *   - offer.referrer\\n     *   - offer.loanDuration\\n     *   - offer.loanAdminFeeInBasisPoints\\n     *   - signature.signer,\\n     *   - signature.nonce,\\n     *   - signature.expiry,\\n     *   - address of this contract\\n     *   - chainId\\n     */\\n    function isValidLenderSignature(LoanData.Offer memory _offer, LoanData.Signature memory _signature)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return isValidLenderSignature(_offer, _signature, address(this));\\n    }\\n\\n    /**\\n     * @dev This function overload the previous function to allow the caller to specify the address of the contract\\n     *\\n     */\\n    function isValidLenderSignature(\\n        LoanData.Offer memory _offer,\\n        LoanData.Signature memory _signature,\\n        address _loanContract\\n    ) public view returns (bool) {\\n        require(block.timestamp <= _signature.expiry, \\\"Lender Signature has expired\\\");\\n        require(_loanContract != address(0), \\\"Loan is zero address\\\");\\n        if (_signature.signer == address(0)) {\\n            return false;\\n        } else {\\n            bytes32 message = keccak256(\\n                abi.encodePacked(getEncodedOffer(_offer), getEncodedSignature(_signature), _loanContract, getChainID())\\n            );\\n\\n            return\\n                SignatureChecker.isValidSignatureNow(\\n                    _signature.signer,\\n                    ECDSA.toEthSignedMessageHash(message),\\n                    _signature.signature\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @notice This function is called in renegotiateLoan() to validate the lender's signature that the lender provided\\n     * off-chain to verify that they did indeed want to agree to this loan renegotiation according to these terms.\\n     *\\n     * @param _loanId - The unique identifier for the loan to be renegotiated\\n     * @param _newLoanDuration - The new amount of time (measured in seconds) that can elapse before the lender can\\n     * liquidate the loan and seize the underlying collateral NFT.\\n     * @param _newMaximumRepaymentAmount - The new maximum amount of money that the borrower would be required to\\n     * retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The\\n     * borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay\\n     * early.\\n     * @param _renegotiationFee Agreed upon fee in ether that borrower pays for the lender for the renegitiation\\n     * @param _signature - The signature structure containing:\\n     * - signer: The address of the signer. The borrower for `acceptOffer`\\n     * - nonce: The nonce referred here is not the same as an Ethereum account's nonce.\\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\\n     * off-chain order. Each nonce can be used at most once per\\u00a0user within NFTfi, regardless of whether they are the\\n     * lender or the borrower in that situation. This serves two purposes:\\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\\n     * , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\\n     * that nonce.\\n     * - expiry - The date when the renegotiation offer expires\\n     * - lenderSignature - The ECDSA signature of the lender, obtained off-chain ahead of time, signing the\\n     * following combination of parameters:\\n     * - _loanId\\n     * - _newLoanDuration\\n     * - _newMaximumRepaymentAmount\\n     * - _lender\\n     * - _lenderNonce\\n     * - _expiry\\n     * - address of this contract\\n     * - chainId\\n     */\\n    function isValidLenderRenegotiationSignature(\\n        uint256 _loanId,\\n        uint32 _newLoanDuration,\\n        uint256 _newMaximumRepaymentAmount,\\n        uint256 _renegotiationFee,\\n        LoanData.Signature memory _signature\\n    ) external view returns (bool) {\\n        return\\n            isValidLenderRenegotiationSignature(\\n                _loanId,\\n                _newLoanDuration,\\n                _newMaximumRepaymentAmount,\\n                _renegotiationFee,\\n                _signature,\\n                address(this)\\n            );\\n    }\\n\\n    /**\\n     * @dev This function overload the previous function to allow the caller to specify the address of the contract\\n     *\\n     */\\n    function isValidLenderRenegotiationSignature(\\n        uint256 _loanId,\\n        uint32 _newLoanDuration,\\n        uint256 _newMaximumRepaymentAmount,\\n        uint256 _renegotiationFee,\\n        LoanData.Signature memory _signature,\\n        address _loanContract\\n    ) public view returns (bool) {\\n        require(block.timestamp <= _signature.expiry, \\\"Renegotiation Signature expired\\\");\\n        require(_loanContract != address(0), \\\"Loan is zero address\\\");\\n        if (_signature.signer == address(0)) {\\n            return false;\\n        } else {\\n            bytes32 message = keccak256(\\n                abi.encodePacked(\\n                    _loanId,\\n                    _newLoanDuration,\\n                    _newMaximumRepaymentAmount,\\n                    _renegotiationFee,\\n                    getEncodedSignature(_signature),\\n                    _loanContract,\\n                    getChainID()\\n                )\\n            );\\n\\n            return\\n                SignatureChecker.isValidSignatureNow(\\n                    _signature.signer,\\n                    ECDSA.toEthSignedMessageHash(message),\\n                    _signature.signature\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @dev We need this to avoid stack too deep errors.\\n     */\\n    function getEncodedOffer(LoanData.Offer memory _offer) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                _offer.loanERC20Denomination,\\n                _offer.loanPrincipalAmount,\\n                _offer.maximumRepaymentAmount,\\n                _offer.nftCollateralContract,\\n                _offer.nftCollateralId,\\n                _offer.referrer,\\n                _offer.loanDuration,\\n                _offer.loanAdminFeeInBasisPoints\\n            );\\n    }\\n\\n    /**\\n     * @dev We need this to avoid stack too deep errors.\\n     */\\n    function getEncodedSignature(LoanData.Signature memory _signature) internal pure returns (bytes memory) {\\n        return abi.encodePacked(_signature.signer, _signature.nonce, _signature.expiry);\\n    }\\n}\\n\",\"keccak256\":\"0xf658f22057da9a6664fdd15662129e6a8a5f0987e37a73f515006e50cc80a593\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x610c7461003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100565760003560e01c80636ab81ec01461005b57806387c0a57314610082578063d06ff74114610095578063eb2ac63f146100a8575b600080fd5b61006e610069366004610909565b6100bb565b604051901515815260200160405180910390f35b61006e6100903660046109d0565b6101bd565b61006e6100a3366004610968565b6102b1565b61006e6100b63660046108bb565b6102c1565b600082602001514211156101165760405162461bcd60e51b815260206004820152601c60248201527f4c656e646572205369676e61747572652068617320657870697265640000000060448201526064015b60405180910390fd5b6001600160a01b03821661013c5760405162461bcd60e51b815260040161010d90610b54565b60408301516001600160a01b0316610156575060006101b6565b6000610161856102ce565b61016a8561038d565b844660405160200161017f9493929190610a63565b6040516020818303038152906040528051906020012090506101b284604001516101a8836103d0565b8660600151610423565b9150505b9392505050565b600082602001514211156102135760405162461bcd60e51b815260206004820152601f60248201527f52656e65676f74696174696f6e205369676e6174757265206578706972656400604482015260640161010d565b6001600160a01b0382166102395760405162461bcd60e51b815260040161010d90610b54565b60408301516001600160a01b0316610253575060006102a7565b6000878787876102628861038d565b874660405160200161027a9796959493929190610aae565b6040516020818303038152906040528051906020012090506102a384604001516101a8836103d0565b9150505b9695505050505050565b60006102a78686868686306101bd565b60006101b68383306100bb565b60608160c0015182600001518360200151846060015185604001518660e0015187608001518860a00151604051602001610377989796959493929190606098891b6001600160601b031990811682526014820198909852603481019690965293871b86166054860152606885019290925290941b909216608882015260e09290921b6001600160e01b031916609c83015260f01b6001600160f01b03191660a082015260a20190565b6040516020818303038152906040529050919050565b60608160400151826000015183602001516040516020016103779392919060609390931b6001600160601b03191683526014830191909152603482015260540190565b6040517f19457468657265756d205369676e6564204d6573736167653a0a3332000000006020820152603c8101829052600090605c01604051602081830303815290604052805190602001209050919050565b6000806000610432858561057d565b9092509050600081600481111561045957634e487b7160e01b600052602160045260246000fd5b1480156104775750856001600160a01b0316826001600160a01b0316145b15610487576001925050506101b6565b600080876001600160a01b0316631626ba7e60e01b88886040516024016104af929190610b1a565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516104ed9190610a47565b600060405180830381855afa9150503d8060008114610528576040519150601f19603f3d011682016040523d82523d6000602084013e61052d565b606091505b5091509150818015610540575080516020145b801561057157508051630b135d3f60e11b906105659083016020908101908401610893565b6001600160e01b031916145b98975050505050505050565b6000808251604114156105b45760208301516040840151606085015160001a6105a8878285856105ed565b945094505050506105e6565b8251604014156105de57602083015160408401516105d38683836106d0565b9350935050506105e6565b506000905060025b9250929050565b6000806fa2a8918ca85bafe22016d0b997e4df60600160ff1b0383111561061a57506000905060036106c7565b8460ff16601b1415801561063257508460ff16601c14155b1561064357506000905060046106c7565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015610697573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166106c0576000600192509250506106c7565b9150600090505b94509492505050565b6000806001600160ff1b038316816106ed60ff86901c601b610bfd565b90506106fb878288856105ed565b935093505050935093915050565b80356001600160a01b038116811461072057600080fd5b919050565b60006101008284031215610737578081fd5b61073f610b82565b905081358152602082013560208201526040820135604082015261076560608301610709565b60608201526107766080830161087f565b608082015260a082013561ffff8116811461079057600080fd5b60a08201526107a160c08301610709565b60c08201526107b260e08301610709565b60e082015292915050565b6000608082840312156107ce578081fd5b6107d6610bab565b905081358152602080830135818301526107f260408401610709565b604083015260608301356001600160401b038082111561081157600080fd5b818501915085601f83011261082557600080fd5b81358181111561083757610837610c51565b610849601f8201601f19168501610bcd565b9150808252868482850101111561085f57600080fd5b808484018584013760008482840101525080606085015250505092915050565b803563ffffffff8116811461072057600080fd5b6000602082840312156108a4578081fd5b81516001600160e01b0319811681146101b6578182fd5b60008061012083850312156108ce578081fd5b6108d88484610725565b91506101008301356001600160401b038111156108f3578182fd5b6108ff858286016107bd565b9150509250929050565b6000806000610140848603121561091e578081fd5b6109288585610725565b92506101008401356001600160401b03811115610943578182fd5b61094f868287016107bd565b92505061095f6101208501610709565b90509250925092565b600080600080600060a0868803121561097f578081fd5b8535945061098f6020870161087f565b9350604086013592506060860135915060808601356001600160401b038111156109b7578182fd5b6109c3888289016107bd565b9150509295509295909350565b60008060008060008060c087890312156109e8578081fd5b863595506109f86020880161087f565b9450604087013593506060870135925060808701356001600160401b03811115610a20578182fd5b610a2c89828a016107bd565b925050610a3b60a08801610709565b90509295509295509295565b60008251610a59818460208701610c21565b9190910192915050565b60008551610a75818460208a01610c21565b855190830190610a89818360208a01610c21565b60609590951b6001600160601b03191694019384525050601482015260340192915050565b87815263ffffffff60e01b8760e01b16602082015285602482015284604482015260008451610ae4816064850160208901610c21565b80830190506bffffffffffffffffffffffff198560601b1660648201528360788201526098810191505098975050505050505050565b8281526040602082015260008251806040840152610b3f816060850160208701610c21565b601f01601f1916919091016060019392505050565b6020808252601490820152734c6f616e206973207a65726f206164647265737360601b604082015260600190565b60405161010081016001600160401b0381118282101715610ba557610ba5610c51565b60405290565b604051608081016001600160401b0381118282101715610ba557610ba5610c51565b604051601f8201601f191681016001600160401b0381118282101715610bf557610bf5610c51565b604052919050565b60008219821115610c1c57634e487b7160e01b81526011600452602481fd5b500190565b60005b83811015610c3c578181015183820152602001610c24565b83811115610c4b576000848401525b50505050565b634e487b7160e01b600052604160045260246000fdfea164736f6c6343000804000a",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100565760003560e01c80636ab81ec01461005b57806387c0a57314610082578063d06ff74114610095578063eb2ac63f146100a8575b600080fd5b61006e610069366004610909565b6100bb565b604051901515815260200160405180910390f35b61006e6100903660046109d0565b6101bd565b61006e6100a3366004610968565b6102b1565b61006e6100b63660046108bb565b6102c1565b600082602001514211156101165760405162461bcd60e51b815260206004820152601c60248201527f4c656e646572205369676e61747572652068617320657870697265640000000060448201526064015b60405180910390fd5b6001600160a01b03821661013c5760405162461bcd60e51b815260040161010d90610b54565b60408301516001600160a01b0316610156575060006101b6565b6000610161856102ce565b61016a8561038d565b844660405160200161017f9493929190610a63565b6040516020818303038152906040528051906020012090506101b284604001516101a8836103d0565b8660600151610423565b9150505b9392505050565b600082602001514211156102135760405162461bcd60e51b815260206004820152601f60248201527f52656e65676f74696174696f6e205369676e6174757265206578706972656400604482015260640161010d565b6001600160a01b0382166102395760405162461bcd60e51b815260040161010d90610b54565b60408301516001600160a01b0316610253575060006102a7565b6000878787876102628861038d565b874660405160200161027a9796959493929190610aae565b6040516020818303038152906040528051906020012090506102a384604001516101a8836103d0565b9150505b9695505050505050565b60006102a78686868686306101bd565b60006101b68383306100bb565b60608160c0015182600001518360200151846060015185604001518660e0015187608001518860a00151604051602001610377989796959493929190606098891b6001600160601b031990811682526014820198909852603481019690965293871b86166054860152606885019290925290941b909216608882015260e09290921b6001600160e01b031916609c83015260f01b6001600160f01b03191660a082015260a20190565b6040516020818303038152906040529050919050565b60608160400151826000015183602001516040516020016103779392919060609390931b6001600160601b03191683526014830191909152603482015260540190565b6040517f19457468657265756d205369676e6564204d6573736167653a0a3332000000006020820152603c8101829052600090605c01604051602081830303815290604052805190602001209050919050565b6000806000610432858561057d565b9092509050600081600481111561045957634e487b7160e01b600052602160045260246000fd5b1480156104775750856001600160a01b0316826001600160a01b0316145b15610487576001925050506101b6565b600080876001600160a01b0316631626ba7e60e01b88886040516024016104af929190610b1a565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516104ed9190610a47565b600060405180830381855afa9150503d8060008114610528576040519150601f19603f3d011682016040523d82523d6000602084013e61052d565b606091505b5091509150818015610540575080516020145b801561057157508051630b135d3f60e11b906105659083016020908101908401610893565b6001600160e01b031916145b98975050505050505050565b6000808251604114156105b45760208301516040840151606085015160001a6105a8878285856105ed565b945094505050506105e6565b8251604014156105de57602083015160408401516105d38683836106d0565b9350935050506105e6565b506000905060025b9250929050565b6000806fa2a8918ca85bafe22016d0b997e4df60600160ff1b0383111561061a57506000905060036106c7565b8460ff16601b1415801561063257508460ff16601c14155b1561064357506000905060046106c7565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015610697573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166106c0576000600192509250506106c7565b9150600090505b94509492505050565b6000806001600160ff1b038316816106ed60ff86901c601b610bfd565b90506106fb878288856105ed565b935093505050935093915050565b80356001600160a01b038116811461072057600080fd5b919050565b60006101008284031215610737578081fd5b61073f610b82565b905081358152602082013560208201526040820135604082015261076560608301610709565b60608201526107766080830161087f565b608082015260a082013561ffff8116811461079057600080fd5b60a08201526107a160c08301610709565b60c08201526107b260e08301610709565b60e082015292915050565b6000608082840312156107ce578081fd5b6107d6610bab565b905081358152602080830135818301526107f260408401610709565b604083015260608301356001600160401b038082111561081157600080fd5b818501915085601f83011261082557600080fd5b81358181111561083757610837610c51565b610849601f8201601f19168501610bcd565b9150808252868482850101111561085f57600080fd5b808484018584013760008482840101525080606085015250505092915050565b803563ffffffff8116811461072057600080fd5b6000602082840312156108a4578081fd5b81516001600160e01b0319811681146101b6578182fd5b60008061012083850312156108ce578081fd5b6108d88484610725565b91506101008301356001600160401b038111156108f3578182fd5b6108ff858286016107bd565b9150509250929050565b6000806000610140848603121561091e578081fd5b6109288585610725565b92506101008401356001600160401b03811115610943578182fd5b61094f868287016107bd565b92505061095f6101208501610709565b90509250925092565b600080600080600060a0868803121561097f578081fd5b8535945061098f6020870161087f565b9350604086013592506060860135915060808601356001600160401b038111156109b7578182fd5b6109c3888289016107bd565b9150509295509295909350565b60008060008060008060c087890312156109e8578081fd5b863595506109f86020880161087f565b9450604087013593506060870135925060808701356001600160401b03811115610a20578182fd5b610a2c89828a016107bd565b925050610a3b60a08801610709565b90509295509295509295565b60008251610a59818460208701610c21565b9190910192915050565b60008551610a75818460208a01610c21565b855190830190610a89818360208a01610c21565b60609590951b6001600160601b03191694019384525050601482015260340192915050565b87815263ffffffff60e01b8760e01b16602082015285602482015284604482015260008451610ae4816064850160208901610c21565b80830190506bffffffffffffffffffffffff198560601b1660648201528360788201526098810191505098975050505050505050565b8281526040602082015260008251806040840152610b3f816060850160208701610c21565b601f01601f1916919091016060019392505050565b6020808252601490820152734c6f616e206973207a65726f206164647265737360601b604082015260600190565b60405161010081016001600160401b0381118282101715610ba557610ba5610c51565b60405290565b604051608081016001600160401b0381118282101715610ba557610ba5610c51565b604051601f8201601f191681016001600160401b0381118282101715610bf557610bf5610c51565b604052919050565b60008219821115610c1c57634e487b7160e01b81526011600452602481fd5b500190565b60005b83811015610c3c578181015183820152602001610c24565b83811115610c4b576000848401525b50505050565b634e487b7160e01b600052604160045260246000fdfea164736f6c6343000804000a",
  "devdoc": {
    "author": "NFTfi",
    "kind": "dev",
    "methods": {
      "isValidLenderRenegotiationSignature(uint256,uint32,uint256,uint256,LoanData.Signature)": {
        "params": {
          "_loanId": "- The unique identifier for the loan to be renegotiated",
          "_newLoanDuration": "- The new amount of time (measured in seconds) that can elapse before the lender can liquidate the loan and seize the underlying collateral NFT.",
          "_newMaximumRepaymentAmount": "- The new maximum amount of money that the borrower would be required to retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay early.",
          "_renegotiationFee": "Agreed upon fee in ether that borrower pays for the lender for the renegitiation",
          "_signature": "- The signature structure containing: - signer: The address of the signer. The borrower for `acceptOffer` - nonce: The nonce referred here is not the same as an Ethereum account's nonce. We are referring instead to a nonce that is used by the lender or the borrower when they are first signing off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an off-chain order. Each nonce can be used at most once per user within NFTfi, regardless of whether they are the lender or the borrower in that situation. This serves two purposes: - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once. - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun() , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains that nonce. - expiry - The date when the renegotiation offer expires - lenderSignature - The ECDSA signature of the lender, obtained off-chain ahead of time, signing the following combination of parameters: - _loanId - _newLoanDuration - _newMaximumRepaymentAmount - _lender - _lenderNonce - _expiry - address of this contract - chainId"
        }
      },
      "isValidLenderRenegotiationSignature(uint256,uint32,uint256,uint256,LoanData.Signature,address)": {
        "details": "This function overload the previous function to allow the caller to specify the address of the contract"
      },
      "isValidLenderSignature(LoanData.Offer,LoanData.Signature)": {
        "params": {
          "_offer": "- The offer struct containing: - loanERC20Denomination: The address of the ERC20 contract of the currency being used as principal/interest for this loan. - loanPrincipalAmount: The original sum of money transferred from lender to borrower at the beginning of the loan, measured in loanERC20Denomination's smallest units. - maximumRepaymentAmount: The maximum amount of money that the borrower would be required to retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay early. - nftCollateralContract: The address of the ERC721 contract of the NFT collateral. - nftCollateralId: The ID within the NFTCollateralContract for the NFT being used as collateral for this loan. The NFT is stored within this contract during the duration of the loan. - referrer: The address of the referrer who found the lender matching the listing, Zero address to signal this there is no referrer. - loanDuration: The amount of time (measured in seconds) that can elapse before the lender can liquidate the loan and seize the underlying collateral NFT. - loanInterestRateForDurationInBasisPoints: This is the interest rate (measured in basis points, e.g. hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and is irrelevant so it should be set to 0. - loanAdminFeeInBasisPoints: The percent (measured in basis points) of the interest earned that will be taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest earned.",
          "_signature": "- The signature structure containing: - signer: The address of the signer. The borrower for `acceptOffer` - nonce: The nonce referred here is not the same as an Ethereum account's nonce. We are referring instead to a nonce that is used by the lender or the borrower when they are first signing off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an off-chain order. Each nonce can be used at most once per user within NFTfi, regardless of whether they are the lender or the borrower in that situation. This serves two purposes:   - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.   - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun(), which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains that nonce. - expiry: Date when the signature expires - signature: The ECDSA signature of the lender, obtained off-chain ahead of time, signing the following combination of parameters:   - offer.loanERC20Denomination   - offer.loanPrincipalAmount   - offer.maximumRepaymentAmount   - offer.nftCollateralContract   - offer.nftCollateralId   - offer.referrer   - offer.loanDuration   - offer.loanAdminFeeInBasisPoints   - signature.signer,   - signature.nonce,   - signature.expiry,   - address of this contract   - chainId"
        }
      },
      "isValidLenderSignature(LoanData.Offer,LoanData.Signature,address)": {
        "details": "This function overload the previous function to allow the caller to specify the address of the contract"
      }
    },
    "title": "NFTfiSigningUtils",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "isValidLenderRenegotiationSignature(uint256,uint32,uint256,uint256,LoanData.Signature)": {
        "notice": "This function is called in renegotiateLoan() to validate the lender's signature that the lender provided off-chain to verify that they did indeed want to agree to this loan renegotiation according to these terms."
      },
      "isValidLenderSignature(LoanData.Offer,LoanData.Signature)": {
        "notice": "This function is when the borrower accepts a lender's offer, to validate the lender's signature that the lender provided off-chain to verify that it did indeed made such offer."
      }
    },
    "notice": "Helper contract for NFTfi. This contract manages verifying signatures from off-chain NFTfi orders. Based on the version of this same contract used on NFTfi V1",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}